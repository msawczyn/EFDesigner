<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections.ObjectModel" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#@ include file="Dsl\Utilities.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Linq;
using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslValidation = global::Microsoft.VisualStudio.Modeling.Validation;
<#

	// Set variables used in the rest of the template

	// Use "this.DslLibrary" rather than "this.Dsl" here so it works with both types.
	string dslName = this.DslLibrary.Name;
	string namespaceString = this.DslLibrary.Namespace;
	XmlSerializationBehavior behavior = this.DslLibrary.XmlSerializationBehavior;
	string behaviorTypeName = behavior.GetRelativeName (namespaceString, true);

	// DslLibraries do no have root domain classes or editors, so the following 
	// variables will only be set for Dsls.
	Diagram diagram = null;
	DomainClass rootClass = null;
	string rootClassName = string.Empty;
	XmlSerializationDefinition definition = null;

	if (this.IsDsl)
	{

		// Calculate the name of the root domain class, if there is one.
		rootClass = this.Dsl.Editor.RootClass;
		rootClassName = rootClass.GetRelativeName (namespaceString, true);
		definition = this.Dsl.Editor.XmlSerializationDefinition;
		System.Diagnostics.Debug.Assert(behavior == this.Dsl.XmlSerializationBehavior, "Dsl.Editor.XmlSerializationBehavior and Dsl.XmlSerializationBehavior are not the same");


		diagram = this.Dsl.Diagram;
		if (diagram != null)
		{
#>
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;
<#
		}
	}
		
	// Add an empty line after using statements.
#>

<#



	OpenNamespace();
#>

partial class <#= this.DslLibrary.Name #>DomainModel
{
	///<Summary>
	/// Provide an implementation of the partial method to set up the serialization behavior for this model.
	///</Summary>
	///<remarks>
	/// This partial method is called from the constructor of the domain class.
	///</remarks>
	[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance","CA1822:MarkMembersAsStatic", Justification="Alternative implementations might need to reference instance variables, so not marked as static.")]
	partial void InitializeSerialization(DslModeling::Store store)
	{
		// Register the serializers and moniker resolver for this model
		<#= this.DslLibrary.Name #>SerializationHelper.Instance.InitializeSerialization(store);	
	}
}


/// <summary>
/// Helper class for serializing and deserializing <#= dslName #> models.
/// </summary>
public abstract partial class <#= dslName #>SerializationHelperBase
{
	#region Constructor
	/// <summary>
	/// Constructor
	/// </summary>
	protected <#= dslName #>SerializationHelperBase() { }
	#endregion
	
	#region Methods
	
	/// <summary>
	/// Ensure that moniker resolvers and domain element serializers are installed properly on the given store, 
	/// so that deserialization can be carried out correctly.
	/// </summary>
	/// <param name="store">Store on which moniker resolvers will be set up.</param>
	internal protected virtual void InitializeSerialization(DslModeling::Store store)
	{
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert(store != null);
		if (store == null)
			throw new global::System.ArgumentNullException("store");
		#endregion

		DslModeling::DomainXmlSerializerDirectory directory = this.GetDirectory(store);

		// Register the moniker resolver for this model, unless one is already registered
		DslModeling::IMonikerResolver monikerResolver = store.FindMonikerResolver(<#= dslName #>DomainModel.DomainModelId);
		if (monikerResolver == null)
		{
			monikerResolver = new <#= behaviorTypeName #>MonikerResolver(store, directory);
			store.AddMonikerResolver(<#= dslName #>DomainModel.DomainModelId, monikerResolver);
		}
		
		// Add serialization behaviors
		directory.AddBehavior(<#= behaviorTypeName #>.Instance);
	}

	/// <Summary>
	/// Called by the serialization helper to allow any necessary setup to be done on each load / save.
	/// </Summary>
	/// <param name="partition">The partition being serialized.</param>
	/// <param name="serializationContext">The current serialization context instance.</param>
	/// <param name="isLoading">Flag to indicate whether the file is being loaded or saved.</param>
	/// <Remarks>The base implementation does nothing</Remarks>
	protected virtual void InitializeSerializationContext(DslModeling::Partition partition, DslModeling::SerializationContext serializationContext, bool isLoading)
	{
	}

	/// <summary>
	/// Return the directory of serializers to use
	/// </summary>
	protected virtual DslModeling::DomainXmlSerializerDirectory GetDirectory(DslModeling::Store store)
	{
		// Just return the default serialization directory from the store
		return store.SerializerDirectory;
	}
		
	/// <summary>
	/// This method returns the moniker resolvers for each of the domain models in the store
	/// </summary>
	/// <param name="store">Store on which the moniker resolvers are set up.</param>
	internal protected virtual global::System.Collections.Generic.IDictionary<global::System.Guid, DslModeling::IMonikerResolver> GetMonikerResolvers(DslModeling::Store store)
	{
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert(store != null);
		if (store == null)
			throw new global::System.ArgumentNullException("store");
		#endregion
		
		global::System.Collections.Generic.Dictionary<global::System.Guid, DslModeling::IMonikerResolver> result = new global::System.Collections.Generic.Dictionary<global::System.Guid, DslModeling::IMonikerResolver>();
		foreach (DslModeling::DomainModelInfo modelInfo in store.DomainDataDirectory.DomainModels)
		{
			if (modelInfo.MonikerResolver != null)
			{
				result.Add(modelInfo.Id, modelInfo.MonikerResolver);
			}
		}
		
		return result;
	}

	/// <summary>
	/// Write extension element data inside the current XML element
	/// </summary>
	/// <param name="serializationContext">The current serialization context instance.</param>
	/// <param name="element">The element whose attributes have just been written.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param>
	/// <remarks>The default implemenation is to write out all non-embedded extension elements,
	/// regardless of whether they relate to the current element or not.
	/// The additional data should be written as a series of one or more
	/// XML elements.</remarks>
	internal protected virtual void WriteExtensions(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	{
		if (serializationContext == null)
		{
			throw new global::System.ArgumentNullException("serializationContext");
		}
		if (element == null)
		{
			throw new global::System.ArgumentNullException("element");
		}
		if (writer == null)
		{
			throw new global::System.ArgumentNullException("writer");
		}

		// Build a list of extension elements to serialize
		global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::ModelElement> allExtensionElements = element.Partition.ElementDirectory.FindElements(DslModeling::ExtensionElement.DomainClassId, true);
		global::System.Collections.Generic.IEnumerable<DslModeling::ExtensionElement> nonEmbeddedExtensionsElements = allExtensionElements.Where(e => DslModeling::DomainClassInfo.FindEmbeddingElementLink(e) == null).OfType<DslModeling::ExtensionElement>();

		DslModeling::SerializationUtilities.WriteExtensions(serializationContext, writer, nonEmbeddedExtensionsElements);
	}

	/// <summary>
	/// Read any extension data written inside this XML element
	/// </summary>
	/// <param name="serializationContext">The current serialization context instance.</param>
	/// <param name="element">In-memory ModelElement instance that is currently being read.</param>
	/// <param name="reader">Reader for the file being read. The reader is positioned after the attributes of the specified element.</param>
	/// <remarks>The method reads any extension element data, regardless of whether it relates the current
	/// element or not. There may be no additional data for the specified element.</remarks>
	internal protected virtual void ReadExtensions(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
		if (serializationContext == null)
		{
			throw new global::System.ArgumentNullException("serializationContext");
		}
		if (element == null)
		{
			throw new global::System.ArgumentNullException("element");
		}
		if (reader == null)
		{
			throw new global::System.ArgumentNullException("reader");
		}

		if (string.CompareOrdinal(reader.LocalName, DslModeling::SerializationUtilities.ExtensionsXmlElementName) == 0)
		{
			DslModeling::SerializationUtilities.ReadExtensions(serializationContext, reader, element.Partition);
		}
	}
	
	/// <summary>
	/// Writes the specified attribute to the file.
	/// </summary>
	/// <param name="serializationContext">The current serialization context instance.</param>
	/// <param name="element">The element whose attributes have just been written.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param>
	/// <param name="attributeName">Name of the attribute to be written</param>
	/// <param name="attributeValue">Value of the attribute to be written</param>
	/// <remarks>This is an extension point to allow customisation e.g. to encode the data
	/// being written to the file.</remarks>
	internal virtual void WriteAttributeString(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, string attributeName, string attributeValue)
	{
		writer.WriteAttributeString(attributeName, attributeValue);
	}

	/// <summary>
	/// Writes the specified element to the file.
	/// </summary>
	/// <param name="serializationContext">The current serialization context instance.</param>
	/// <param name="element">The element whose attributes have just been written.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param>
	/// <param name="elementName">Name of the element to be written.</param>
	/// <param name="elementValue">Value of the element to be written.</param>
	/// <remarks>This is an extension point to allow customisation e.g. to encode the data
	/// being written to the file.</remarks>
	internal virtual void WriteElementString(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, string elementName, string elementValue)
	{
		writer.WriteElementString(elementName, elementValue);
	}

	/// <summary>
	/// Reads and returns the value of an attribute.
	/// </summary>
	/// <param name="serializationContext">The current serialization context instance.</param>
	/// <param name="element">The element whose attributes have just been written.</param>
	/// <param name="reader">XmlReader to read the serialized data from.</param>
	/// <param name="attributeName">The name of the attribute to be read.</param>
	/// <returns>The value of the attribute.</returns>
	/// <remarks>This is an extension point to allow customisation e.g. to decode the data
	/// being written to the file.</remarks>
	internal virtual string ReadAttribute(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader, string attributeName)
	{
		return reader.GetAttribute(attributeName);
	}

	/// <summary>
	/// Reads and returns the value of an element.
	/// </summary>
	/// <param name="serializationContext">The current serialization context instance.</param>
	/// <param name="element">The element whose attributes have just been written.</param>
	/// <param name="reader">XmlReader to read the serialized data from.</param>
	/// <returns>The value of the element.</returns>
	/// <remarks>This is an extension point to allow customisation e.g. to decode the data
	/// being written to the file.</remarks>
	internal virtual string ReadElementContentAsString(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
		return reader.ReadElementContentAsString();
	}

	/// <summary>
	/// Creates and returns the settings used when reading a file.
	/// </summary>
	/// <param name="serializationContext">The current serialization context instance.</param>
	/// <param name="isDiagram">Indicates whether a diagram or model file is currently being serialized.</param>
	internal virtual global::System.Xml.XmlReaderSettings CreateXmlReaderSettings(DslModeling::SerializationContext serializationContext, bool isDiagram)
	{
		return new global::System.Xml.XmlReaderSettings() { DtdProcessing = System.Xml.DtdProcessing.Prohibit };
	}

	/// <summary>
	/// Creates and returns the settings used when writing a file.
	/// </summary>
	/// <param name="serializationContext">The current serialization context instance.</param>
	/// <param name="isDiagram">Indicates whether a diagram or model file is currently being serialized.</param>
	/// <param name="encoding">The encoding to use when writing the file.</param>
	internal virtual global::System.Xml.XmlWriterSettings CreateXmlWriterSettings(DslModeling::SerializationContext serializationContext, bool isDiagram, global::System.Text.Encoding encoding)
	{
		global::System.Xml.XmlWriterSettings settings = new global::System.Xml.XmlWriterSettings();
		settings.Indent = true;
		settings.Encoding = encoding;

		return settings;
	}
	
	#endregion
}

/// <summary>
/// Helper class for serializing and deserializing <#= dslName #> models.
/// </summary>
public sealed partial class <#= dslName #>SerializationHelper : <#= dslName #>SerializationHelperBase
{
	#region Constructor
	/// <summary>
	/// Private constructor to prevent direct instantiation.
	/// </summary>
	private <#= dslName #>SerializationHelper() : base () { }
	#endregion
	
	#region Singleton Instance
	/// <summary>
	/// Singleton instance.
	/// </summary>
	private static <#= dslName #>SerializationHelper instance;
	/// <summary>
	/// Singleton instance.
	/// </summary>
	[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
	public static <#= dslName #>SerializationHelper Instance
	{
		[global::System.Diagnostics.DebuggerStepThrough]
		get
		{
			if (<#= dslName #>SerializationHelper.instance == null)
				<#= dslName #>SerializationHelper.instance = new <#= dslName #>SerializationHelper();
			return <#= dslName #>SerializationHelper.instance;
		}
	}
	#endregion
}

<#
	CloseNamespace();
#>


<#
	if (!this.IsDsl)
	{
#>
//
// The serialization helper does not contain load/save methods because the input is not a DSL definition.
//
<#
	}
	else if (this.Dsl.Editor == null)
	{
#>
//
// The serialization helper does not contain load/save methods because the DSL definition does not define an Editor.
//
<#
	}
	else if (this.Dsl.Editor.RootClass == null)
	{
#>
//
// The serialization helper does not contain load/save methods because the DSL definition's Editor does not specify a RootClass.
//
<#
	}
	else if (this.Dsl.Editor.XmlSerializationDefinition == null)
	{
#>
//
// The serialization helper does not contain load/save methods because the DSL definition's Editor does not specify a XmlSerializationDefinition.
//
<#
	}
	else if (this.Dsl.Editor.XmlSerializationDefinition.Behavior == null)
	{
#>
//
// The serialization helper does not contain load/save methods because the XmlSerializationDefinition of DSL definition's Editor does not specify a XmlSerializationBehavior.
//
<#
	}
	else
	{
		OpenNamespace();
#>

partial class <#= dslName #>SerializationHelperBase
{

	/// <summary>
	/// Loads a <#= rootClass.Name #> instance into the default partition of the given store, and ignore serialization result.
	/// </summary>
	/// <param name="store">The new <#= rootClass.Name #> instance will be created into the default partition of this store.</param>
	/// <param name="fileName">Name of the file from which the <#= rootClass.Name #> instance will be deserialized.</param>
	/// <param name="schemaResolver">
	/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
	/// If null is passed, schema validation will not be performed.
	/// </param>
	/// <param name="validationController">
	/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
	/// is passed, load-time validation will not be performed.
	/// </param>
	/// <param name="serializerLocator">
	/// An ISerializerLocator that will be used to locate any additional domain model types required to load the model. Can be null.
	/// </param>
	/// <returns>The loaded <#= rootClass.Name #> instance.</returns>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual <#= rootClassName #> LoadModel(DslModeling::Store store, string fileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController, DslModeling::ISerializerLocator serializerLocator)
	{
		#region Check Parameters
		if (store == null) 
			throw new global::System.ArgumentNullException("store");
		#endregion
		
		return this.LoadModel(new DslModeling::SerializationResult(), store.DefaultPartition, fileName, schemaResolver, validationController, serializerLocator);
	}
	
	/// <summary>
	/// Loads a <#= rootClass.Name #> instance into the default partition of the given store.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the load operation.</param>
	/// <param name="store">The new <#= rootClass.Name #> instance will be created into the default partition of this store.</param>
	/// <param name="fileName">Name of the file from which the <#= rootClass.Name #> instance will be deserialized.</param>
	/// <param name="schemaResolver">
	/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
	/// If null is passed, schema validation will not be performed.
	/// </param>
	/// <param name="validationController">
	/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
	/// is passed, load-time validation will not be performed.
	/// </param>
	/// <param name="serializerLocator">
	/// An ISerializerLocator that will be used to locate any additional domain model types required to load the model. Can be null.
	/// </param>
	/// <returns>The loaded <#= rootClass.Name #> instance.</returns>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual <#= rootClassName #> LoadModel(DslModeling::SerializationResult serializationResult, DslModeling::Store store, string fileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController, DslModeling::ISerializerLocator serializerLocator)
	{
		#region Check Parameters
		if (store == null) 
			throw new global::System.ArgumentNullException("store");
		#endregion
		
		return this.LoadModel(serializationResult, store.DefaultPartition, fileName, schemaResolver, validationController, serializerLocator);
	}

	/// <summary>
	/// Loads a <#= rootClass.Name #> instance.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the load operation.</param>
	/// <param name="partition">Partition in which the new <#= rootClass.Name #> instance will be created.</param>
	/// <param name="fileName">Name of the file from which the <#= rootClass.Name #> instance will be deserialized.</param>
	/// <param name="schemaResolver">
	/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
	/// If null is passed, schema validation will not be performed.
	/// </param>
	/// <param name="validationController">
	/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
	/// is passed, load-time validation will not be performed.
	/// </param>
	/// <param name="serializerLocator">
	/// An ISerializerLocator that will be used to locate any additional domain model types required to load the model. Can be null.
	/// </param>
	/// <returns>The loaded <#= rootClass.Name #> instance.</returns>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability","CA1506:AvoidExcessiveClassCoupling", Justification="Generated code")]
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual <#= rootClassName #> LoadModel(DslModeling::SerializationResult serializationResult, DslModeling::Partition partition, string fileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController, DslModeling::ISerializerLocator serializerLocator)
	{
		#region Check Parameters
		if (string.IsNullOrEmpty(fileName))
			throw new global::System.ArgumentNullException(nameof(fileName));
		#endregion
	
		using (global::System.IO.FileStream fileStream = global::System.IO.File.OpenRead(fileName))
		{
			return this.LoadModel(serializationResult, partition, fileName, schemaResolver, validationController, serializerLocator, fileStream);
		}
	}

	/// <summary>
	/// Loads a <#= rootClass.Name #> instance from a stream.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the load operation.</param>
	/// <param name="partition">Partition in which the new <#= rootClass.Name #> instance will be created.</param>
	/// <param name="location">Source location associated with stream from which the <#= rootClass.Name #> instance is to be loaded. Usually a file path, but can be any string, including null.</param>
	/// <param name="schemaResolver">
	/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
	/// If null is passed, schema validation will not be performed.
	/// </param>
	/// <param name="validationController">
	/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
	/// is passed, load-time validation will not be performed.
	/// </param>
	/// <param name="serializerLocator">
	/// An ISerializerLocator that will be used to locate any additional domain model types required to load the model. Can be null.
	/// </param>
	/// <param name="stream">The Stream from which the <#= rootClass.Name #> will be deserialized.</param>
	/// <returns>The loaded <#= rootClass.Name #> instance.</returns>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability","CA1506:AvoidExcessiveClassCoupling", Justification="Generated code")]
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual <#= rootClassName #> LoadModel(DslModeling::SerializationResult serializationResult, DslModeling::Partition partition, string location, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController, DslModeling::ISerializerLocator serializerLocator, global::System.IO.Stream stream)
	{
		#region Check Parameters
		if (serializationResult == null)
			throw new global::System.ArgumentNullException(nameof(serializationResult));
		if (partition == null)
			throw new global::System.ArgumentNullException(nameof(partition));
		if (stream == null)
			throw new global::System.ArgumentNullException(nameof(stream));
		#endregion
	
		// Ensure there is a transaction for this model to Load in.
		if (!partition.Store.TransactionActive)
		{
			throw new global::System.InvalidOperationException(<#= this.Dsl.GetRelativeName(namespaceString, true) #>DomainModel.SingletonResourceManager.GetString("MissingTransaction"));
		}
		
		<#= rootClassName #> modelRoot = null;
		DslModeling::DomainXmlSerializerDirectory directory = this.GetDirectory(partition.Store);
		DslModeling::DomainClassXmlSerializer modelRootSerializer = directory.GetSerializer(<#= rootClassName #>.DomainClassId);
		global::System.Diagnostics.Debug.Assert(modelRootSerializer != null, "Cannot find serializer for <#= rootClass.Name #>!");
		if (modelRootSerializer != null)
		{
<#
		// Extra PostLoad tx if customization point
		if ( definition.CustomPostLoad )
		{
#>	
				using (DslModeling::Transaction postT = partition.Store.TransactionManager.BeginTransaction("PostLoad Model", true))
				{		
<#
			PushIndent("\t");
		}
#>
			DslModeling::SerializationContext serializationContext = new DslModeling::SerializationContext(directory, location, serializationResult);
			this.InitializeSerializationContext(partition, serializationContext, true);
			DslModeling::TransactionContext transactionContext = new DslModeling::TransactionContext();
			transactionContext.Add(DslModeling::SerializationContext.TransactionContextKey, serializationContext);
			using (DslModeling::Transaction t = partition.Store.TransactionManager.BeginTransaction("Load Model from " + location ?? "stream", true, transactionContext))
			{
				// Ensure there is some content in the file.  Blank (or almost blank, to account for encoding header bytes, etc.)
				// files will cause a new root element to be created and returned. 
				if (stream.Length > 5)
				{
					try
					{
						global::System.Xml.XmlReaderSettings settings = <#= behavior.DslLibrary.Name #>SerializationHelper.Instance.CreateXmlReaderSettings(serializationContext, false);
						using (global::System.Xml.XmlReader reader = global::System.Xml.XmlReader.Create(stream, settings))
						{
							// Attempt to read the encoding.
							reader.Read(); // Move to the first node - will be the XmlDeclaration if there is one.
							global::System.Text.Encoding encoding;
							if (this.TryGetEncoding(reader, out encoding))
							{
								serializationResult.Encoding = encoding;
							}

							// Load any additional domain models that are required
							DslModeling::SerializationUtilities.ResolveDomainModels(reader, serializerLocator, partition.Store);
							
							reader.MoveToContent();
								
							modelRoot = modelRootSerializer.TryCreateInstance(serializationContext, reader, partition) as <#= rootClassName #>;
							if (modelRoot != null && !serializationResult.Failed)
							{
								this.ReadRootElement(serializationContext, modelRoot, reader, schemaResolver);
							}
						}

					}
					catch (global::System.Xml.XmlException xEx)
					{
						DslModeling::SerializationUtilities.AddMessage(
							serializationContext,
							DslModeling::SerializationMessageKind.Error,
							xEx
						);
					}
				}
			
				if(modelRoot == null && !serializationResult.Failed)
				{
					// create model root if it doesn't exist.
					modelRoot = this.CreateModelHelper(partition);
				}
				if (t.IsActive)
					t.Commit();
			} // End Inner Tx
<#
		// Enable PostLoad customization point
		if ( definition.CustomPostLoad )
		{
			PopIndent();
#>	
				// Fire PostLoad customization code whether load has succeeded or not
				// Provide a method in a partial class with the following signature:
					
				///// <summary>
				///// Customize Model Loading.
				///// </summary>
				///// <param name="serializationResult">Stores serialization result from the load operation.</param>
				///// <param name="partition">Partition in which the new <#= rootClass.Name #> instance will be created.</param>
				///// <param name="fileName">Name of the file from which the <#= rootClass.Name #> instance will be deserialized.</param>
				///// <param name="modelRoot">The root of the file that was loaded.</param>
				// private void OnPostLoadModel(DslModeling::SerializationResult serializationResult, DslModeling::Partition partition, string fileName, <#= rootClass.GetRelativeName(namespaceString, true) #> modelRoot )

				this.OnPostLoadModel(serializationResult, partition, location, modelRoot);
				if (serializationResult.Failed)
				{	// Serialization error encountered, rollback the middle transaction.
					modelRoot = null;
					postT.Rollback();
				}
				if (postT.IsActive)
					postT.Commit();
			} // End PostLoad Tx
<#
		}
#>

			// Do load-time validation if a ValidationController is provided.
			if (!serializationResult.Failed && validationController != null)
			{
				using (new SerializationValidationObserver(serializationResult, validationController))
				{
					validationController.Validate(partition, DslValidation::ValidationCategories.Load);
				}
			}

		}
		return modelRoot;
	}

	/// <summary>
	/// Attempts to return the encoding used by the reader.
	/// </summary>
	/// <remarks>
	/// The reader will be positioned at the start of the document when calling this method.
	/// </remarks>
	protected virtual bool TryGetEncoding(global::System.Xml.XmlReader reader, out global::System.Text.Encoding encoding)
	{
		global::System.Diagnostics.Debug.Assert(reader.NodeType == System.Xml.XmlNodeType.XmlDeclaration, "reader should be at the XmlDeclaration node when calling this method");

		encoding = null;
		// Attempt to read and parse the "encoding" attribute from the XML declaration node
		if (reader.NodeType == global::System.Xml.XmlNodeType.XmlDeclaration)
		{
			string encodingName = reader.GetAttribute("encoding");
			if (!string.IsNullOrWhiteSpace(encodingName))
			{
				encoding = global::System.Text.Encoding.GetEncoding(encodingName);
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Saves the given model root to the given file, with default encoding (UTF-8), and optional properties with default value will not
	/// be written out.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="modelRoot"><#= rootClass.Name #> instance to be saved.</param>
	/// <param name="fileName">Name of the file in which the <#= rootClass.Name #> instance will be saved.</param>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual void SaveModel(DslModeling::SerializationResult serializationResult, <#= rootClassName #> modelRoot, string fileName)
	{
		this.SaveModel(serializationResult, modelRoot, fileName, global::System.Text.Encoding.UTF8, false);
	}
	
	/// <summary>
	/// Saves the given model to the given file, with default encoding (UTF-8).
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="modelRoot"><#= rootClass.Name #> instance to be saved.</param>
	/// <param name="fileName">Name of the file in which the <#= rootClass.Name #> instance will be saved.</param>
	/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual void SaveModel(DslModeling::SerializationResult serializationResult, <#= rootClassName #> modelRoot, string fileName, bool writeOptionalPropertiesWithDefaultValue)
	{
		this.SaveModel(serializationResult, modelRoot, fileName, global::System.Text.Encoding.UTF8, writeOptionalPropertiesWithDefaultValue);
	}

	/// <summary>
	/// Saves the given model root to the given file, with specified encoding.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="modelRoot"><#= rootClass.Name #> instance to be saved.</param>
	/// <param name="fileName">Name of the file in which the <#= rootClass.Name #> instance will be saved.</param>
	/// <param name="encoding">Encoding to use when saving the <#= rootClass.Name #> instance.</param>
	/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual void SaveModel(DslModeling::SerializationResult serializationResult, <#= rootClassName #> modelRoot, string fileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
	{
		#region Check Parameters
		if (serializationResult == null)
			throw new global::System.ArgumentNullException("serializationResult");
		if (modelRoot == null)
			throw new global::System.ArgumentNullException("modelRoot");
		if (string.IsNullOrEmpty(fileName))
			throw new global::System.ArgumentNullException("fileName");
		#endregion

		if (serializationResult.Failed)
			return;

<#
		if (diagram == null)
		{
#>
		using (global::System.IO.MemoryStream newFileContent = new global::System.IO.MemoryStream())
		{
			DslModeling::DomainXmlSerializerDirectory directory = this.GetDirectory(modelRoot.Store);

			DslModeling::SerializationContext serializationContext = new DslModeling::SerializationContext(directory, fileName, serializationResult);
			this.InitializeSerializationContext(modelRoot.Partition, serializationContext, false);
			// MonikerResolver shouldn't be required in Save operation, so not calling SetupMonikerResolver() here.
			serializationContext.WriteOptionalPropertiesWithDefaultValue = writeOptionalPropertiesWithDefaultValue;
			global::System.Xml.XmlWriterSettings settings = <#= behavior.DslLibrary.Name #>SerializationHelper.Instance.CreateXmlWriterSettings(serializationContext, false, encoding);
			using (global::System.Xml.XmlWriter writer = global::System.Xml.XmlWriter.Create(newFileContent, settings))
			{
				this.WriteRootElement(serializationContext, modelRoot, writer);
			}

			if (!serializationResult.Failed && newFileContent != null)
			{	// Only write the content if there's no error encountered during serialization.
				using (global::System.IO.FileStream fileStream = new global::System.IO.FileStream(fileName, global::System.IO.FileMode.Create, global::System.IO.FileAccess.Write, global::System.IO.FileShare.None))
				{
					using (global::System.IO.BinaryWriter writer = new global::System.IO.BinaryWriter(fileStream, encoding))
					{
						writer.Write(newFileContent.ToArray());
					}
				}
			}
		}
<#
		}
		else
		{
#>
		using (global::System.IO.MemoryStream newFileContent = this.InternalSaveModel(serializationResult, modelRoot, fileName, encoding, writeOptionalPropertiesWithDefaultValue))
		{
			if (!serializationResult.Failed && newFileContent != null)
			{	// Only write the content if there's no error encountered during serialization.
				using (global::System.IO.FileStream fileStream = new global::System.IO.FileStream(fileName, global::System.IO.FileMode.Create, global::System.IO.FileAccess.Write, global::System.IO.FileShare.None))
				{
					using (global::System.IO.BinaryWriter writer = new global::System.IO.BinaryWriter(fileStream, encoding))
					{
						writer.Write(newFileContent.ToArray());
					}
				}
			}
		}
<#
		}
#>	}

	/// <summary>
	/// Saves the given model root as a in-memory stream.
	/// This is a helper used by SaveModel() and SaveModelAndDiagram(). When saving the model and the diagram together, we want to make sure that 
	/// both can be saved without error before writing the content to disk, so we serialize the model into a in-memory stream first.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="modelRoot"><#= rootClass.Name #> instance to be saved.</param>
	/// <param name="fileName">Name of the file in which the <#= rootClass.Name #> instance will be saved.</param>
	/// <param name="encoding">Encoding to use when saving the <#= rootClass.Name #> instance.</param>
	/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
	/// <returns>In-memory stream containing the serialized <#= rootClass.Name #> instance.</returns>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
	internal global::System.IO.MemoryStream InternalSaveModel(DslModeling::SerializationResult serializationResult, <#= rootClassName #> modelRoot, string fileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
	{
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert(serializationResult != null);
		global::System.Diagnostics.Debug.Assert(modelRoot != null);
		global::System.Diagnostics.Debug.Assert(!serializationResult.Failed);
		#endregion

		serializationResult.Encoding = encoding;

		DslModeling::DomainXmlSerializerDirectory directory = this.GetDirectory(modelRoot.Store);

		
		global::System.IO.MemoryStream newFileContent = new global::System.IO.MemoryStream();
		
		DslModeling::SerializationContext serializationContext = new DslModeling::SerializationContext(directory, fileName, serializationResult);
		this.InitializeSerializationContext(modelRoot.Partition, serializationContext, false);
		// MonikerResolver shouldn't be required in Save operation, so not calling SetupMonikerResolver() here.
		serializationContext.WriteOptionalPropertiesWithDefaultValue = writeOptionalPropertiesWithDefaultValue;
		global::System.Xml.XmlWriterSettings settings = <#= behavior.DslLibrary.Name #>SerializationHelper.Instance.CreateXmlWriterSettings(serializationContext, false, encoding);
		using (global::System.Xml.XmlWriter writer = global::System.Xml.XmlWriter.Create(newFileContent, settings))
		{
			this.WriteRootElement(serializationContext, modelRoot, writer);
		}
			
		return newFileContent;
	}
<#
	if (diagram != null)
	{
		string diagramName = diagram.Name;
		string diagramTypeName = diagram.GetRelativeName (namespaceString, true);
#>
	/// <summary>
	/// Saves the given model root as a in-memory stream.
	/// This is a helper used by SaveModel() and SaveModelAndDiagram(). When saving the model and the diagram together, we want to make sure that 
	/// both can be saved without error before writing the content to disk, so we serialize the model into a in-memory stream first.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="diagram"><#= diagramName #> to be saved.</param>
	/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
	/// <param name="encoding">Encoding to use when saving the diagram.</param>
	/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
	/// <returns>In-memory stream containing the serialized <#= diagramName #> instance.</returns>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
	internal global::System.IO.MemoryStream InternalSaveDiagram(DslModeling::SerializationResult serializationResult, <#= diagramTypeName #> diagram, string diagramFileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
	{
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert(serializationResult != null);
		global::System.Diagnostics.Debug.Assert(diagram != null);
		global::System.Diagnostics.Debug.Assert(!serializationResult.Failed);
		#endregion

		DslModeling::DomainXmlSerializerDirectory directory = this.GetDirectory(diagram.Store);

		
		global::System.IO.MemoryStream newFileContent = new global::System.IO.MemoryStream();
		
		DslModeling::SerializationContext serializationContext = new DslModeling::SerializationContext(directory, diagramFileName, serializationResult);
		this.InitializeSerializationContext(diagram.Partition, serializationContext, false);
		// MonikerResolver shouldn't be required in Save operation, so not calling SetupMonikerResolver() here.
		serializationContext.WriteOptionalPropertiesWithDefaultValue = writeOptionalPropertiesWithDefaultValue;
		global::System.Xml.XmlWriterSettings settings = <#= behavior.DslLibrary.Name #>SerializationHelper.Instance.CreateXmlWriterSettings(serializationContext, true, encoding);
		using (global::System.Xml.XmlWriter writer = global::System.Xml.XmlWriter.Create(newFileContent, settings))
		{
			this.WriteRootElement(serializationContext, diagram, writer);
		}

		return newFileContent;
	}
<#
	}
#>

	/// <summary>
	/// Helper method to create and initialize a new <#= rootClass.Name #>.
	/// </summary>
<#
		if (rootClass.InheritanceModifier == InheritanceModifier.Abstract)
		{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="modelPartition", Justification = "Signature enforced by caller.")]
<#
		}
#>
	<#= (rootClass.AccessModifier == TypeAccessModifier.Assembly) ? "internal" : "internal protected" #> virtual <#= rootClass.GetRelativeName(namespaceString, true) #> CreateModelHelper(DslModeling::Partition modelPartition)
	{
<#
		if (rootClass.InheritanceModifier != InheritanceModifier.Abstract)
		{
#>
		<#= rootClass.GetRelativeName(namespaceString, true) #> model = new <#= rootClass.GetRelativeName(namespaceString, true) #>(modelPartition);
		return model;
<#
		}
		else
		{
#>
		return null;
<#
		}
#>
	}
	
<#
		if (diagram != null)
		{
			string diagramName = diagram.Name;
			string diagramTypeName = diagram.GetRelativeName (namespaceString, true);
#>
	/// <summary>
	/// Loads a <#= rootClass.Name #> instance and its associated diagram file into the default partition of the given store, and ignore serialization result.
	/// </summary>
	/// <param name="store">The new <#= rootClass.Name #> instance will be created into the default partition of this store.</param>
	/// <param name="modelFileName">Name of the file from which the <#= rootClass.Name #> instance will be deserialized.</param>
	/// <param name="diagramFileName">Name of the file from which the <#= diagramName #> instance will be deserialized.</param>
	/// <param name="schemaResolver">
	/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
	/// If null is passed, schema validation will not be performed.
	/// </param>
	/// <param name="validationController">
	/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
	/// is passed, load-time validation will not be performed.
	/// </param>
	/// <param name="serializerLocator">
	/// An ISerializerLocator that will be used to locate any additional domain model types required to load the model. Can be null.
	/// </param>
	/// <returns>The loaded <#= rootClass.Name #> instance.</returns>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual <#= rootClassName #> LoadModelAndDiagram(DslModeling::Store store, string modelFileName, string diagramFileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController, DslModeling::ISerializerLocator serializerLocator)
	{
		return this.LoadModelAndDiagram(new DslModeling::SerializationResult(), store, modelFileName, diagramFileName, schemaResolver, validationController, serializerLocator);
	}
	
	/// <summary>
	/// Loads a <#= rootClass.Name #> instance and its associated diagram file into the default partition of the given store.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the load operation.</param>
	/// <param name="store">The new <#= rootClass.Name #> instance will be created into the default partition of this store.</param>
	/// <param name="modelFileName">Name of the file from which the <#= rootClass.Name #> instance will be deserialized.</param>
	/// <param name="diagramFileName">Name of the file from which the <#= diagramName #> instance will be deserialized.</param>
	/// <param name="schemaResolver">
	/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
	/// If null is passed, schema validation will not be performed.
	/// </param>
	/// <param name="validationController">
	/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
	/// is passed, load-time validation will not be performed.
	/// </param>
	/// <param name="serializerLocator">
	/// An ISerializerLocator that will be used to locate any additional domain model types required to load the model. Can be null.
	/// </param>
	/// <returns>The loaded <#= rootClass.Name #> instance.</returns>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual <#= rootClassName #> LoadModelAndDiagram(DslModeling::SerializationResult serializationResult, DslModeling::Store store, string modelFileName, string diagramFileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController, DslModeling::ISerializerLocator serializerLocator)
	{
		#region Check Parameters
		if (store == null)
			throw new global::System.ArgumentNullException("store");
		#endregion
		
		DslModeling::Partition diagramPartition = new DslModeling::Partition(store);
		return this.LoadModelAndDiagram(serializationResult, store.DefaultPartition, modelFileName, diagramPartition, diagramFileName, schemaResolver, validationController, serializerLocator);
	}
		
	/// <summary>
	/// Loads a <#= rootClass.Name #> instance and its associated diagram file.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the load operation.</param>
	/// <param name="modelPartition">Partition in which the new <#= rootClass.Name #> instance will be created.</param>
	/// <param name="modelFileName">Name of the file from which the <#= rootClass.Name #> instance will be deserialized.</param>
	/// <param name="diagramPartition">Partition in which the new <#= diagramName #> instance will be created.</param>
	/// <param name="diagramFileName">Name of the file from which the <#= diagramName #> instance will be deserialized.</param>
	/// <param name="schemaResolver">
	/// An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).
	/// If null is passed, schema validation will not be performed.
	/// </param>
	/// <param name="validationController">
	/// A ValidationController that will be used to do load-time validation (validations with validation category "Load"). If null
	/// is passed, load-time validation will not be performed.
	/// </param>
	/// <param name="serializerLocator">
	/// An ISerializerLocator that will be used to locate any additional domain model types required to load the model. Can be null.
	/// </param>
	/// <returns>The loaded <#= rootClass.Name #> instance.</returns>
<#
			if (definition.CustomPostLoad)
			{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
<#
			}
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual <#= rootClassName #> LoadModelAndDiagram(DslModeling::SerializationResult serializationResult, DslModeling::Partition modelPartition, string modelFileName, DslModeling::Partition diagramPartition, string diagramFileName, DslModeling::ISchemaResolver schemaResolver, DslValidation::ValidationController validationController, DslModeling::ISerializerLocator serializerLocator)
	{
		#region Check Parameters
		if (serializationResult == null)
			throw new global::System.ArgumentNullException("serializationResult");
		if (modelPartition == null)		
			throw new global::System.ArgumentNullException("modelPartition");
		if (diagramPartition == null)
			throw new global::System.ArgumentNullException("diagramPartition");
		if (string.IsNullOrEmpty(diagramFileName))
			throw new global::System.ArgumentNullException("diagramFileName");
		#endregion

		<#= rootClassName #> modelRoot;

		// Ensure there is an outer transaction spanning both model and diagram load, so moniker resolution works properly.
		if (!diagramPartition.Store.TransactionActive)
		{
			throw new global::System.InvalidOperationException(<#= this.Dsl.GetRelativeName(namespaceString, true) #>DomainModel.SingletonResourceManager.GetString("MissingTransaction"));
		}

		modelRoot = this.LoadModel(serializationResult, modelPartition, modelFileName, schemaResolver, validationController, serializerLocator);

		if (serializationResult.Failed)
		{
			// don't try to deserialize diagram data if model load failed.
			return modelRoot;
		}

		<#= diagramTypeName #> diagram = null;
		DslModeling::DomainXmlSerializerDirectory directory = this.GetDirectory(diagramPartition.Store);
		DslModeling::DomainClassXmlSerializer diagramSerializer = directory.GetSerializer(<#= diagramTypeName #>.DomainClassId);
		global::System.Diagnostics.Debug.Assert(diagramSerializer != null, "Cannot find serializer for <#= diagramName #>");
		if (diagramSerializer != null)
		{
			if(!global::System.IO.File.Exists(diagramFileName))
			{
				// missing diagram file indicates we should create a new diagram.
				diagram = this.CreateDiagramHelper(diagramPartition, modelRoot);
			}
			else
			{
				using (global::System.IO.FileStream fileStream = global::System.IO.File.OpenRead(diagramFileName))
				{
					DslModeling::SerializationContext serializationContext = new DslModeling::SerializationContext(directory, fileStream.Name, serializationResult);
					this.InitializeSerializationContext(diagramPartition, serializationContext, true);
					DslModeling::TransactionContext transactionContext = new DslModeling::TransactionContext();
					transactionContext.Add(DslModeling::SerializationContext.TransactionContextKey, serializationContext);
<#
			// Extra PostLoad tx if customization point
			if ( definition.CustomPostLoad )
			{
#>	
					using (DslModeling::Transaction postT = diagramPartition.Store.TransactionManager.BeginTransaction("PostLoad Model and Diagram", true, transactionContext))
					{
<#
				PushIndent ("\t");
			}
#>					
					using (DslModeling::Transaction t = diagramPartition.Store.TransactionManager.BeginTransaction("LoadDiagram", true, transactionContext))
					{
						// Ensure there is some content in the file. Blank (or almost blank, to account for encoding header bytes, etc.)
						// files will cause a new diagram to be created and returned 
						if (fileStream.Length > 5)
						{
							global::System.Xml.XmlReaderSettings settings = <#= behavior.DslLibrary.Name #>SerializationHelper.Instance.CreateXmlReaderSettings(serializationContext, false);
							try
							{
								using (global::System.Xml.XmlReader reader = global::System.Xml.XmlReader.Create(fileStream, settings))
								{
									reader.MoveToContent();
									diagram = diagramSerializer.TryCreateInstance(serializationContext, reader, diagramPartition) as <#= diagramTypeName #>;
									if (diagram != null)
									{
										this.ReadRootElement(serializationContext, diagram, reader, schemaResolver);
									}
								}
							}
							catch (global::System.Xml.XmlException xEx)
							{
								DslModeling::SerializationUtilities.AddMessage(
									serializationContext,
									DslModeling::SerializationMessageKind.Error,
									xEx
								);
							}
							if (serializationResult.Failed)
							{	
								// Serialization error encountered, rollback the transaction.
								diagram = null;
								t.Rollback();
							}
						}
						
						if(diagram == null && !serializationResult.Failed)
						{
							// Create diagram if it doesn't exist
							diagram = this.CreateDiagramHelper(diagramPartition, modelRoot);
						}
						
						if (t.IsActive)
							t.Commit();
					} // End inner Tx
<#
			// Extra PostLoad 
			if ( definition.CustomPostLoad )
			{
				PopIndent();
#>

						// Fire PostLoad customization code whether Load succeeded or not
						// Provide a method in a partial class with the following signature:
						
						///// <summary>
						///// Customize Model and Diagram Loading.
						///// </summary>
						///// <param name="serializationResult">Stores serialization result from the load operation.</param>
						///// <param name="modelPartition">Partition in which the new DslLibrary instance will be created.</param>
						///// <param name="modelFileName">Name of the file from which the DslLibrary instance will be deserialized.</param>
						///// <param name="diagramPartition">Partition in which the new DslDesignerDiagram instance will be created.</param>
						///// <param name="diagramFileName">Name of the file from which the DslDesignerDiagram instance will be deserialized.</param>
						///// <param name="modelRoot">The root of the file that was loaded.</param>
						///// <param name="diagram">The diagram matching the modelRoot.</param>
						// private void OnPostLoadModelAndDiagram(DslModeling::SerializationResult serializationResult, DslModeling::Partition modelPartition, string modelFileName, DslModeling::Partition diagramPartition, string diagramFileName, <#= rootClassName #> modelRoot, <#= diagramTypeName #> diagram)

						this.OnPostLoadModelAndDiagram(serializationResult, modelPartition, modelFileName, diagramPartition, diagramFileName, modelRoot, diagram);
						if (serializationResult.Failed)
						{	// Serialization error encountered, rollback the middle transaction.
								modelRoot = null;
								postT.Rollback();
						}
						if (postT.IsActive)
							postT.Commit();
					} // End MiddleTx					
<#
			}
#>

					// Do load-time validation if a ValidationController is provided.
					if (!serializationResult.Failed && validationController != null)
					{
						using (new SerializationValidationObserver(serializationResult, validationController))
						{
							validationController.Validate(diagramPartition, DslValidation::ValidationCategories.Load);
						}
					}
				}
			}

			if (diagram != null)
			{
				if (!serializationResult.Failed)
				{	// Succeeded.
					diagram.ModelElement = modelRoot;
					diagram.PostDeserialization(true);
					this.CheckForOrphanedShapes(diagram, serializationResult);
				}
				else
				{	// Failed.
					diagram.PostDeserialization(false);
				}
			}
		}
		return modelRoot;
	}

<#
			// Swimlanes that will be used in generating CreateDiagramHelper method.
			List<SwimLaneMap> swimlaneMaps = diagram.ShapeMaps.OfType<SwimLaneMap>().ToList();
	
#>
	/// <summary>
	/// Helper method to create and initialize a new <#= diagramName #>.
	/// </summary>
<#
			if (swimlaneMaps.Count == 0)
			{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="modelRoot", Justification = "Signature enforced by caller.")]
<#
			}
#>
	<#= (diagram.AccessModifier == TypeAccessModifier.Assembly) ? "internal" : "internal protected" #> virtual <#= diagram.GetRelativeName(namespaceString, true) #> CreateDiagramHelper(DslModeling::Partition diagramPartition, DslModeling::ModelElement modelRoot)
	{
		<#= diagram.GetRelativeName(namespaceString, true) #> diagram = new <#= diagram.GetRelativeName(namespaceString, true) #>(diagramPartition);
<#
			// if we have swimlane-mapped classes, create one of each of those as well, and merge them into the root.
			if(swimlaneMaps.Count > 0)
			{
#>

		// If model root has not children, create initial elements mapped to swimlanes, and merge them into the root.
		if (DslModeling::DomainRoleInfo.GetAllElementLinks(modelRoot).Count == 0)
		{
			DslModeling::Partition modelPartition = modelRoot.Partition;
			DslModeling::ElementGroup elementGroup = new DslModeling::ElementGroup(modelPartition);
			DslModeling::ModelElement mappedElement;
<#
				foreach(SwimLaneMap mapping in swimlaneMaps)
				{
					string swimlaneName = mapping.SwimLane.GetRelativeName(namespaceString, false);
					// To disambiguate swimlane name suffix on factory methods use the relative name with the periods stripped
					string swimlaneSuffix = swimlaneName.Replace(".", "");
#>
			mappedElement = CreateSwimLaneRootFor<#= swimlaneSuffix #>(modelPartition);
			elementGroup.Add(mappedElement);
			elementGroup.MarkAsRoot(mappedElement);
<#
				}
#>
			if(diagram.ElementOperations.CanMergeElementGroupPrototype(modelRoot, elementGroup.CreatePrototype()))
			{
				diagram.ElementOperations.MergeElementGroup(modelRoot, elementGroup);
			}
			else
			{
				global::System.Diagnostics.Debug.Fail("Cannot merge swimlane-mapped element(s) into the root model element.  Initial swimlanes will not be created.");
			}
		}

<#
			}
			if (HasSwimlanes())
			{
#>

		// If we have unmapped swimlanes then Initialize them also
		diagram.InitializeSwimlanes();

<#
			}
#>
		return diagram;
	}
	
<#
			foreach(SwimLaneMap mapping in swimlaneMaps)
			{
				string swimlaneName = mapping.SwimLane.GetRelativeName(namespaceString, false);
				// To disambiguate swimlane name suffix on factory methods use the relative name with the periods stripped
				string swimlaneSuffix = swimlaneName.Replace(".", "");
				DomainClass domainClass = mapping.Class;
				string relativeClassName = domainClass.GetRelativeName(namespaceString, true);
				bool isAbstract = domainClass.InheritanceModifier == InheritanceModifier.Abstract;
#>
	/// <summary>
	/// Create the root element for the <#= swimlaneName #> swimlane.
	/// </summary>
	/// <param name="modelPartition">Partition in which the swimlane's root element should be instantiated.</param>
<#
				if (isAbstract)
				{
#>
	/// <remarks>The swimlane is mapped to an abstract class of root element. This method must be overridden 
	/// by custom code in the doubly-derived derived class to create the correct type of concrete element.</remarks>
	protected abstract <#= relativeClassName #> CreateSwimLaneRootFor<#= swimlaneSuffix #>(DslModeling::Partition modelPartition);
	
<#
				}
				else
				{
				
#>
	protected virtual <#= relativeClassName #> CreateSwimLaneRootFor<#= swimlaneSuffix #>(DslModeling::Partition modelPartition)
	{
		return new <#= relativeClassName #>(modelPartition);
	}
	
<#
				}
			}
			TypeAccessModifier saveMethodsAccessModifier = ((diagram.AccessModifier == TypeAccessModifier.Assembly || rootClass.AccessModifier == TypeAccessModifier.Assembly) ? TypeAccessModifier.Assembly : TypeAccessModifier.Public);
#>

	/// <summary>
	/// Saves the given diagram to the given file, with default encoding (UTF-8), and optional properties with default value will not
	/// be written out.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="modelRoot"><#= rootClass.Name #> instance to be saved.</param>
	/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
	/// <param name="diagram"><#= diagramName #> to be saved.</param>
	/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(saveMethodsAccessModifier) #> virtual void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, <#= rootClassName #> modelRoot, string modelFileName, <#= diagramTypeName #> diagram, string diagramFileName)
	{
		this.SaveModelAndDiagram(serializationResult, modelRoot, modelFileName, diagram, diagramFileName, global::System.Text.Encoding.UTF8, false);
	}
	
	/// <summary>
	/// Saves the given diagram to the given file, with default encoding (UTF-8).
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="modelRoot"><#= rootClass.Name #> instance to be saved.</param>
	/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
	/// <param name="diagram"><#= diagramName #> to be saved.</param>
	/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
	/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(saveMethodsAccessModifier) #> virtual void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, <#= rootClassName #> modelRoot, string modelFileName, <#= diagramTypeName #> diagram, string diagramFileName, bool writeOptionalPropertiesWithDefaultValue)
	{
		this.SaveModelAndDiagram(serializationResult, modelRoot, modelFileName, diagram, diagramFileName, global::System.Text.Encoding.UTF8, writeOptionalPropertiesWithDefaultValue);
	}

	/// <summary>
	/// Saves the given <#= rootClass.Name #> and <#= diagramName #> to the given files, with specified encoding.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="modelRoot"><#= rootClass.Name #> instance to be saved.</param>
	/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
	/// <param name="diagram"><#= diagramName #> to be saved.</param>
	/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
	/// <param name="encoding">Encoding to use when saving the diagram.</param>
	/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
	<#= CodeGenerationUtilities.GetTypeAccessModifier(saveMethodsAccessModifier) #> virtual void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, <#= rootClassName #> modelRoot, string modelFileName, <#= diagramTypeName #> diagram, string diagramFileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
	{
		#region Check Parameters
		if (serializationResult == null)
			throw new global::System.ArgumentNullException("serializationResult");
		if (string.IsNullOrEmpty(modelFileName))
			throw new global::System.ArgumentNullException("modelFileName");
		if (diagram == null)
			throw new global::System.ArgumentNullException("diagram");
		if (string.IsNullOrEmpty(diagramFileName))
			throw new global::System.ArgumentNullException("diagramFileName");
		#endregion

		if (serializationResult.Failed)
			return;

		// Save the model file first
		using (global::System.IO.MemoryStream modelFileContent = this.InternalSaveModel(serializationResult, modelRoot, modelFileName, encoding, writeOptionalPropertiesWithDefaultValue))
		{
			if (serializationResult.Failed)
				return;

			using (global::System.IO.MemoryStream diagramFileContent = this.InternalSaveDiagram(serializationResult, diagram, diagramFileName, encoding, writeOptionalPropertiesWithDefaultValue))
			{
				if (!serializationResult.Failed)
				{
					// Only write the contents if there's no error encountered during serialization.
					if (modelFileContent != null)
					{
						using (global::System.IO.FileStream fileStream = new global::System.IO.FileStream(modelFileName, global::System.IO.FileMode.Create, global::System.IO.FileAccess.Write, global::System.IO.FileShare.None))
						{
							using (global::System.IO.BinaryWriter writer = new global::System.IO.BinaryWriter(fileStream, encoding))
							{
								writer.Write(modelFileContent.ToArray());
							}
						}
					}
					if (diagramFileContent != null)
					{
						using (global::System.IO.FileStream fileStream = new global::System.IO.FileStream(diagramFileName, global::System.IO.FileMode.Create, global::System.IO.FileAccess.Write, global::System.IO.FileShare.None))
						{
							using (global::System.IO.BinaryWriter writer = new global::System.IO.BinaryWriter(fileStream, encoding))
							{
								writer.Write(diagramFileContent.ToArray());
							}
						}
					}
				}
			}
		}
	}

	/// <summary>
	/// Saves the given diagram to the given file, with default encoding (UTF-8), and optional properties with default value will not
	/// be written out.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="diagram"><#= diagramName #> to be saved.</param>
	/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(saveMethodsAccessModifier) #> virtual void SaveDiagram(DslModeling::SerializationResult serializationResult, <#= diagramTypeName #> diagram, string diagramFileName)
	{
		this.SaveDiagram(serializationResult, diagram, diagramFileName, global::System.Text.Encoding.UTF8, false);
	}
	
	/// <summary>
	/// Saves the given diagram to the given file, with default encoding (UTF-8).
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="diagram"><#= diagramName #> to be saved.</param>
	/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
	/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(saveMethodsAccessModifier) #> virtual void SaveDiagram(DslModeling::SerializationResult serializationResult, <#= diagramTypeName #> diagram, string diagramFileName, bool writeOptionalPropertiesWithDefaultValue)
	{
		this.SaveDiagram(serializationResult, diagram, diagramFileName, global::System.Text.Encoding.UTF8, writeOptionalPropertiesWithDefaultValue);
	}

	/// <summary>
	/// Saves the given <#= diagramName #> to the given file, with specified encoding.
	/// </summary>
	/// <param name="serializationResult">Stores serialization result from the save operation.</param>
	/// <param name="diagram"><#= diagramName #> to be saved.</param>
	/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
	/// <param name="encoding">Encoding to use when saving the diagram.</param>
	/// <param name="writeOptionalPropertiesWithDefaultValue">Whether optional properties with default value will be saved.</param>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
	<#= CodeGenerationUtilities.GetTypeAccessModifier(saveMethodsAccessModifier) #> virtual void SaveDiagram(DslModeling::SerializationResult serializationResult, <#= diagramTypeName #> diagram, string diagramFileName, global::System.Text.Encoding encoding, bool writeOptionalPropertiesWithDefaultValue)
	{
		#region Check Parameters
		if (serializationResult == null)
			throw new global::System.ArgumentNullException("serializationResult");
		if (diagram == null)
			throw new global::System.ArgumentNullException("diagram");
		if (string.IsNullOrEmpty(diagramFileName))
			throw new global::System.ArgumentNullException("diagramFileName");
		#endregion

		if (serializationResult.Failed)
			return;

		using (global::System.IO.MemoryStream diagramFileContent = this.InternalSaveDiagram(serializationResult, diagram, diagramFileName, encoding, writeOptionalPropertiesWithDefaultValue))
		{
			if (!serializationResult.Failed)
			{
				// Only write the contents if there's no error encountered during serialization.
				if (diagramFileContent != null)
				{
					using (global::System.IO.FileStream fileStream = new global::System.IO.FileStream(diagramFileName, global::System.IO.FileMode.Create, global::System.IO.FileAccess.Write, global::System.IO.FileShare.None))
					{
						using (global::System.IO.BinaryWriter writer = new global::System.IO.BinaryWriter(fileStream, encoding))
						{
							writer.Write(diagramFileContent.ToArray());
						}
					}
				}
			}
		}
	}
<#
		}
	
		// Generate code to read and write the root element (both model root and diagram).
		string versionStr = CodeGenerationUtilities.WrapAsCSharpString(CodeGenerationUtilities.GetVersionString(this.Dsl));
#>

	/// <summary>
	/// Read an element from the root of XML.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="rootElement">In-memory element instance that will get the deserialized data.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	/// <param name="schemaResolver">An ISchemaResolver that allows the serializer to do schema validation on the root element (and everything inside it).</param>
	protected virtual void ReadRootElement(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement rootElement, global::System.Xml.XmlReader reader, DslModeling::ISchemaResolver schemaResolver)
	{
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert(serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException("serializationContext");
		global::System.Diagnostics.Debug.Assert(rootElement != null);
		if (rootElement == null)
			throw new global::System.ArgumentNullException("rootElement");
		global::System.Diagnostics.Debug.Assert(reader != null);
		if (reader == null)
			throw new global::System.ArgumentNullException("reader");
		#endregion

		DslModeling::DomainXmlSerializerDirectory directory = this.GetDirectory(rootElement.Store);

		DslModeling::DomainClassXmlSerializer rootSerializer = directory.GetSerializer(rootElement.GetDomainClass().Id);
		global::System.Diagnostics.Debug.Assert(rootSerializer != null, "Cannot find serializer for " + rootElement.GetDomainClass().Name + "!");

		// Version check.
		this.CheckVersion(serializationContext, reader);

		if (!serializationContext.Result.Failed)
		{	
			// Use a validating reader if possible
			using (reader = TryCreateValidatingReader(schemaResolver, reader, serializationContext))
			{
				rootSerializer.Read(serializationContext, rootElement, reader);
			}
		}

	}
	
	/// <summary>
	/// Write an element as the root of XML.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="rootElement">Root element instance that will be serialized.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param>
	public virtual void WriteRootElement(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement rootElement, global::System.Xml.XmlWriter writer)
	{
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert(serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException("serializationContext");
		global::System.Diagnostics.Debug.Assert(rootElement != null);
		if (rootElement == null)
			throw new global::System.ArgumentNullException("rootElement");
		global::System.Diagnostics.Debug.Assert(writer != null);
		if (writer == null)
			throw new global::System.ArgumentNullException("writer");
		#endregion

		DslModeling::DomainXmlSerializerDirectory directory = this.GetDirectory(rootElement.Store);

		DslModeling::DomainClassXmlSerializer rootSerializer = directory.GetSerializer(rootElement.GetDomainClass().Id);
		global::System.Diagnostics.Debug.Assert(rootSerializer != null, "Cannot find serializer for " + rootElement.GetDomainClass().Name + "!");

		// Set up root element settings
		DslModeling::RootElementSettings rootElementSettings = new DslModeling::RootElementSettings();
<#
		string schemaTargetNamespace = CodeGenerationUtilities.GetXmlSchemaNamespace(this.DslLibrary);

		if (diagram == null)
		{
#>
		rootElementSettings.SchemaTargetNamespace = <#= CodeGenerationUtilities.WrapAsCSharpString(schemaTargetNamespace) #>;
<#
		}
		else
		{
#>
		if (!(rootElement is DslDiagrams::Diagram))
		{
			// Only model has schema, diagram has no schema.
			rootElementSettings.SchemaTargetNamespace = <#= CodeGenerationUtilities.WrapAsCSharpString(schemaTargetNamespace) #>;
		}
<#
		}
#>
		rootElementSettings.Version = new global::System.Version(<#= versionStr #>);

		// Carry out the normal serialization.
		rootSerializer.Write(serializationContext, rootElement, writer, rootElementSettings);
	}

	/// <summary>
	/// Checks the version of the file being read.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="reader">Reader for the file being read. The reader is positioned at the open tag of the root element being read.</param>
	protected virtual void CheckVersion(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
	{
		return;
		/*
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert(serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException("serializationContext");
		global::System.Diagnostics.Debug.Assert(reader != null);
		if (reader == null)
			throw new global::System.ArgumentNullException("reader");
		#endregion

		global::System.Version expectedVersion = new global::System.Version(<#= versionStr #>);
		string dslVersionStr = reader.GetAttribute("dslVersion");
		if (dslVersionStr != null)
		{
			try
			{
				global::System.Version actualVersion = new global::System.Version(dslVersionStr);
				if (actualVersion != expectedVersion)
				{
					<#= behavior.Name #>SerializationMessages.VersionMismatch(serializationContext, reader, expectedVersion, actualVersion);
				}
			}
			catch (global::System.ArgumentException)
			{
				<#= behavior.Name #>SerializationMessages.InvalidPropertyValue(serializationContext, reader, "dslVersion", typeof(global::System.Version), dslVersionStr);
			}
			catch (global::System.FormatException)
			{
				<#= behavior.Name #>SerializationMessages.InvalidPropertyValue(serializationContext, reader, "dslVersion", typeof(global::System.Version), dslVersionStr);
			}
			catch (global::System.OverflowException)
			{
				<#= behavior.Name #>SerializationMessages.InvalidPropertyValue(serializationContext, reader, "dslVersion", typeof(global::System.Version), dslVersionStr);
			}
		}
		*/
	}


	/// <summary>
	/// Attempts to return a validating XML reader
	/// </summary>
	/// <returns>If all of the schema for registered serializers and all of the schema referenced in the file can be resolved,
	/// then a validating reader is returned. Otherwise, the supplied reader is returned.
	/// The serialization context will contain warning messages for all schema that could not be resolved.</returns>
	protected virtual global::System.Xml.XmlReader TryCreateValidatingReader(DslModeling::ISchemaResolver schemaResolver, global::System.Xml.XmlReader reader, DslModeling::SerializationContext serializationContext)
	{
		System.Diagnostics.Debug.Assert(serializationContext != null, "Serialization context should not be null");

		// Can't do anything without a schema resolver
		if (schemaResolver == null)
		{
			return reader;
		}
		
		global::System.Xml.Schema.XmlSchemaSet schemaSet = new global::System.Xml.Schema.XmlSchemaSet(reader.NameTable);

		// Combine the list of namespaces for models in the store with those referred to in the current node
		System.Collections.Generic.IEnumerable<string> namespaces = serializationContext.Directory.Namespaces.Select(n => n.TargetNamespace);
		namespaces = namespaces.Concat(DslModeling::SerializationUtilities.GetNamespacesFromCurrentNode(reader));		

		bool success = true;
		foreach (string ns in namespaces.Distinct())
		{
			// Try to resolve all namespaces so warnings are shown for all missing namespaces
			success = ResolveSchema(ns, schemaSet, schemaResolver, reader, serializationContext) & success;
		}

		if (success && schemaSet.Count > 0)
		{
			global::System.Xml.XmlReaderSettings readerSettings = reader.Settings.Clone();
			readerSettings.ConformanceLevel = global::System.Xml.ConformanceLevel.Auto;
			readerSettings.ValidationType = global::System.Xml.ValidationType.Schema;
			readerSettings.Schemas = schemaSet;
			<#= behavior.Name #>SchemaValidationCallback validationCallback = new <#= behavior.Name #>SchemaValidationCallback(serializationContext);
			readerSettings.ValidationEventHandler += new global::System.Xml.Schema.ValidationEventHandler(validationCallback.Handler);


			// Wrap the given reader as a validating reader and carry out the normal deserialization.
			global::System.Xml.XmlReader validatingReader = global::System.Xml.XmlReader.Create(reader, readerSettings);

			validationCallback.Reader = validatingReader;
			return validatingReader;
		}

		return reader;
	}

	/// <summary>
	/// Attempts to resolve the supplied schema namespace
	/// </summary>
	/// <remarks>If the schema can be resolved it is added to the supplied schema set. Otherwise, a 
	/// warning will be written to serializationContext.
	/// </remarks>
	/// <returns>A flag indicating whether the schema was resolved or not</returns>
	protected static bool ResolveSchema(string targetNamespace, global::System.Xml.Schema.XmlSchemaSet schemaSet, DslModeling::ISchemaResolver schemaResolver, global::System.Xml.XmlReader reader, DslModeling::SerializationContext serializationContext)
	{
		global::System.Collections.Generic.IList<string> schemas = schemaResolver.ResolveSchema(targetNamespace);
		if (schemas != null && schemas.Count > 0)
		{
			if (schemas.Count > 1)
			{
				<#= behavior.Name #>SerializationMessages.AmbiguousSchema(serializationContext, reader, targetNamespace, schemas[0]);
			}
			schemaSet.Add(targetNamespace, schemas[0]);
			return true;
		}

		<#= behavior.Name #>SerializationMessages.NoSchema(serializationContext, reader, targetNamespace);
		return false;
	}


	/// <summary>
	/// A utility class to handle schema validation warning/error
	/// </summary>
	private sealed class <#= behavior.Name #>SchemaValidationCallback
	{
		#region Member Variables
		/// <summary>
		/// SerializationContext to store schema validation warning/error.
		/// </summary>
		DslModeling::SerializationContext serializationContext;
		/// <summary>
		/// Reader that generates the schema warning/error.
		/// </summary>
		global::System.Xml.XmlReader reader;
		#endregion

		#region Constructor
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="serializationContext">SerializationContext to be used to store schema validation warning/error.</param>
		internal <#= behavior.Name #>SchemaValidationCallback(DslModeling::SerializationContext serializationContext)
		{
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			this.serializationContext = serializationContext;
		}
		#endregion

		#region Accessor
		/// <summary>
		/// Sets the reader that generates the schema validation warning/error.
		/// </summary>
		internal global::System.Xml.XmlReader Reader
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			set { this.reader = value; }
		}
		#endregion

		#region Callback method
		/// <summary>
		/// Callback to handler schema validation warning/error.
		/// </summary>
		internal void Handler(object sender, global::System.Xml.Schema.ValidationEventArgs e)
		{
			global::System.Diagnostics.Debug.Assert(this.serializationContext != null);
			if (this.serializationContext != null)
				<#= behavior.Name #>SerializationMessages.SchemaValidationError(this.serializationContext, this.reader, e.Message);
		}
		#endregion
	}

	/// <summary>
	/// Return the model in XML format
	/// </summary>
	/// <param name="modelRoot">Root instance to be saved.</param>
	/// <param name="encoding">Encoding to use when saving the root instance.</param>
	/// <returns>Model in XML form</returns>
	<#= CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) #> virtual string GetSerializedModelString(<#= this.Dsl.Editor.RootClass.GetFullName(true) #> modelRoot, global::System.Text.Encoding encoding)
	{
		string result = string.Empty;
		if (modelRoot == null)
		{
			return result;
		}

		DslModeling::SerializationResult serializationResult = new DslModeling::SerializationResult();
		using (global::System.IO.MemoryStream modelFileContent = this.InternalSaveModel(serializationResult, modelRoot, string.Empty, encoding, false))
		{
			if (!serializationResult.Failed && modelFileContent != null)
			{
				char[] chars = encoding.GetChars(modelFileContent.GetBuffer());

				// search the open angle bracket and trim off the Byte Of Mark.
				result = new string( chars);
				int indexPos = result.IndexOf('<');
				if (indexPos > 0)
				{
					// strip off the leading Byte Of Mark.
					result = result.Substring(indexPos);
				}

				// trim off trailing 0s.
				result = result.TrimEnd( '\0');
			}
		}
		return result;
	}
	

	#region Private/Helper Methods/Properties
		
	#region Class SerializationValidationObserver
	/// <summary>
	/// An utility class to collect validation messages during serialization, and store them in serialization result.
	/// </summary>
	protected sealed class SerializationValidationObserver : DslValidation::ValidationMessageObserver, global::System.IDisposable
	{
		#region Member Variables
		/// <summary>
		/// SerializationResult to store the messages.
		/// </summary>
		private DslModeling::SerializationResult serializationResult;
		/// <summary>
		/// ValidationController to get messages from.
		/// </summary>
		private DslValidation::ValidationController validationController;
		#endregion

		#region Constructor
		/// <summary>
		/// Constructor
		/// </summary>
		internal SerializationValidationObserver(DslModeling::SerializationResult serializationResult, DslValidation::ValidationController validationController)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			global::System.Diagnostics.Debug.Assert(validationController != null);
			#endregion

			this.serializationResult = serializationResult;
			this.validationController = validationController;

			// Subscribe to validation messages.
			this.validationController.AddObserver(this);
		}

		/// <summary>
		/// Destructor
		/// </summary>
		~SerializationValidationObserver()
		{
			this.Dispose(false);
		}
		#endregion

		#region Base Overrides
		/// <summary>
		/// Called with validation messages are added.
		/// </summary>
		protected override void OnValidationMessageAdded(DslValidation::ValidationMessage addedMessage)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(addedMessage != null);
			#endregion

			if (addedMessage != null && this.serializationResult != null)
			{	// Record the validation message as a serialization message.
				DslModeling::SerializationUtilities.AddValidationMessage(this.serializationResult, addedMessage);
			}
			base.OnValidationMessageAdded(addedMessage);
		}
		#endregion

		#region IDisposable Members
		/// <summary>
		/// IDisposable.Dispose().
		/// </summary>
		public void Dispose()
		{
			this.Dispose(true);
			global::System.GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Unregister the observer on dispose.
		/// </summary>
		private void Dispose(bool disposing)
		{
			global::System.Diagnostics.Debug.Assert(disposing, "SerializationValidationObserver finalized without being disposed!");
			if (disposing && this.validationController != null)
			{
				this.validationController.RemoveObserver(this);
				this.validationController = null;
			}
			this.serializationResult = null;
		}
		#endregion
	}
	#endregion
<#
		if (diagram != null)
		{
#>
	
	/// <summary>
	/// Go through the diagram to find all shapes that are not connected to a model element. Some of them may be by design, the rest are out-of-sync shapes.
	/// We want to make sure that all out-of-sync shapes are given a chance to fix themselves up, or post proper warning/error messages.
	/// </summary>
	/// <param name="diagram">The diagram of which the shapes are being checked.</param>
	/// <param name="serializationResult">SerializationResult to store warning/error in case an orphaned shape choose to do so.</param>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters")]
	protected virtual void CheckForOrphanedShapes(DslDiagrams::Diagram diagram, DslModeling::SerializationResult serializationResult)
	{
		global::System.Collections.Generic.List<DslDiagrams::ShapeElement> orphanedShapes = new global::System.Collections.Generic.List<DslDiagrams::ShapeElement>();
		diagram.IterateShapes(new OrphanedShapeIterator(orphanedShapes, diagram));
		foreach (DslDiagrams::ShapeElement orphanedShape in orphanedShapes)
		{
			if (serializationResult.Failed)
				break;

			orphanedShape.OnOrphaned(serializationResult);
		}
	}
	
	#region Class OrphanedShapeIterator
	/// <summary>
	/// An iterator to collect all the orphaned shapes.
	/// </summary>
	private class OrphanedShapeIterator : DslDiagrams::IShapeIterator
	{
		#region Member Variables
		/// <summary>
		/// Stores all iterated orphaned shapes.
		/// </summary>
		private global::System.Collections.Generic.List<DslDiagrams::ShapeElement> orphanedShapes;
		
		/// <summary>
		/// Diagram that contains the shapes to be iterated.
		/// </summary>
		private DslDiagrams::Diagram diagram;
		#endregion

		#region Constructor
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="orphanedShapes">Storage for all iterated orphaned shapes.</param>
		/// <param name="diagram">Diagram that contains the shapes to be iterated.</param>
		internal OrphanedShapeIterator(global::System.Collections.Generic.List<DslDiagrams::ShapeElement> orphanedShapes, DslDiagrams::Diagram diagram)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(orphanedShapes != null);
			global::System.Diagnostics.Debug.Assert(diagram != null);
			#endregion

			this.orphanedShapes = orphanedShapes;
			this.diagram = diagram;
		}
		#endregion

		#region IShapeIterator Members
		/// <summary>
		/// Called when a shape is encountered during iteration. The shape will be stored if it's orphaned.
		/// A shape is considered "orphaned" if:
		/// 1) It has a PresentationViewsSubject link out of it, but the Subject cannot be resolved.
		/// 2) It is a connector, and the Subject is null (regardless of the existence of PresentationViewsSubject relationship).
		/// </summary>
		/// <param name="shape">Shape encountered.</param>
		public void OnShape(DslDiagrams::ShapeElement shape)
		{
			if (this.diagram.IsOrphaned(shape))
				this.orphanedShapes.Add(shape);	// Orphaned.
		}
		#endregion
	}
	#endregion
<#
		}
#>
	#endregion
}

<#
		CloseNamespace();
	}
#>
<#+
private bool HasSwimlanes()
{
	foreach (DiagramElement element in this.DslLibrary.DiagramElements)
	{
		if (element is SwimLane)
		{
			return true;
		}
	}
	return false;
}

#>
