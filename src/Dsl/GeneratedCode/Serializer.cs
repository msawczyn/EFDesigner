//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelRootSerializer for DomainClass ModelRoot.
	/// </summary>
	public partial class ModelRootSerializer : DslModeling::DomainClassXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelRootSerializer Constructor
	   /// </summary>
	   public ModelRootSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelRoot.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRoot"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelRoot.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRootMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelRoot in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelRoot instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelRoot element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      ModelRoot instanceOfModelRoot = element as ModelRoot;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelRoot != null, "Expecting an instance of ModelRoot");
	
	      // LazyLoadingEnabled
	      if (!serializationContext.Result.Failed)
	      {
	         string attribLazyLoadingEnabled = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "lazyLoadingEnabled");
	         if (attribLazyLoadingEnabled != null)
	         {
	            global::System.Boolean valueOfLazyLoadingEnabled;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribLazyLoadingEnabled, out valueOfLazyLoadingEnabled))
	            {
	               instanceOfModelRoot.LazyLoadingEnabled = valueOfLazyLoadingEnabled;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "lazyLoadingEnabled", typeof(global::System.Boolean), attribLazyLoadingEnabled);
	            }
	         }
	      }
	      // EntityContainerAccess
	      if (!serializationContext.Result.Failed)
	      {
	         string attribEntityContainerAccess = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "entityContainerAccess");
	         if (attribEntityContainerAccess != null)
	         {
	            ContainerAccess valueOfEntityContainerAccess;
	            if (DslModeling::SerializationUtilities.TryGetValue<ContainerAccess>(serializationContext, attribEntityContainerAccess, out valueOfEntityContainerAccess))
	            {
	               instanceOfModelRoot.EntityContainerAccess = valueOfEntityContainerAccess;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "entityContainerAccess", typeof(ContainerAccess), attribEntityContainerAccess);
	            }
	         }
	      }
	      // EntityContainerName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribEntityContainerName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "entityContainerName");
	         if (attribEntityContainerName != null)
	         {
	            global::System.String valueOfEntityContainerName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribEntityContainerName, out valueOfEntityContainerName))
	            {
	               instanceOfModelRoot.EntityContainerName = valueOfEntityContainerName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "entityContainerName", typeof(global::System.String), attribEntityContainerName);
	            }
	         }
	      }
	      // Namespace
	      if (!serializationContext.Result.Failed)
	      {
	         string attribNamespace = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "namespace");
	         if (attribNamespace != null)
	         {
	            global::System.String valueOfNamespace;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNamespace, out valueOfNamespace))
	            {
	               instanceOfModelRoot.Namespace = valueOfNamespace;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "namespace", typeof(global::System.String), attribNamespace);
	            }
	         }
	      }
	      // DatabaseInitializerType
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDatabaseInitializerType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "databaseInitializerType");
	         if (attribDatabaseInitializerType != null)
	         {
	            DatabaseInitializerKind valueOfDatabaseInitializerType;
	            if (DslModeling::SerializationUtilities.TryGetValue<DatabaseInitializerKind>(serializationContext, attribDatabaseInitializerType, out valueOfDatabaseInitializerType))
	            {
	               instanceOfModelRoot.DatabaseInitializerType = valueOfDatabaseInitializerType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "databaseInitializerType", typeof(DatabaseInitializerKind), attribDatabaseInitializerType);
	            }
	         }
	      }
	      // ConnectionString
	      if (!serializationContext.Result.Failed)
	      {
	         string attribConnectionString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "connectionString");
	         if (attribConnectionString != null)
	         {
	            global::System.String valueOfConnectionString;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribConnectionString, out valueOfConnectionString))
	            {
	               instanceOfModelRoot.ConnectionString = valueOfConnectionString;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "connectionString", typeof(global::System.String), attribConnectionString);
	            }
	         }
	      }
	      // AutomaticMigrationsEnabled
	      if (!serializationContext.Result.Failed)
	      {
	         string attribAutomaticMigrationsEnabled = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "automaticMigrationsEnabled");
	         if (attribAutomaticMigrationsEnabled != null)
	         {
	            global::System.Boolean valueOfAutomaticMigrationsEnabled;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribAutomaticMigrationsEnabled, out valueOfAutomaticMigrationsEnabled))
	            {
	               instanceOfModelRoot.AutomaticMigrationsEnabled = valueOfAutomaticMigrationsEnabled;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "automaticMigrationsEnabled", typeof(global::System.Boolean), attribAutomaticMigrationsEnabled);
	            }
	         }
	      }
	      // EntityOutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         string attribEntityOutputDirectory = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "entityOutputDirectory");
	         if (attribEntityOutputDirectory != null)
	         {
	            global::System.String valueOfEntityOutputDirectory;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribEntityOutputDirectory, out valueOfEntityOutputDirectory))
	            {
	               instanceOfModelRoot.EntityOutputDirectory = valueOfEntityOutputDirectory;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "entityOutputDirectory", typeof(global::System.String), attribEntityOutputDirectory);
	            }
	         }
	      }
	      // ContextOutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         string attribContextOutputDirectory = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "contextOutputDirectory");
	         if (attribContextOutputDirectory != null)
	         {
	            global::System.String valueOfContextOutputDirectory;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribContextOutputDirectory, out valueOfContextOutputDirectory))
	            {
	               instanceOfModelRoot.ContextOutputDirectory = valueOfContextOutputDirectory;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "contextOutputDirectory", typeof(global::System.String), attribContextOutputDirectory);
	            }
	         }
	      }
	      // EnumOutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         string attribEnumOutputDirectory = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "enumOutputDirectory");
	         if (attribEnumOutputDirectory != null)
	         {
	            global::System.String valueOfEnumOutputDirectory;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribEnumOutputDirectory, out valueOfEnumOutputDirectory))
	            {
	               instanceOfModelRoot.EnumOutputDirectory = valueOfEnumOutputDirectory;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "enumOutputDirectory", typeof(global::System.String), attribEnumOutputDirectory);
	            }
	         }
	      }
	      // DatabaseSchema
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDatabaseSchema = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "databaseSchema");
	         if (attribDatabaseSchema != null)
	         {
	            global::System.String valueOfDatabaseSchema;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDatabaseSchema, out valueOfDatabaseSchema))
	            {
	               instanceOfModelRoot.DatabaseSchema = valueOfDatabaseSchema;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "databaseSchema", typeof(global::System.String), attribDatabaseSchema);
	            }
	         }
	      }
	      // ConcurrencyDefault
	      if (!serializationContext.Result.Failed)
	      {
	         string attribConcurrencyDefault = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "concurrencyDefault");
	         if (attribConcurrencyDefault != null)
	         {
	            Concurrency valueOfConcurrencyDefault;
	            if (DslModeling::SerializationUtilities.TryGetValue<Concurrency>(serializationContext, attribConcurrencyDefault, out valueOfConcurrencyDefault))
	            {
	               instanceOfModelRoot.ConcurrencyDefault = valueOfConcurrencyDefault;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "concurrencyDefault", typeof(Concurrency), attribConcurrencyDefault);
	            }
	         }
	      }
	      // FileNameMarker
	      if (!serializationContext.Result.Failed)
	      {
	         string attribFileNameMarker = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "fileNameMarker");
	         if (attribFileNameMarker != null)
	         {
	            global::System.String valueOfFileNameMarker;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribFileNameMarker, out valueOfFileNameMarker))
	            {
	               instanceOfModelRoot.FileNameMarker = valueOfFileNameMarker;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "fileNameMarker", typeof(global::System.String), attribFileNameMarker);
	            }
	         }
	      }
	      // EntityFrameworkVersion
	      if (!serializationContext.Result.Failed)
	      {
	         string attribEntityFrameworkVersion = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "entityFrameworkVersion");
	         if (attribEntityFrameworkVersion != null)
	         {
	            EFVersion valueOfEntityFrameworkVersion;
	            if (DslModeling::SerializationUtilities.TryGetValue<EFVersion>(serializationContext, attribEntityFrameworkVersion, out valueOfEntityFrameworkVersion))
	            {
	               instanceOfModelRoot.EntityFrameworkVersion = valueOfEntityFrameworkVersion;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "entityFrameworkVersion", typeof(EFVersion), attribEntityFrameworkVersion);
	            }
	         }
	      }
	      // ConnectionStringName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribConnectionStringName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "connectionStringName");
	         if (attribConnectionStringName != null)
	         {
	            global::System.String valueOfConnectionStringName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribConnectionStringName, out valueOfConnectionStringName))
	            {
	               instanceOfModelRoot.ConnectionStringName = valueOfConnectionStringName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "connectionStringName", typeof(global::System.String), attribConnectionStringName);
	            }
	         }
	      }
	      // ChopMethodChains
	      if (!serializationContext.Result.Failed)
	      {
	         string attribChopMethodChains = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "chopMethodChains");
	         if (attribChopMethodChains != null)
	         {
	            global::System.Boolean valueOfChopMethodChains;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribChopMethodChains, out valueOfChopMethodChains))
	            {
	               instanceOfModelRoot.ChopMethodChains = valueOfChopMethodChains;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "chopMethodChains", typeof(global::System.Boolean), attribChopMethodChains);
	            }
	         }
	      }
	      // InheritanceStrategy
	      if (!serializationContext.Result.Failed)
	      {
	         string attribInheritanceStrategy = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "inheritanceStrategy");
	         if (attribInheritanceStrategy != null)
	         {
	            CodeStrategy valueOfInheritanceStrategy;
	            if (DslModeling::SerializationUtilities.TryGetValue<CodeStrategy>(serializationContext, attribInheritanceStrategy, out valueOfInheritanceStrategy))
	            {
	               instanceOfModelRoot.InheritanceStrategy = valueOfInheritanceStrategy;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "inheritanceStrategy", typeof(CodeStrategy), attribInheritanceStrategy);
	            }
	         }
	      }
	      // DefaultCollectionClass
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDefaultCollectionClass = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "defaultCollectionClass");
	         if (attribDefaultCollectionClass != null)
	         {
	            global::System.String valueOfDefaultCollectionClass;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDefaultCollectionClass, out valueOfDefaultCollectionClass))
	            {
	               instanceOfModelRoot.DefaultCollectionClass = valueOfDefaultCollectionClass;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "defaultCollectionClass", typeof(global::System.String), attribDefaultCollectionClass);
	            }
	         }
	      }
	      // ProxyGenerationEnabled
	      if (!serializationContext.Result.Failed)
	      {
	         string attribProxyGenerationEnabled = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "proxyGenerationEnabled");
	         if (attribProxyGenerationEnabled != null)
	         {
	            global::System.Boolean valueOfProxyGenerationEnabled;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribProxyGenerationEnabled, out valueOfProxyGenerationEnabled))
	            {
	               instanceOfModelRoot.ProxyGenerationEnabled = valueOfProxyGenerationEnabled;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "proxyGenerationEnabled", typeof(global::System.Boolean), attribProxyGenerationEnabled);
	            }
	         }
	      }
	      // TransformOnSave
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTransformOnSave = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "transformOnSave");
	         if (attribTransformOnSave != null)
	         {
	            global::System.Boolean valueOfTransformOnSave;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTransformOnSave, out valueOfTransformOnSave))
	            {
	               instanceOfModelRoot.TransformOnSave = valueOfTransformOnSave;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "transformOnSave", typeof(global::System.Boolean), attribTransformOnSave);
	            }
	         }
	      }
	      // DefaultIdentityType
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDefaultIdentityType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "defaultIdentityType");
	         if (attribDefaultIdentityType != null)
	         {
	            global::System.String valueOfDefaultIdentityType;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDefaultIdentityType, out valueOfDefaultIdentityType))
	            {
	               instanceOfModelRoot.DefaultIdentityType = valueOfDefaultIdentityType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "defaultIdentityType", typeof(global::System.String), attribDefaultIdentityType);
	            }
	         }
	      }
	      // ShowCascadeDeletes
	      if (!serializationContext.Result.Failed)
	      {
	         string attribShowCascadeDeletes = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "showCascadeDeletes");
	         if (attribShowCascadeDeletes != null)
	         {
	            global::System.Boolean valueOfShowCascadeDeletes;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribShowCascadeDeletes, out valueOfShowCascadeDeletes))
	            {
	               instanceOfModelRoot.ShowCascadeDeletes = valueOfShowCascadeDeletes;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "showCascadeDeletes", typeof(global::System.Boolean), attribShowCascadeDeletes);
	            }
	         }
	      }
	      // DatabaseType
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDatabaseType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "databaseType");
	         if (attribDatabaseType != null)
	         {
	            DatabaseKind valueOfDatabaseType;
	            if (DslModeling::SerializationUtilities.TryGetValue<DatabaseKind>(serializationContext, attribDatabaseType, out valueOfDatabaseType))
	            {
	               instanceOfModelRoot.DatabaseType = valueOfDatabaseType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "databaseType", typeof(DatabaseKind), attribDatabaseType);
	            }
	         }
	      }
	      // WarnOnMissingDocumentation
	      if (!serializationContext.Result.Failed)
	      {
	         string attribWarnOnMissingDocumentation = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "warnOnMissingDocumentation");
	         if (attribWarnOnMissingDocumentation != null)
	         {
	            global::System.Boolean valueOfWarnOnMissingDocumentation;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribWarnOnMissingDocumentation, out valueOfWarnOnMissingDocumentation))
	            {
	               instanceOfModelRoot.WarnOnMissingDocumentation = valueOfWarnOnMissingDocumentation;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "warnOnMissingDocumentation", typeof(global::System.Boolean), attribWarnOnMissingDocumentation);
	            }
	         }
	      }
	      // EntityFrameworkPackageVersion
	      if (!serializationContext.Result.Failed)
	      {
	         string attribEntityFrameworkPackageVersion = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "entityFrameworkPackageVersion");
	         if (attribEntityFrameworkPackageVersion != null)
	         {
	            global::System.String valueOfEntityFrameworkPackageVersion;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribEntityFrameworkPackageVersion, out valueOfEntityFrameworkPackageVersion))
	            {
	               instanceOfModelRoot.EntityFrameworkPackageVersion = valueOfEntityFrameworkPackageVersion;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "entityFrameworkPackageVersion", typeof(global::System.String), attribEntityFrameworkPackageVersion);
	            }
	         }
	      }
	      // StructOutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         string attribStructOutputDirectory = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "structOutputDirectory");
	         if (attribStructOutputDirectory != null)
	         {
	            global::System.String valueOfStructOutputDirectory;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribStructOutputDirectory, out valueOfStructOutputDirectory))
	            {
	               instanceOfModelRoot.StructOutputDirectory = valueOfStructOutputDirectory;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "structOutputDirectory", typeof(global::System.String), attribStructOutputDirectory);
	            }
	         }
	      }
	      // DbSetAccess
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDbSetAccess = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "dbSetAccess");
	         if (attribDbSetAccess != null)
	         {
	            ContainerAccess valueOfDbSetAccess;
	            if (DslModeling::SerializationUtilities.TryGetValue<ContainerAccess>(serializationContext, attribDbSetAccess, out valueOfDbSetAccess))
	            {
	               instanceOfModelRoot.DbSetAccess = valueOfDbSetAccess;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "dbSetAccess", typeof(ContainerAccess), attribDbSetAccess);
	            }
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDescription = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "description");
	         if (attribDescription != null)
	         {
	            global::System.String valueOfDescription;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDescription, out valueOfDescription))
	            {
	               instanceOfModelRoot.Description = valueOfDescription;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSummary = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "summary");
	         if (attribSummary != null)
	         {
	            global::System.String valueOfSummary;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSummary, out valueOfSummary))
	            {
	               instanceOfModelRoot.Summary = valueOfSummary;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "summary", typeof(global::System.String), attribSummary);
	            }
	         }
	      }
	      // ShowWarningsInDesigner
	      if (!serializationContext.Result.Failed)
	      {
	         string attribShowWarningsInDesigner = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "showWarningsInDesigner");
	         if (attribShowWarningsInDesigner != null)
	         {
	            global::System.Boolean valueOfShowWarningsInDesigner;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribShowWarningsInDesigner, out valueOfShowWarningsInDesigner))
	            {
	               instanceOfModelRoot.ShowWarningsInDesigner = valueOfShowWarningsInDesigner;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "showWarningsInDesigner", typeof(global::System.Boolean), attribShowWarningsInDesigner);
	            }
	         }
	      }
	      // EntityNamespace
	      if (!serializationContext.Result.Failed)
	      {
	         string attribEntityNamespace = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "entityNamespace");
	         if (attribEntityNamespace != null)
	         {
	            global::System.String valueOfEntityNamespace;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribEntityNamespace, out valueOfEntityNamespace))
	            {
	               instanceOfModelRoot.EntityNamespace = valueOfEntityNamespace;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "entityNamespace", typeof(global::System.String), attribEntityNamespace);
	            }
	         }
	      }
	      // EnumNamespace
	      if (!serializationContext.Result.Failed)
	      {
	         string attribEnumNamespace = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "enumNamespace");
	         if (attribEnumNamespace != null)
	         {
	            global::System.String valueOfEnumNamespace;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribEnumNamespace, out valueOfEnumNamespace))
	            {
	               instanceOfModelRoot.EnumNamespace = valueOfEnumNamespace;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "enumNamespace", typeof(global::System.String), attribEnumNamespace);
	            }
	         }
	      }
	      // StructNamespace
	      if (!serializationContext.Result.Failed)
	      {
	         string attribStructNamespace = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "structNamespace");
	         if (attribStructNamespace != null)
	         {
	            global::System.String valueOfStructNamespace;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribStructNamespace, out valueOfStructNamespace))
	            {
	               instanceOfModelRoot.StructNamespace = valueOfStructNamespace;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "structNamespace", typeof(global::System.String), attribStructNamespace);
	            }
	         }
	      }
	      // ExposeForeignKeys
	      if (!serializationContext.Result.Failed)
	      {
	         string attribExposeForeignKeys = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "exposeForeignKeys");
	         if (attribExposeForeignKeys != null)
	         {
	            global::System.Boolean valueOfExposeForeignKeys;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribExposeForeignKeys, out valueOfExposeForeignKeys))
	            {
	               instanceOfModelRoot.ExposeForeignKeys = valueOfExposeForeignKeys;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "exposeForeignKeys", typeof(global::System.Boolean), attribExposeForeignKeys);
	            }
	         }
	      }
	      // BaseClass
	      if (!serializationContext.Result.Failed)
	      {
	         string attribBaseClass = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "baseClass");
	         if (attribBaseClass != null)
	         {
	            global::System.String valueOfBaseClass;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribBaseClass, out valueOfBaseClass))
	            {
	               instanceOfModelRoot.BaseClass = valueOfBaseClass;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "baseClass", typeof(global::System.String), attribBaseClass);
	            }
	         }
	      }
	      // ShowGrid
	      if (!serializationContext.Result.Failed)
	      {
	         string attribShowGrid = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "showGrid");
	         if (attribShowGrid != null)
	         {
	            global::System.Boolean valueOfShowGrid;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribShowGrid, out valueOfShowGrid))
	            {
	               instanceOfModelRoot.ShowGrid = valueOfShowGrid;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "showGrid", typeof(global::System.Boolean), attribShowGrid);
	            }
	         }
	      }
	      // SnapToGrid
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSnapToGrid = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "snapToGrid");
	         if (attribSnapToGrid != null)
	         {
	            global::System.Boolean valueOfSnapToGrid;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSnapToGrid, out valueOfSnapToGrid))
	            {
	               instanceOfModelRoot.SnapToGrid = valueOfSnapToGrid;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "snapToGrid", typeof(global::System.Boolean), attribSnapToGrid);
	            }
	         }
	      }
	      // GridColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribGridColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "gridColor");
	         if (attribGridColor != null)
	         {
	            global::System.Drawing.Color valueOfGridColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribGridColor, out valueOfGridColor))
	            {
	               instanceOfModelRoot.GridColor = valueOfGridColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "gridColor", typeof(global::System.Drawing.Color), attribGridColor);
	            }
	         }
	      }
	      // GridSize
	      if (!serializationContext.Result.Failed)
	      {
	         string attribGridSize = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "gridSize");
	         if (attribGridSize != null)
	         {
	            global::System.Int16 valueOfGridSize;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Int16>(serializationContext, attribGridSize, out valueOfGridSize))
	            {
	               instanceOfModelRoot.GridSize = valueOfGridSize;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "gridSize", typeof(global::System.Int16), attribGridSize);
	            }
	         }
	      }
	      // ShowForeignKeyPropertyNames
	      if (!serializationContext.Result.Failed)
	      {
	         string attribShowForeignKeyPropertyNames = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "showForeignKeyPropertyNames");
	         if (attribShowForeignKeyPropertyNames != null)
	         {
	            global::System.Boolean valueOfShowForeignKeyPropertyNames;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribShowForeignKeyPropertyNames, out valueOfShowForeignKeyPropertyNames))
	            {
	               instanceOfModelRoot.ShowForeignKeyPropertyNames = valueOfShowForeignKeyPropertyNames;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "showForeignKeyPropertyNames", typeof(global::System.Boolean), attribShowForeignKeyPropertyNames);
	            }
	         }
	      }
	      // DatabaseCollationDefault
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDatabaseCollationDefault = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "databaseCollationDefault");
	         if (attribDatabaseCollationDefault != null)
	         {
	            global::System.String valueOfDatabaseCollationDefault;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDatabaseCollationDefault, out valueOfDatabaseCollationDefault))
	            {
	               instanceOfModelRoot.DatabaseCollationDefault = valueOfDatabaseCollationDefault;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "databaseCollationDefault", typeof(global::System.String), attribDatabaseCollationDefault);
	            }
	         }
	      }
	      // PropertyAccessModeDefault
	      if (!serializationContext.Result.Failed)
	      {
	         string attribPropertyAccessModeDefault = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "propertyAccessModeDefault");
	         if (attribPropertyAccessModeDefault != null)
	         {
	            PropertyAccessMode valueOfPropertyAccessModeDefault;
	            if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccessMode>(serializationContext, attribPropertyAccessModeDefault, out valueOfPropertyAccessModeDefault))
	            {
	               instanceOfModelRoot.PropertyAccessModeDefault = valueOfPropertyAccessModeDefault;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "propertyAccessModeDefault", typeof(PropertyAccessMode), attribPropertyAccessModeDefault);
	            }
	         }
	      }
	      // UseTabs
	      if (!serializationContext.Result.Failed)
	      {
	         string attribUseTabs = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useTabs");
	         if (attribUseTabs != null)
	         {
	            global::System.Boolean valueOfUseTabs;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUseTabs, out valueOfUseTabs))
	            {
	               instanceOfModelRoot.UseTabs = valueOfUseTabs;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useTabs", typeof(global::System.Boolean), attribUseTabs);
	            }
	         }
	      }
	      // GenerateDbContextFactory
	      if (!serializationContext.Result.Failed)
	      {
	         string attribGenerateDbContextFactory = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "generateDbContextFactory");
	         if (attribGenerateDbContextFactory != null)
	         {
	            global::System.Boolean valueOfGenerateDbContextFactory;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribGenerateDbContextFactory, out valueOfGenerateDbContextFactory))
	            {
	               instanceOfModelRoot.GenerateDbContextFactory = valueOfGenerateDbContextFactory;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generateDbContextFactory", typeof(global::System.Boolean), attribGenerateDbContextFactory);
	            }
	         }
	      }
	      // EntityDefaultConstructorVisibilityDefault
	      if (!serializationContext.Result.Failed)
	      {
	         string attribEntityDefaultConstructorVisibilityDefault = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "entityDefaultConstructorVisibilityDefault");
	         if (attribEntityDefaultConstructorVisibilityDefault != null)
	         {
	            TypeAccessModifierExt valueOfEntityDefaultConstructorVisibilityDefault;
	            if (DslModeling::SerializationUtilities.TryGetValue<TypeAccessModifierExt>(serializationContext, attribEntityDefaultConstructorVisibilityDefault, out valueOfEntityDefaultConstructorVisibilityDefault))
	            {
	               instanceOfModelRoot.EntityDefaultConstructorVisibilityDefault = valueOfEntityDefaultConstructorVisibilityDefault;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "entityDefaultConstructorVisibilityDefault", typeof(TypeAccessModifierExt), attribEntityDefaultConstructorVisibilityDefault);
	            }
	         }
	      }
	      // PluralizeDbSetNames
	      if (!serializationContext.Result.Failed)
	      {
	         string attribPluralizeDbSetNames = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "pluralizeDbSetNames");
	         if (attribPluralizeDbSetNames != null)
	         {
	            global::System.Boolean valueOfPluralizeDbSetNames;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribPluralizeDbSetNames, out valueOfPluralizeDbSetNames))
	            {
	               instanceOfModelRoot.PluralizeDbSetNames = valueOfPluralizeDbSetNames;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "pluralizeDbSetNames", typeof(global::System.Boolean), attribPluralizeDbSetNames);
	            }
	         }
	      }
	      // PluralizeTableNames
	      if (!serializationContext.Result.Failed)
	      {
	         string attribPluralizeTableNames = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "pluralizeTableNames");
	         if (attribPluralizeTableNames != null)
	         {
	            global::System.Boolean valueOfPluralizeTableNames;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribPluralizeTableNames, out valueOfPluralizeTableNames))
	            {
	               instanceOfModelRoot.PluralizeTableNames = valueOfPluralizeTableNames;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "pluralizeTableNames", typeof(global::System.Boolean), attribPluralizeTableNames);
	            }
	         }
	      }
	      // ShadowKeyNamePattern
	      if (!serializationContext.Result.Failed)
	      {
	         string attribShadowKeyNamePattern = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "shadowKeyNamePattern");
	         if (attribShadowKeyNamePattern != null)
	         {
	            ShadowKeyPattern valueOfShadowKeyNamePattern;
	            if (DslModeling::SerializationUtilities.TryGetValue<ShadowKeyPattern>(serializationContext, attribShadowKeyNamePattern, out valueOfShadowKeyNamePattern))
	            {
	               instanceOfModelRoot.ShadowKeyNamePattern = valueOfShadowKeyNamePattern;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "shadowKeyNamePattern", typeof(ShadowKeyPattern), attribShadowKeyNamePattern);
	            }
	         }
	      }
	      // AutoPropertyDefault
	      if (!serializationContext.Result.Failed)
	      {
	         string attribAutoPropertyDefault = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "autoPropertyDefault");
	         if (attribAutoPropertyDefault != null)
	         {
	            global::System.Boolean valueOfAutoPropertyDefault;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribAutoPropertyDefault, out valueOfAutoPropertyDefault))
	            {
	               instanceOfModelRoot.AutoPropertyDefault = valueOfAutoPropertyDefault;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "autoPropertyDefault", typeof(global::System.Boolean), attribAutoPropertyDefault);
	            }
	         }
	      }
	      // ShowInterfaceIndicators
	      if (!serializationContext.Result.Failed)
	      {
	         string attribShowInterfaceIndicators = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "showInterfaceIndicators");
	         if (attribShowInterfaceIndicators != null)
	         {
	            global::System.Boolean valueOfShowInterfaceIndicators;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribShowInterfaceIndicators, out valueOfShowInterfaceIndicators))
	            {
	               instanceOfModelRoot.ShowInterfaceIndicators = valueOfShowInterfaceIndicators;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "showInterfaceIndicators", typeof(global::System.Boolean), attribShowInterfaceIndicators);
	            }
	         }
	      }
	      // GenerateTableComments
	      if (!serializationContext.Result.Failed)
	      {
	         string attribGenerateTableComments = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "generateTableComments");
	         if (attribGenerateTableComments != null)
	         {
	            global::System.Boolean valueOfGenerateTableComments;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribGenerateTableComments, out valueOfGenerateTableComments))
	            {
	               instanceOfModelRoot.GenerateTableComments = valueOfGenerateTableComments;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generateTableComments", typeof(global::System.Boolean), attribGenerateTableComments);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	      ModelRoot instanceOfModelRoot = element as ModelRoot;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelRoot != null, "Expecting an instance of ModelRoot!");
	
	      // Read child model elements (which are always serialized as nested XML elements).
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	         ReadChildElements(serializationContext, instanceOfModelRoot, reader);
	   }
	
	   /// <summary>
	   /// This method deserializes all child model elements.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first child XML element to deserialized.
	   /// This method will read as many child elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
	   ///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
	   ///    should return immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
	   private static void ReadChildElements(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         switch (reader.LocalName)
	         {
	            case "comments":   // Relationship "ModelRootHasComments"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <comments>
	                  ReadModelRootHasCommentsInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </comments>
	               }
	               break;
	            case "enums":   // Relationship "ModelRootHasEnums"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <enums>
	                  ReadModelRootHasEnumsInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </enums>
	               }
	               break;
	            case "classes":   // Relationship "ModelRootHasClasses"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <classes>
	                  ReadModelRootHasClassesInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </classes>
	               }
	               break;
	            case "diagrams":   // Relationship "ModelRootHasModelDiagrams"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <diagrams>
	                  ReadModelRootHasModelDiagramsInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </diagrams>
	               }
	               break;
	            default:
			         return;  // Don't know this element.
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship ModelRootHasComments.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   private static void ReadModelRootHasCommentsInstances(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newCommentOfModelRootHasCommentsSerializer = serializationContext.Directory.GetSerializer(Comment.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newCommentOfModelRootHasCommentsSerializer != null, "Cannot find serializer for Comment!");
	         Comment newCommentOfModelRootHasComments = newCommentOfModelRootHasCommentsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Comment;
	         if (newCommentOfModelRootHasComments != null)
	         {
	            element.Comments.Add(newCommentOfModelRootHasComments);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newCommentOfModelRootHasComments.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newCommentOfModelRootHasComments.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newCommentOfModelRootHasComments, reader);
	         }
	         else
	         {
	            global::System.Type typeofModelRootHasComments = typeof(ModelRootHasComments);
	            DslModeling::DomainRelationshipXmlSerializer newModelRootHasCommentsSerializer = serializationContext.Directory.GetSerializer(ModelRootHasComments.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
	            global::System.Diagnostics.Debug.Assert(newModelRootHasCommentsSerializer != null, "Cannot find serializer for ModelRootHasComments!");
	            ModelRootHasComments newModelRootHasComments = newModelRootHasCommentsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelRootHasComments;
	            if (newModelRootHasComments != null)
	            {
	               if (newModelRootHasComments.GetType() == typeofModelRootHasComments)
	               {   // The relationship should be serialized in short-form.
	                  EFModelSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ModelRootHasComments));
	               }
	               DslModeling::DomainRoleInfo.SetRolePlayer (newModelRootHasComments, ModelRootHasComments.ModelRootDomainRoleId, element);
	               DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelRootHasComments.GetDomainClass().Id);
	               global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelRootHasComments.GetDomainClass().Name + "!");
	               targetSerializer.Read(serializationContext, newModelRootHasComments, reader);
	            }
	            else
	            {   // Unknown element, skip
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship ModelRootHasEnums.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   private static void ReadModelRootHasEnumsInstances(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newModelRootHasEnumsSerializer = serializationContext.Directory.GetSerializer(ModelRootHasEnums.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newModelRootHasEnumsSerializer != null, "Cannot find serializer for ModelRootHasEnums!");
	         ModelRootHasEnums newModelRootHasEnums = newModelRootHasEnumsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelRootHasEnums;
	         if (newModelRootHasEnums != null)
	         {
	            DslModeling::DomainRoleInfo.SetRolePlayer (newModelRootHasEnums, ModelRootHasEnums.ModelRootDomainRoleId, element);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelRootHasEnums.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelRootHasEnums.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newModelRootHasEnums, reader);
	         }
	         else
	         {   // Maybe the relationship is serialized in short-form by mistake.
	            DslModeling::DomainClassXmlSerializer newModelEnumOfModelRootHasEnumsSerializer = serializationContext.Directory.GetSerializer(ModelEnum.DomainClassId);
	            global::System.Diagnostics.Debug.Assert(newModelEnumOfModelRootHasEnumsSerializer != null, "Cannot find serializer for ModelEnum!");
	            ModelEnum newModelEnumOfModelRootHasEnums = newModelEnumOfModelRootHasEnumsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelEnum;
	            if (newModelEnumOfModelRootHasEnums != null)
	            {
	               EFModelSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(ModelRootHasEnums));
	               element.Enums.Add(newModelEnumOfModelRootHasEnums);
	               DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelEnumOfModelRootHasEnums.GetDomainClass().Id);
	               global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelEnumOfModelRootHasEnums.GetDomainClass().Name + "!");
	               targetSerializer.Read(serializationContext, newModelEnumOfModelRootHasEnums, reader);
	            }
	            else
	            {   // Unknown element, skip.
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship ModelRootHasClasses.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   private static void ReadModelRootHasClassesInstances(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newModelRootHasClassesSerializer = serializationContext.Directory.GetSerializer(ModelRootHasClasses.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newModelRootHasClassesSerializer != null, "Cannot find serializer for ModelRootHasClasses!");
	         ModelRootHasClasses newModelRootHasClasses = newModelRootHasClassesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelRootHasClasses;
	         if (newModelRootHasClasses != null)
	         {
	            DslModeling::DomainRoleInfo.SetRolePlayer (newModelRootHasClasses, ModelRootHasClasses.ModelRootDomainRoleId, element);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelRootHasClasses.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelRootHasClasses.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newModelRootHasClasses, reader);
	         }
	         else
	         {   // Maybe the relationship is serialized in short-form by mistake.
	            DslModeling::DomainClassXmlSerializer newModelClassOfModelRootHasClassesSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
	            global::System.Diagnostics.Debug.Assert(newModelClassOfModelRootHasClassesSerializer != null, "Cannot find serializer for ModelClass!");
	            ModelClass newModelClassOfModelRootHasClasses = newModelClassOfModelRootHasClassesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelClass;
	            if (newModelClassOfModelRootHasClasses != null)
	            {
	               EFModelSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(ModelRootHasClasses));
	               element.Classes.Add(newModelClassOfModelRootHasClasses);
	               DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelClassOfModelRootHasClasses.GetDomainClass().Id);
	               global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelClassOfModelRootHasClasses.GetDomainClass().Name + "!");
	               targetSerializer.Read(serializationContext, newModelClassOfModelRootHasClasses, reader);
	            }
	            else
	            {   // Unknown element, skip.
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship ModelRootHasModelDiagrams.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRoot instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   private static void ReadModelRootHasModelDiagramsInstances(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newModelRootHasModelDiagramsSerializer = serializationContext.Directory.GetSerializer(ModelRootHasModelDiagrams.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newModelRootHasModelDiagramsSerializer != null, "Cannot find serializer for ModelRootHasModelDiagrams!");
	         ModelRootHasModelDiagrams newModelRootHasModelDiagrams = newModelRootHasModelDiagramsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelRootHasModelDiagrams;
	         if (newModelRootHasModelDiagrams != null)
	         {
	            DslModeling::DomainRoleInfo.SetRolePlayer (newModelRootHasModelDiagrams, ModelRootHasModelDiagrams.ModelRootDomainRoleId, element);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelRootHasModelDiagrams.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelRootHasModelDiagrams.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newModelRootHasModelDiagrams, reader);
	         }
	         else
	         {   // Maybe the relationship is serialized in short-form by mistake.
	            DslModeling::DomainClassXmlSerializer newModelDiagramDataOfModelRootHasModelDiagramsSerializer = serializationContext.Directory.GetSerializer(ModelDiagramData.DomainClassId);
	            global::System.Diagnostics.Debug.Assert(newModelDiagramDataOfModelRootHasModelDiagramsSerializer != null, "Cannot find serializer for ModelDiagramData!");
	            ModelDiagramData newModelDiagramDataOfModelRootHasModelDiagrams = newModelDiagramDataOfModelRootHasModelDiagramsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelDiagramData;
	            if (newModelDiagramDataOfModelRootHasModelDiagrams != null)
	            {
	               EFModelSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(ModelRootHasModelDiagrams));
	               element.Diagrams.Add(newModelDiagramDataOfModelRootHasModelDiagrams);
	               DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelDiagramDataOfModelRootHasModelDiagrams.GetDomainClass().Id);
	               global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelDiagramDataOfModelRootHasModelDiagrams.GetDomainClass().Name + "!");
	               targetSerializer.Read(serializationContext, newModelDiagramDataOfModelRootHasModelDiagrams, reader);
	            }
	            else
	            {   // Unknown element, skip.
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelRoot based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelRoot, a new ModelRoot instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a serialized ModelRoot instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRoot" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRoot".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               ModelRootSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelRoot based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelRoot.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelRoot instance should be created.</param>
	   /// <returns>Created ModelRoot instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new ModelRoot(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelRoot, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelRoot.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRoot.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelRoot itself) instance of ModelRoot based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRoot" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRoot".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelRootSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelRoot based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelRoot.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRoot, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRoot.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRoot.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelRoot instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRoot instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelRoot instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelRoot instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelRoot instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRoot instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRoot instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      ModelRoot instanceOfModelRoot = element as ModelRoot;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelRoot != null, "Expecting an instance of ModelRoot");
	
	      // LazyLoadingEnabled
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.LazyLoadingEnabled;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "lazyLoadingEnabled", serializedPropValue);
	            }
	         }
	      }
	      // EntityContainerAccess
	      if (!serializationContext.Result.Failed)
	      {
	         ContainerAccess propValue = instanceOfModelRoot.EntityContainerAccess;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<ContainerAccess>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Public") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "entityContainerAccess", serializedPropValue);
	            }
	         }
	      }
	      // EntityContainerName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.EntityContainerName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "entityContainerName", propValue);
	
	         }
	      }
	      // Namespace
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.Namespace;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "namespace", propValue);
	
	         }
	      }
	      // DatabaseInitializerType
	      if (!serializationContext.Result.Failed)
	      {
	         DatabaseInitializerKind propValue = instanceOfModelRoot.DatabaseInitializerType;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<DatabaseInitializerKind>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "MigrateDatabaseToLatestVersion") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "databaseInitializerType", serializedPropValue);
	            }
	         }
	      }
	      // ConnectionString
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.ConnectionString;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "connectionString", propValue);
	
	         }
	      }
	      // AutomaticMigrationsEnabled
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.AutomaticMigrationsEnabled;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "automaticMigrationsEnabled", serializedPropValue);
	         }
	      }
	      // EntityOutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.EntityOutputDirectory;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "entityOutputDirectory", propValue);
	
	         }
	      }
	      // ContextOutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.ContextOutputDirectory;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "contextOutputDirectory", propValue);
	
	         }
	      }
	      // EnumOutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.EnumOutputDirectory;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "enumOutputDirectory", propValue);
	
	         }
	      }
	      // DatabaseSchema
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.DatabaseSchema;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "dbo") != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "databaseSchema", propValue);
	            }
	         }
	      }
	      // ConcurrencyDefault
	      if (!serializationContext.Result.Failed)
	      {
	         Concurrency propValue = instanceOfModelRoot.ConcurrencyDefault;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<Concurrency>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "concurrencyDefault", serializedPropValue);
	            }
	         }
	      }
	      // FileNameMarker
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.FileNameMarker;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "generated") != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "fileNameMarker", propValue);
	            }
	         }
	      }
	      // EntityFrameworkVersion
	      if (!serializationContext.Result.Failed)
	      {
	         EFVersion propValue = instanceOfModelRoot.EntityFrameworkVersion;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<EFVersion>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "EFCore") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "entityFrameworkVersion", serializedPropValue);
	            }
	         }
	      }
	      // ConnectionStringName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.ConnectionStringName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "connectionStringName", propValue);
	
	         }
	      }
	      // ChopMethodChains
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.ChopMethodChains;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "chopMethodChains", serializedPropValue);
	            }
	         }
	      }
	      // InheritanceStrategy
	      if (!serializationContext.Result.Failed)
	      {
	         CodeStrategy propValue = instanceOfModelRoot.InheritanceStrategy;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<CodeStrategy>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "TablePerHierarchy") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "inheritanceStrategy", serializedPropValue);
	            }
	         }
	      }
	      // DefaultCollectionClass
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.DefaultCollectionClass;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "HashSet") != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "defaultCollectionClass", propValue);
	            }
	         }
	      }
	      // ProxyGenerationEnabled
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.ProxyGenerationEnabled;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "proxyGenerationEnabled", serializedPropValue);
	            }
	         }
	      }
	      // TransformOnSave
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.TransformOnSave;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "transformOnSave", serializedPropValue);
	            }
	         }
	      }
	      // DefaultIdentityType
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.DefaultIdentityType;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Int64") != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "defaultIdentityType", propValue);
	            }
	         }
	      }
	      // ShowCascadeDeletes
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.ShowCascadeDeletes;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "showCascadeDeletes", serializedPropValue);
	         }
	      }
	      // DatabaseType
	      if (!serializationContext.Result.Failed)
	      {
	         DatabaseKind propValue = instanceOfModelRoot.DatabaseType;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<DatabaseKind>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "databaseType", serializedPropValue);
	         }
	      }
	      // WarnOnMissingDocumentation
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.WarnOnMissingDocumentation;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "warnOnMissingDocumentation", serializedPropValue);
	            }
	         }
	      }
	      // EntityFrameworkPackageVersion
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.EntityFrameworkPackageVersion;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "Latest") != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "entityFrameworkPackageVersion", propValue);
	            }
	         }
	      }
	      // StructOutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.StructOutputDirectory;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "structOutputDirectory", propValue);
	
	         }
	      }
	      // DbSetAccess
	      if (!serializationContext.Result.Failed)
	      {
	         ContainerAccess propValue = instanceOfModelRoot.DbSetAccess;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<ContainerAccess>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Public") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "dbSetAccess", serializedPropValue);
	            }
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.Description;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "description", propValue);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.Summary;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "summary", propValue);
	
	         }
	      }
	      // ShowWarningsInDesigner
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.ShowWarningsInDesigner;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "showWarningsInDesigner", serializedPropValue);
	            }
	         }
	      }
	      // EntityNamespace
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.EntityNamespace;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "entityNamespace", propValue);
	
	         }
	      }
	      // EnumNamespace
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.EnumNamespace;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "enumNamespace", propValue);
	
	         }
	      }
	      // StructNamespace
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.StructNamespace;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "structNamespace", propValue);
	
	         }
	      }
	      // ExposeForeignKeys
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.ExposeForeignKeys;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "exposeForeignKeys", serializedPropValue);
	         }
	      }
	      // BaseClass
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.BaseClass;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "DbContext") != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "baseClass", propValue);
	            }
	         }
	      }
	      // ShowGrid
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.ShowGrid;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "showGrid", serializedPropValue);
	            }
	         }
	      }
	      // SnapToGrid
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.SnapToGrid;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "snapToGrid", serializedPropValue);
	            }
	         }
	      }
	      // GridColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfModelRoot.GridColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "gridColor", serializedPropValue);
	            }
	         }
	      }
	      // GridSize
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Int16 propValue = instanceOfModelRoot.GridSize;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Int16>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "0") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "gridSize", serializedPropValue);
	            }
	         }
	      }
	      // ShowForeignKeyPropertyNames
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.ShowForeignKeyPropertyNames;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "showForeignKeyPropertyNames", serializedPropValue);
	            }
	         }
	      }
	      // DatabaseCollationDefault
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelRoot.DatabaseCollationDefault;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "default") != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "databaseCollationDefault", propValue);
	            }
	         }
	      }
	      // PropertyAccessModeDefault
	      if (!serializationContext.Result.Failed)
	      {
	         PropertyAccessMode propValue = instanceOfModelRoot.PropertyAccessModeDefault;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccessMode>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "FieldDuringConstruction") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "propertyAccessModeDefault", serializedPropValue);
	            }
	         }
	      }
	      // UseTabs
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.UseTabs;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useTabs", serializedPropValue);
	            }
	         }
	      }
	      // GenerateDbContextFactory
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.GenerateDbContextFactory;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "generateDbContextFactory", serializedPropValue);
	         }
	      }
	      // EntityDefaultConstructorVisibilityDefault
	      if (!serializationContext.Result.Failed)
	      {
	         TypeAccessModifierExt propValue = instanceOfModelRoot.EntityDefaultConstructorVisibilityDefault;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<TypeAccessModifierExt>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "entityDefaultConstructorVisibilityDefault", serializedPropValue);
	            }
	         }
	      }
	      // PluralizeDbSetNames
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.PluralizeDbSetNames;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "pluralizeDbSetNames", serializedPropValue);
	            }
	         }
	      }
	      // PluralizeTableNames
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.PluralizeTableNames;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "pluralizeTableNames", serializedPropValue);
	            }
	         }
	      }
	      // ShadowKeyNamePattern
	      if (!serializationContext.Result.Failed)
	      {
	         ShadowKeyPattern propValue = instanceOfModelRoot.ShadowKeyNamePattern;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<ShadowKeyPattern>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "TableColumn") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "shadowKeyNamePattern", serializedPropValue);
	            }
	         }
	      }
	      // AutoPropertyDefault
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.AutoPropertyDefault;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "autoPropertyDefault", serializedPropValue);
	            }
	         }
	      }
	      // ShowInterfaceIndicators
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.ShowInterfaceIndicators;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "showInterfaceIndicators", serializedPropValue);
	         }
	      }
	      // GenerateTableComments
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelRoot.GenerateTableComments;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "generateTableComments", serializedPropValue);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRoot instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	      ModelRoot instance = element as ModelRoot;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRoot!");
	
	      // Write child model elements (which are always serialized as nested XML elements).
	      if (!serializationContext.Result.Failed)
	         WriteChildElements(serializationContext, instance, writer);
	   }
	
	
	   /// <summary>
	   /// Serialize all child model elements.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRoot instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]
	   private static void WriteChildElements(DslModeling::SerializationContext serializationContext, ModelRoot element, global::System.Xml.XmlWriter writer)
	   {
	      // ModelRootHasComments
	      global::System.Collections.ObjectModel.ReadOnlyCollection<ModelRootHasComments> allModelRootHasCommentsInstances = ModelRootHasComments.GetLinksToComments(element);
	      if (!serializationContext.Result.Failed && allModelRootHasCommentsInstances.Count > 0)
	      {
	         writer.WriteStartElement("comments");
	         global::System.Type typeofModelRootHasComments = typeof(ModelRootHasComments);
	         foreach (ModelRootHasComments eachModelRootHasCommentsInstance in allModelRootHasCommentsInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         if (eachModelRootHasCommentsInstance.GetType() != typeofModelRootHasComments)
		         {   // Derived relationships will be serialized in full-form.
		            DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachModelRootHasCommentsInstance.GetDomainClass().Id);
		            global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachModelRootHasCommentsInstance.GetDomainClass().Name + "!");   
		            derivedRelSerializer.Write(serializationContext, eachModelRootHasCommentsInstance, writer);
		         }
		         else
		         {   // No need to serialize the relationship itself, just serialize the role-player directly.
			         DslModeling::ModelElement targetElement = eachModelRootHasCommentsInstance.Comment;
			         DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			         global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");   
			         targetSerializer.Write(serializationContext, targetElement, writer);
		         }
	         }
	         writer.WriteEndElement();
	      }
	
	      // ModelRootHasEnums
	      global::System.Collections.ObjectModel.ReadOnlyCollection<ModelRootHasEnums> allModelRootHasEnumsInstances = ModelRootHasEnums.GetLinksToEnums(element);
	      if (!serializationContext.Result.Failed && allModelRootHasEnumsInstances.Count > 0)
	      {
	         writer.WriteStartElement("enums");
	         foreach (ModelRootHasEnums eachModelRootHasEnumsInstance in allModelRootHasEnumsInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachModelRootHasEnumsInstance.GetDomainClass().Id);
		         global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachModelRootHasEnumsInstance.GetDomainClass().Name + "!");
		         relSerializer.Write(serializationContext, eachModelRootHasEnumsInstance, writer);
	         }
	         writer.WriteEndElement();
	      }
	
	      // ModelRootHasClasses
	      global::System.Collections.ObjectModel.ReadOnlyCollection<ModelRootHasClasses> allModelRootHasClassesInstances = ModelRootHasClasses.GetLinksToClasses(element);
	      if (!serializationContext.Result.Failed && allModelRootHasClassesInstances.Count > 0)
	      {
	         writer.WriteStartElement("classes");
	         foreach (ModelRootHasClasses eachModelRootHasClassesInstance in allModelRootHasClassesInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachModelRootHasClassesInstance.GetDomainClass().Id);
		         global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachModelRootHasClassesInstance.GetDomainClass().Name + "!");
		         relSerializer.Write(serializationContext, eachModelRootHasClassesInstance, writer);
	         }
	         writer.WriteEndElement();
	      }
	
	      // ModelRootHasModelDiagrams
	      global::System.Collections.ObjectModel.ReadOnlyCollection<ModelRootHasModelDiagrams> allModelRootHasModelDiagramsInstances = ModelRootHasModelDiagrams.GetLinksToDiagrams(element);
	      if (!serializationContext.Result.Failed && allModelRootHasModelDiagramsInstances.Count > 0)
	      {
	         writer.WriteStartElement("diagrams");
	         foreach (ModelRootHasModelDiagrams eachModelRootHasModelDiagramsInstance in allModelRootHasModelDiagramsInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachModelRootHasModelDiagramsInstance.GetDomainClass().Id);
		         global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachModelRootHasModelDiagramsInstance.GetDomainClass().Name + "!");
		         relSerializer.Write(serializationContext, eachModelRootHasModelDiagramsInstance, writer);
	         }
	         writer.WriteEndElement();
	      }
	
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelRoot instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRoot instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelRoot instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRoot instance = element as ModelRoot;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRoot!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRoot instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelClassSerializer for DomainClass ModelClass.
	/// </summary>
	public partial class ModelClassSerializer : DesignElementSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelClassSerializer Constructor
	   /// </summary>
	   public ModelClassSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelClass.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelClass"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelClass.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelClassMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelClass in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelClass instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelClass element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      ModelClass instanceOfModelClass = element as ModelClass;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass");
	
	      // IsAbstract
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsAbstract = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isAbstract");
	         if (attribIsAbstract != null)
	         {
	            global::System.Boolean valueOfIsAbstract;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsAbstract, out valueOfIsAbstract))
	            {
	               instanceOfModelClass.IsAbstract = valueOfIsAbstract;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isAbstract", typeof(global::System.Boolean), attribIsAbstract);
	            }
	         }
	      }
	      // TableName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTableName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "tableName");
	         if (attribTableName != null)
	         {
	            global::System.String valueOfTableName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTableName, out valueOfTableName))
	            {
	               instanceOfModelClass.TableName = valueOfTableName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "tableName", typeof(global::System.String), attribTableName);
	            }
	         }
	      }
	      // DatabaseSchema
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDatabaseSchema = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "databaseSchema");
	         if (attribDatabaseSchema != null)
	         {
	            global::System.String valueOfDatabaseSchema;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDatabaseSchema, out valueOfDatabaseSchema))
	            {
	               instanceOfModelClass.DatabaseSchema = valueOfDatabaseSchema;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "databaseSchema", typeof(global::System.String), attribDatabaseSchema);
	            }
	         }
	      }
	      // Concurrency
	      if (!serializationContext.Result.Failed)
	      {
	         string attribConcurrency = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "concurrency");
	         if (attribConcurrency != null)
	         {
	            ConcurrencyOverride valueOfConcurrency;
	            if (DslModeling::SerializationUtilities.TryGetValue<ConcurrencyOverride>(serializationContext, attribConcurrency, out valueOfConcurrency))
	            {
	               instanceOfModelClass.Concurrency = valueOfConcurrency;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "concurrency", typeof(ConcurrencyOverride), attribConcurrency);
	            }
	         }
	      }
	      // IsDatabaseSchemaTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsDatabaseSchemaTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isDatabaseSchemaTracking");
	         if (attribIsDatabaseSchemaTracking != null)
	         {
	            global::System.Boolean valueOfIsDatabaseSchemaTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsDatabaseSchemaTracking, out valueOfIsDatabaseSchemaTracking))
	            {
	               instanceOfModelClass.IsDatabaseSchemaTracking = valueOfIsDatabaseSchemaTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isDatabaseSchemaTracking", typeof(global::System.Boolean), attribIsDatabaseSchemaTracking);
	            }
	         }
	      }
	      // Namespace
	      if (!serializationContext.Result.Failed)
	      {
	         string attribNamespace = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "namespace");
	         if (attribNamespace != null)
	         {
	            global::System.String valueOfNamespace;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNamespace, out valueOfNamespace))
	            {
	               instanceOfModelClass.Namespace = valueOfNamespace;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "namespace", typeof(global::System.String), attribNamespace);
	            }
	         }
	      }
	      // IsNamespaceTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsNamespaceTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isNamespaceTracking");
	         if (attribIsNamespaceTracking != null)
	         {
	            global::System.Boolean valueOfIsNamespaceTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsNamespaceTracking, out valueOfIsNamespaceTracking))
	            {
	               instanceOfModelClass.IsNamespaceTracking = valueOfIsNamespaceTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isNamespaceTracking", typeof(global::System.Boolean), attribIsNamespaceTracking);
	            }
	         }
	      }
	      // DbSetName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDbSetName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "dbSetName");
	         if (attribDbSetName != null)
	         {
	            global::System.String valueOfDbSetName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDbSetName, out valueOfDbSetName))
	            {
	               instanceOfModelClass.DbSetName = valueOfDbSetName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "dbSetName", typeof(global::System.String), attribDbSetName);
	            }
	         }
	      }
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         string attribName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
	         if (attribName != null)
	         {
	            global::System.String valueOfName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
	            {
	               instanceOfModelClass.Name = valueOfName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
	            }
	         }
	      }
	      // ImplementNotify
	      if (!serializationContext.Result.Failed)
	      {
	         string attribImplementNotify = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "implementNotify");
	         if (attribImplementNotify != null)
	         {
	            global::System.Boolean valueOfImplementNotify;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribImplementNotify, out valueOfImplementNotify))
	            {
	               instanceOfModelClass.ImplementNotify = valueOfImplementNotify;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementNotify", typeof(global::System.Boolean), attribImplementNotify);
	            }
	         }
	      }
	      // CustomInterfaces
	      if (!serializationContext.Result.Failed)
	      {
	         string attribCustomInterfaces = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "customInterfaces");
	         if (attribCustomInterfaces != null)
	         {
	            global::System.String valueOfCustomInterfaces;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCustomInterfaces, out valueOfCustomInterfaces))
	            {
	               instanceOfModelClass.CustomInterfaces = valueOfCustomInterfaces;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customInterfaces", typeof(global::System.String), attribCustomInterfaces);
	            }
	         }
	      }
	      // IsDependentType
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsDependentType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isDependentType");
	         if (attribIsDependentType != null)
	         {
	            global::System.Boolean valueOfIsDependentType;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsDependentType, out valueOfIsDependentType))
	            {
	               instanceOfModelClass.IsDependentType = valueOfIsDependentType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isDependentType", typeof(global::System.Boolean), attribIsDependentType);
	            }
	         }
	      }
	      // OutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutputDirectory = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outputDirectory");
	         if (attribOutputDirectory != null)
	         {
	            global::System.String valueOfOutputDirectory;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribOutputDirectory, out valueOfOutputDirectory))
	            {
	               instanceOfModelClass.OutputDirectory = valueOfOutputDirectory;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outputDirectory", typeof(global::System.String), attribOutputDirectory);
	            }
	         }
	      }
	      // IsOutputDirectoryTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsOutputDirectoryTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isOutputDirectoryTracking");
	         if (attribIsOutputDirectoryTracking != null)
	         {
	            global::System.Boolean valueOfIsOutputDirectoryTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsOutputDirectoryTracking, out valueOfIsOutputDirectoryTracking))
	            {
	               instanceOfModelClass.IsOutputDirectoryTracking = valueOfIsOutputDirectoryTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isOutputDirectoryTracking", typeof(global::System.Boolean), attribIsOutputDirectoryTracking);
	            }
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDescription = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "description");
	         if (attribDescription != null)
	         {
	            global::System.String valueOfDescription;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDescription, out valueOfDescription))
	            {
	               instanceOfModelClass.Description = valueOfDescription;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSummary = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "summary");
	         if (attribSummary != null)
	         {
	            global::System.String valueOfSummary;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSummary, out valueOfSummary))
	            {
	               instanceOfModelClass.Summary = valueOfSummary;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "summary", typeof(global::System.String), attribSummary);
	            }
	         }
	      }
	      // CustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         string attribCustomAttributes = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "customAttributes");
	         if (attribCustomAttributes != null)
	         {
	            global::System.String valueOfCustomAttributes;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCustomAttributes, out valueOfCustomAttributes))
	            {
	               instanceOfModelClass.CustomAttributes = valueOfCustomAttributes;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customAttributes", typeof(global::System.String), attribCustomAttributes);
	            }
	         }
	      }
	      // AutoPropertyDefault
	      if (!serializationContext.Result.Failed)
	      {
	         string attribAutoPropertyDefault = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "autoPropertyDefault");
	         if (attribAutoPropertyDefault != null)
	         {
	            global::System.Boolean valueOfAutoPropertyDefault;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribAutoPropertyDefault, out valueOfAutoPropertyDefault))
	            {
	               instanceOfModelClass.AutoPropertyDefault = valueOfAutoPropertyDefault;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "autoPropertyDefault", typeof(global::System.Boolean), attribAutoPropertyDefault);
	            }
	         }
	      }
	      // GenerateCode
	      if (!serializationContext.Result.Failed)
	      {
	         string attribGenerateCode = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "generateCode");
	         if (attribGenerateCode != null)
	         {
	            global::System.Boolean valueOfGenerateCode;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribGenerateCode, out valueOfGenerateCode))
	            {
	               instanceOfModelClass.GenerateCode = valueOfGenerateCode;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generateCode", typeof(global::System.Boolean), attribGenerateCode);
	            }
	         }
	      }
	      // IsPropertyBag
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsPropertyBag = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isPropertyBag");
	         if (attribIsPropertyBag != null)
	         {
	            global::System.Boolean valueOfIsPropertyBag;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsPropertyBag, out valueOfIsPropertyBag))
	            {
	               instanceOfModelClass.IsPropertyBag = valueOfIsPropertyBag;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isPropertyBag", typeof(global::System.Boolean), attribIsPropertyBag);
	            }
	         }
	      }
	      // IsQueryType
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsQueryType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isQueryType");
	         if (attribIsQueryType != null)
	         {
	            global::System.Boolean valueOfIsQueryType;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsQueryType, out valueOfIsQueryType))
	            {
	               instanceOfModelClass.IsQueryType = valueOfIsQueryType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isQueryType", typeof(global::System.Boolean), attribIsQueryType);
	            }
	         }
	      }
	      // ExcludeFromMigrations
	      if (!serializationContext.Result.Failed)
	      {
	         string attribExcludeFromMigrations = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "excludeFromMigrations");
	         if (attribExcludeFromMigrations != null)
	         {
	            global::System.Boolean valueOfExcludeFromMigrations;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribExcludeFromMigrations, out valueOfExcludeFromMigrations))
	            {
	               instanceOfModelClass.ExcludeFromMigrations = valueOfExcludeFromMigrations;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "excludeFromMigrations", typeof(global::System.Boolean), attribExcludeFromMigrations);
	            }
	         }
	      }
	      // IsDatabaseView
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsDatabaseView = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isDatabaseView");
	         if (attribIsDatabaseView != null)
	         {
	            global::System.Boolean valueOfIsDatabaseView;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsDatabaseView, out valueOfIsDatabaseView))
	            {
	               instanceOfModelClass.IsDatabaseView = valueOfIsDatabaseView;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isDatabaseView", typeof(global::System.Boolean), attribIsDatabaseView);
	            }
	         }
	      }
	      // ViewName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribViewName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "viewName");
	         if (attribViewName != null)
	         {
	            global::System.String valueOfViewName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribViewName, out valueOfViewName))
	            {
	               instanceOfModelClass.ViewName = valueOfViewName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "viewName", typeof(global::System.String), attribViewName);
	            }
	         }
	      }
	      // DefaultConstructorVisibility
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDefaultConstructorVisibility = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "defaultConstructorVisibility");
	         if (attribDefaultConstructorVisibility != null)
	         {
	            TypeAccessModifierExt valueOfDefaultConstructorVisibility;
	            if (DslModeling::SerializationUtilities.TryGetValue<TypeAccessModifierExt>(serializationContext, attribDefaultConstructorVisibility, out valueOfDefaultConstructorVisibility))
	            {
	               instanceOfModelClass.DefaultConstructorVisibility = valueOfDefaultConstructorVisibility;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "defaultConstructorVisibility", typeof(TypeAccessModifierExt), attribDefaultConstructorVisibility);
	            }
	         }
	      }
	      // IsDefaultConstructorVisibilityTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsDefaultConstructorVisibilityTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isDefaultConstructorVisibilityTracking");
	         if (attribIsDefaultConstructorVisibilityTracking != null)
	         {
	            global::System.Boolean valueOfIsDefaultConstructorVisibilityTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsDefaultConstructorVisibilityTracking, out valueOfIsDefaultConstructorVisibilityTracking))
	            {
	               instanceOfModelClass.IsDefaultConstructorVisibilityTracking = valueOfIsDefaultConstructorVisibilityTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isDefaultConstructorVisibilityTracking", typeof(global::System.Boolean), attribIsDefaultConstructorVisibilityTracking);
	            }
	         }
	      }
	      // IsAutoPropertyDefaultTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsAutoPropertyDefaultTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isAutoPropertyDefaultTracking");
	         if (attribIsAutoPropertyDefaultTracking != null)
	         {
	            global::System.Boolean valueOfIsAutoPropertyDefaultTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsAutoPropertyDefaultTracking, out valueOfIsAutoPropertyDefaultTracking))
	            {
	               instanceOfModelClass.IsAutoPropertyDefaultTracking = valueOfIsAutoPropertyDefaultTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isAutoPropertyDefaultTracking", typeof(global::System.Boolean), attribIsAutoPropertyDefaultTracking);
	            }
	         }
	      }
	      // UseTemporalTables
	      if (!serializationContext.Result.Failed)
	      {
	         string attribUseTemporalTables = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "useTemporalTables");
	         if (attribUseTemporalTables != null)
	         {
	            global::System.Boolean valueOfUseTemporalTables;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribUseTemporalTables, out valueOfUseTemporalTables))
	            {
	               instanceOfModelClass.UseTemporalTables = valueOfUseTemporalTables;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "useTemporalTables", typeof(global::System.Boolean), attribUseTemporalTables);
	            }
	         }
	      }
	      // IsAssociationClass
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsAssociationClass = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isAssociationClass");
	         if (attribIsAssociationClass != null)
	         {
	            global::System.Boolean valueOfIsAssociationClass;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsAssociationClass, out valueOfIsAssociationClass))
	            {
	               instanceOfModelClass.IsAssociationClass = valueOfIsAssociationClass;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isAssociationClass", typeof(global::System.Boolean), attribIsAssociationClass);
	            }
	         }
	      }
	      // DescribedAssociationElementId
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDescribedAssociationElementId = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "describedAssociationElementId");
	         if (attribDescribedAssociationElementId != null)
	         {
	            global::System.Guid valueOfDescribedAssociationElementId;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Guid>(serializationContext, attribDescribedAssociationElementId, out valueOfDescribedAssociationElementId))
	            {
	               // Non-public setter, use DomainPropertyInfo method.
	               DslModeling::DomainPropertyInfo propInfo = instanceOfModelClass.Partition.DomainDataDirectory.GetDomainProperty (ModelClass.DescribedAssociationElementIdDomainPropertyId);
	               global::System.Diagnostics.Debug.Assert (propInfo != null, "Cannot get DomainPropertyInfo for ModelClass.DescribedAssociationElementId!");
	               propInfo.SetValue(instanceOfModelClass, valueOfDescribedAssociationElementId);
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "describedAssociationElementId", typeof(global::System.Guid), attribDescribedAssociationElementId);
	            }
	         }
	      }
	      // TableComment
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTableComment = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "tableComment");
	         if (attribTableComment != null)
	         {
	            global::System.String valueOfTableComment;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTableComment, out valueOfTableComment))
	            {
	               instanceOfModelClass.TableComment = valueOfTableComment;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "tableComment", typeof(global::System.String), attribTableComment);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	      ModelClass instanceOfModelClass = element as ModelClass;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass!");
	
	      // Read child model elements (which are always serialized as nested XML elements).
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	         ReadChildElements(serializationContext, instanceOfModelClass, reader);
	   }
	
	   /// <summary>
	   /// This method deserializes all child model elements.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first child XML element to deserialized.
	   /// This method will read as many child elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
	   ///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
	   ///    should return immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
	   private static void ReadChildElements(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         switch (reader.LocalName)
	         {
	            case "unidirectionalTargets":   // Relationship "UnidirectionalAssociation"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <unidirectionalTargets>
	                  ReadUnidirectionalAssociationInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </unidirectionalTargets>
	               }
	               break;
	            case "attributes":   // Relationship "ClassHasAttributes"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <attributes>
	                  ReadClassHasAttributesInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </attributes>
	               }
	               break;
	            case "subclasses":   // Relationship "Generalization"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <subclasses>
	                  ReadGeneralizationInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </subclasses>
	               }
	               break;
	            case "bidirectionalTargets":   // Relationship "BidirectionalAssociation"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <bidirectionalTargets>
	                  ReadBidirectionalAssociationInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </bidirectionalTargets>
	               }
	               break;
	            default:
			         return;  // Don't know this element.
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship UnidirectionalAssociation.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
	   private static void ReadUnidirectionalAssociationInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newUnidirectionalAssociationSerializer = serializationContext.Directory.GetSerializer(UnidirectionalAssociation.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newUnidirectionalAssociationSerializer != null, "Cannot find serializer for UnidirectionalAssociation!");
	         UnidirectionalAssociation newUnidirectionalAssociation = newUnidirectionalAssociationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as UnidirectionalAssociation;
	         if (newUnidirectionalAssociation != null)
	         {
	            DslModeling::DomainRoleInfo.SetRolePlayer (newUnidirectionalAssociation, UnidirectionalAssociation.UnidirectionalSourceDomainRoleId, element);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newUnidirectionalAssociation.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newUnidirectionalAssociation.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newUnidirectionalAssociation, reader);
	         }
	         else
	         {   // Maybe the relationship is serialized in short-form by mistake.
	            DslModeling::DomainClassXmlSerializer newModelClassMonikerOfUnidirectionalAssociationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
	            global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfUnidirectionalAssociationSerializer != null, "Cannot find serializer for ModelClass!");
	            DslModeling::Moniker newModelClassMonikerOfUnidirectionalAssociation = newModelClassMonikerOfUnidirectionalAssociationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, UnidirectionalAssociation.DomainClassId, element.Partition);
	            if (newModelClassMonikerOfUnidirectionalAssociation != null)
	            {
	               EFModelSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(UnidirectionalAssociation));
	               new UnidirectionalAssociation(element.Partition, new DslModeling::RoleAssignment(UnidirectionalAssociation.UnidirectionalSourceDomainRoleId, element), new DslModeling::RoleAssignment(UnidirectionalAssociation.UnidirectionalTargetDomainRoleId, newModelClassMonikerOfUnidirectionalAssociation));
	               DslModeling::SerializationUtilities.Skip(reader);   // Moniker contains no child XML elements, so just skip.
	            }
	            else
	            {   // Unknown element, skip.
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship ClassHasAttributes.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   private static void ReadClassHasAttributesInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newModelAttributeOfClassHasAttributesSerializer = serializationContext.Directory.GetSerializer(ModelAttribute.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newModelAttributeOfClassHasAttributesSerializer != null, "Cannot find serializer for ModelAttribute!");
	         ModelAttribute newModelAttributeOfClassHasAttributes = newModelAttributeOfClassHasAttributesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelAttribute;
	         if (newModelAttributeOfClassHasAttributes != null)
	         {
	            element.Attributes.Add(newModelAttributeOfClassHasAttributes);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelAttributeOfClassHasAttributes.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelAttributeOfClassHasAttributes.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newModelAttributeOfClassHasAttributes, reader);
	         }
	         else
	         {
	            global::System.Type typeofClassHasAttributes = typeof(ClassHasAttributes);
	            DslModeling::DomainRelationshipXmlSerializer newClassHasAttributesSerializer = serializationContext.Directory.GetSerializer(ClassHasAttributes.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
	            global::System.Diagnostics.Debug.Assert(newClassHasAttributesSerializer != null, "Cannot find serializer for ClassHasAttributes!");
	            ClassHasAttributes newClassHasAttributes = newClassHasAttributesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ClassHasAttributes;
	            if (newClassHasAttributes != null)
	            {
	               if (newClassHasAttributes.GetType() == typeofClassHasAttributes)
	               {   // The relationship should be serialized in short-form.
	                  EFModelSerializationBehaviorSerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(ClassHasAttributes));
	               }
	               DslModeling::DomainRoleInfo.SetRolePlayer (newClassHasAttributes, ClassHasAttributes.ModelClassDomainRoleId, element);
	               DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newClassHasAttributes.GetDomainClass().Id);
	               global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newClassHasAttributes.GetDomainClass().Name + "!");
	               targetSerializer.Read(serializationContext, newClassHasAttributes, reader);
	            }
	            else
	            {   // Unknown element, skip
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship Generalization.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
	   private static void ReadGeneralizationInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newGeneralizationSerializer = serializationContext.Directory.GetSerializer(Generalization.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newGeneralizationSerializer != null, "Cannot find serializer for Generalization!");
	         Generalization newGeneralization = newGeneralizationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as Generalization;
	         if (newGeneralization != null)
	         {
	            DslModeling::DomainRoleInfo.SetRolePlayer (newGeneralization, Generalization.SuperclassDomainRoleId, element);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newGeneralization.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newGeneralization.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newGeneralization, reader);
	         }
	         else
	         {   // Maybe the relationship is serialized in short-form by mistake.
	            DslModeling::DomainClassXmlSerializer newModelClassMonikerOfGeneralizationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
	            global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfGeneralizationSerializer != null, "Cannot find serializer for ModelClass!");
	            DslModeling::Moniker newModelClassMonikerOfGeneralization = newModelClassMonikerOfGeneralizationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, Generalization.DomainClassId, element.Partition);
	            if (newModelClassMonikerOfGeneralization != null)
	            {
	               EFModelSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(Generalization));
	               new Generalization(element.Partition, new DslModeling::RoleAssignment(Generalization.SuperclassDomainRoleId, element), new DslModeling::RoleAssignment(Generalization.SubclassDomainRoleId, newModelClassMonikerOfGeneralization));
	               DslModeling::SerializationUtilities.Skip(reader);   // Moniker contains no child XML elements, so just skip.
	            }
	            else
	            {   // Unknown element, skip.
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship BidirectionalAssociation.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelClass instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
	   private static void ReadBidirectionalAssociationInstances(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newBidirectionalAssociationSerializer = serializationContext.Directory.GetSerializer(BidirectionalAssociation.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newBidirectionalAssociationSerializer != null, "Cannot find serializer for BidirectionalAssociation!");
	         BidirectionalAssociation newBidirectionalAssociation = newBidirectionalAssociationSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as BidirectionalAssociation;
	         if (newBidirectionalAssociation != null)
	         {
	            DslModeling::DomainRoleInfo.SetRolePlayer (newBidirectionalAssociation, BidirectionalAssociation.BidirectionalSourceDomainRoleId, element);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newBidirectionalAssociation.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newBidirectionalAssociation.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newBidirectionalAssociation, reader);
	         }
	         else
	         {   // Maybe the relationship is serialized in short-form by mistake.
	            DslModeling::DomainClassXmlSerializer newModelClassMonikerOfBidirectionalAssociationSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
	            global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfBidirectionalAssociationSerializer != null, "Cannot find serializer for ModelClass!");
	            DslModeling::Moniker newModelClassMonikerOfBidirectionalAssociation = newModelClassMonikerOfBidirectionalAssociationSerializer.TryCreateMonikerInstance(serializationContext, reader, element, BidirectionalAssociation.DomainClassId, element.Partition);
	            if (newModelClassMonikerOfBidirectionalAssociation != null)
	            {
	               EFModelSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(BidirectionalAssociation));
	               new BidirectionalAssociation(element.Partition, new DslModeling::RoleAssignment(BidirectionalAssociation.BidirectionalSourceDomainRoleId, element), new DslModeling::RoleAssignment(BidirectionalAssociation.BidirectionalTargetDomainRoleId, newModelClassMonikerOfBidirectionalAssociation));
	               DslModeling::SerializationUtilities.Skip(reader);   // Moniker contains no child XML elements, so just skip.
	            }
	            else
	            {   // Unknown element, skip.
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelClass based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelClass, a new ModelClass instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelClass instance, or null if the reader is not pointing to a serialized ModelClass instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelClass" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelClass".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               ModelClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelClassSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelClass based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelClass.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelClass instance should be created.</param>
	   /// <returns>Created ModelClass instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new ModelClass(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelClass, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelClass.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelClass.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelClass itself) instance of ModelClass based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelClass" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelClass".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelClassSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelClassSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelClass based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelClass.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelClass, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelClass.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelClass.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelClass instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelClass instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelClass instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelClass instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelClass instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelClass instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelClass instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      ModelClass instanceOfModelClass = element as ModelClass;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelClass != null, "Expecting an instance of ModelClass");
	
	      // IsAbstract
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsAbstract;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isAbstract", serializedPropValue);
	            }
	         }
	      }
	      // TableName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.TableName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "tableName", propValue);
	            }
	         }
	      }
	      // DatabaseSchema
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.DatabaseSchema;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "databaseSchema", propValue);
	            }
	         }
	      }
	      // Concurrency
	      if (!serializationContext.Result.Failed)
	      {
	         ConcurrencyOverride propValue = instanceOfModelClass.Concurrency;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<ConcurrencyOverride>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "concurrency", serializedPropValue);
	            }
	         }
	      }
	      // IsDatabaseSchemaTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsDatabaseSchemaTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isDatabaseSchemaTracking", serializedPropValue);
	            }
	         }
	      }
	      // Namespace
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.Namespace;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null)
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "namespace", propValue);
	         }
	      }
	      // IsNamespaceTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsNamespaceTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isNamespaceTracking", serializedPropValue);
	            }
	         }
	      }
	      // DbSetName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.DbSetName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "dbSetName", propValue);
	
	         }
	      }
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.Name;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
	            }
	         }
	      }
	      // ImplementNotify
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.ImplementNotify;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "implementNotify", serializedPropValue);
	            }
	         }
	      }
	      // CustomInterfaces
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.CustomInterfaces;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "customInterfaces", propValue);
	
	         }
	      }
	      // IsDependentType
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsDependentType;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isDependentType", serializedPropValue);
	            }
	         }
	      }
	      // OutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.OutputDirectory;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null)
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outputDirectory", propValue);
	         }
	      }
	      // IsOutputDirectoryTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsOutputDirectoryTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isOutputDirectoryTracking", serializedPropValue);
	            }
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.Description;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "description", propValue);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.Summary;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "summary", propValue);
	
	         }
	      }
	      // CustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.CustomAttributes;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "customAttributes", propValue);
	
	         }
	      }
	      // AutoPropertyDefault
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.AutoPropertyDefault;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "autoPropertyDefault", serializedPropValue);
	            }
	         }
	      }
	      // GenerateCode
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.GenerateCode;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "generateCode", serializedPropValue);
	            }
	         }
	      }
	      // IsPropertyBag
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsPropertyBag;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isPropertyBag", serializedPropValue);
	            }
	         }
	      }
	      // IsQueryType
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsQueryType;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isQueryType", serializedPropValue);
	            }
	         }
	      }
	      // ExcludeFromMigrations
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.ExcludeFromMigrations;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "excludeFromMigrations", serializedPropValue);
	         }
	      }
	      // IsDatabaseView
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsDatabaseView;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isDatabaseView", serializedPropValue);
	            }
	         }
	      }
	      // ViewName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.ViewName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "viewName", propValue);
	
	         }
	      }
	      // DefaultConstructorVisibility
	      if (!serializationContext.Result.Failed)
	      {
	         TypeAccessModifierExt propValue = instanceOfModelClass.DefaultConstructorVisibility;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<TypeAccessModifierExt>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "defaultConstructorVisibility", serializedPropValue);
	            }
	         }
	      }
	      // IsDefaultConstructorVisibilityTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsDefaultConstructorVisibilityTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isDefaultConstructorVisibilityTracking", serializedPropValue);
	            }
	         }
	      }
	      // IsAutoPropertyDefaultTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsAutoPropertyDefaultTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isAutoPropertyDefaultTracking", serializedPropValue);
	            }
	         }
	      }
	      // UseTemporalTables
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.UseTemporalTables;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "useTemporalTables", serializedPropValue);
	         }
	      }
	      // IsAssociationClass
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelClass.IsAssociationClass;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isAssociationClass", serializedPropValue);
	         }
	      }
	      // DescribedAssociationElementId
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Guid propValue = instanceOfModelClass.DescribedAssociationElementId;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Guid>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "describedAssociationElementId", serializedPropValue);
	         }
	      }
	      // TableComment
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelClass.TableComment;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "tableComment", propValue);
	
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelClass instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	      ModelClass instance = element as ModelClass;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
	
	      // Write child model elements (which are always serialized as nested XML elements).
	      if (!serializationContext.Result.Failed)
	         WriteChildElements(serializationContext, instance, writer);
	   }
	
	
	   /// <summary>
	   /// Serialize all child model elements.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelClass instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]
	   private static void WriteChildElements(DslModeling::SerializationContext serializationContext, ModelClass element, global::System.Xml.XmlWriter writer)
	   {
	      // UnidirectionalAssociation
	      global::System.Collections.ObjectModel.ReadOnlyCollection<UnidirectionalAssociation> allUnidirectionalAssociationInstances = UnidirectionalAssociation.GetLinksToUnidirectionalTargets(element);
	      if (!serializationContext.Result.Failed && allUnidirectionalAssociationInstances.Count > 0)
	      {
	         writer.WriteStartElement("unidirectionalTargets");
	         foreach (UnidirectionalAssociation eachUnidirectionalAssociationInstance in allUnidirectionalAssociationInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachUnidirectionalAssociationInstance.GetDomainClass().Id);
		         global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachUnidirectionalAssociationInstance.GetDomainClass().Name + "!");
		         relSerializer.Write(serializationContext, eachUnidirectionalAssociationInstance, writer);
	         }
	         writer.WriteEndElement();
	      }
	
	      // ClassHasAttributes
	      global::System.Collections.ObjectModel.ReadOnlyCollection<ClassHasAttributes> allClassHasAttributesInstances = ClassHasAttributes.GetLinksToAttributes(element);
	      if (!serializationContext.Result.Failed && allClassHasAttributesInstances.Count > 0)
	      {
	         writer.WriteStartElement("attributes");
	         global::System.Type typeofClassHasAttributes = typeof(ClassHasAttributes);
	         foreach (ClassHasAttributes eachClassHasAttributesInstance in allClassHasAttributesInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         if (eachClassHasAttributesInstance.GetType() != typeofClassHasAttributes)
		         {   // Derived relationships will be serialized in full-form.
		            DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(eachClassHasAttributesInstance.GetDomainClass().Id);
		            global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + eachClassHasAttributesInstance.GetDomainClass().Name + "!");   
		            derivedRelSerializer.Write(serializationContext, eachClassHasAttributesInstance, writer);
		         }
		         else
		         {   // No need to serialize the relationship itself, just serialize the role-player directly.
			         DslModeling::ModelElement targetElement = eachClassHasAttributesInstance.Attribute;
			         DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			         global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");   
			         targetSerializer.Write(serializationContext, targetElement, writer);
		         }
	         }
	         writer.WriteEndElement();
	      }
	
	      // Generalization
	      global::System.Collections.ObjectModel.ReadOnlyCollection<Generalization> allGeneralizationInstances = Generalization.GetLinksToSubclasses(element);
	      if (!serializationContext.Result.Failed && allGeneralizationInstances.Count > 0)
	      {
	         writer.WriteStartElement("subclasses");
	         foreach (Generalization eachGeneralizationInstance in allGeneralizationInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachGeneralizationInstance.GetDomainClass().Id);
		         global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachGeneralizationInstance.GetDomainClass().Name + "!");
		         relSerializer.Write(serializationContext, eachGeneralizationInstance, writer);
	         }
	         writer.WriteEndElement();
	      }
	
	      // BidirectionalAssociation
	      global::System.Collections.ObjectModel.ReadOnlyCollection<BidirectionalAssociation> allBidirectionalAssociationInstances = BidirectionalAssociation.GetLinksToBidirectionalTargets(element);
	      if (!serializationContext.Result.Failed && allBidirectionalAssociationInstances.Count > 0)
	      {
	         writer.WriteStartElement("bidirectionalTargets");
	         foreach (BidirectionalAssociation eachBidirectionalAssociationInstance in allBidirectionalAssociationInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachBidirectionalAssociationInstance.GetDomainClass().Id);
		         global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachBidirectionalAssociationInstance.GetDomainClass().Name + "!");
		         relSerializer.Write(serializationContext, eachBidirectionalAssociationInstance, writer);
	         }
	         writer.WriteEndElement();
	      }
	
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelClass instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelClass instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelClass instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelClass instance = element as ModelClass;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelClass!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelClass instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelAttributeSerializer for DomainClass ModelAttribute.
	/// </summary>
	public partial class ModelAttributeSerializer : DslModeling::DomainClassXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelAttributeSerializer Constructor
	   /// </summary>
	   public ModelAttributeSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelAttribute.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelAttribute"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelAttribute.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelAttributeMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelAttribute in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelAttribute instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelAttribute element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelAttribute instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelAttribute instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      ModelAttribute instanceOfModelAttribute = element as ModelAttribute;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelAttribute != null, "Expecting an instance of ModelAttribute");
	
	      // Type
	      if (!serializationContext.Result.Failed)
	      {
	         string attribType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "type");
	         if (attribType != null)
	         {
	            global::System.String valueOfType;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribType, out valueOfType))
	            {
	               instanceOfModelAttribute.Type = valueOfType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "type", typeof(global::System.String), attribType);
	            }
	         }
	      }
	      // InitialValue
	      if (!serializationContext.Result.Failed)
	      {
	         string attribInitialValue = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "initialValue");
	         if (attribInitialValue != null)
	         {
	            global::System.String valueOfInitialValue;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribInitialValue, out valueOfInitialValue))
	            {
	               instanceOfModelAttribute.InitialValue = valueOfInitialValue;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "initialValue", typeof(global::System.String), attribInitialValue);
	            }
	         }
	      }
	      // IsIdentity
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsIdentity = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isIdentity");
	         if (attribIsIdentity != null)
	         {
	            global::System.Boolean valueOfIsIdentity;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsIdentity, out valueOfIsIdentity))
	            {
	               instanceOfModelAttribute.IsIdentity = valueOfIsIdentity;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isIdentity", typeof(global::System.Boolean), attribIsIdentity);
	            }
	         }
	      }
	      // Required
	      if (!serializationContext.Result.Failed)
	      {
	         string attribRequired = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "required");
	         if (attribRequired != null)
	         {
	            global::System.Boolean valueOfRequired;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribRequired, out valueOfRequired))
	            {
	               instanceOfModelAttribute.Required = valueOfRequired;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "required", typeof(global::System.Boolean), attribRequired);
	            }
	         }
	      }
	      // Persistent
	      if (!serializationContext.Result.Failed)
	      {
	         string attribPersistent = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "persistent");
	         if (attribPersistent != null)
	         {
	            global::System.Boolean valueOfPersistent;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribPersistent, out valueOfPersistent))
	            {
	               instanceOfModelAttribute.Persistent = valueOfPersistent;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "persistent", typeof(global::System.Boolean), attribPersistent);
	            }
	         }
	      }
	      // MaxLength
	      if (!serializationContext.Result.Failed)
	      {
	         string attribMaxLength = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "maxLength");
	         if (attribMaxLength != null)
	         {
	            global::System.Nullable<System.Int32> valueOfMaxLength;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Nullable<System.Int32>>(serializationContext, attribMaxLength, out valueOfMaxLength))
	            {
	               instanceOfModelAttribute.MaxLength = valueOfMaxLength;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "maxLength", typeof(global::System.Nullable<System.Int32>), attribMaxLength);
	            }
	         }
	      }
	      // Indexed
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIndexed = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "indexed");
	         if (attribIndexed != null)
	         {
	            global::System.Boolean valueOfIndexed;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIndexed, out valueOfIndexed))
	            {
	               instanceOfModelAttribute.Indexed = valueOfIndexed;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "indexed", typeof(global::System.Boolean), attribIndexed);
	            }
	         }
	      }
	      // IndexedUnique
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIndexedUnique = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "indexedUnique");
	         if (attribIndexedUnique != null)
	         {
	            global::System.Boolean valueOfIndexedUnique;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIndexedUnique, out valueOfIndexedUnique))
	            {
	               instanceOfModelAttribute.IndexedUnique = valueOfIndexedUnique;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "indexedUnique", typeof(global::System.Boolean), attribIndexedUnique);
	            }
	         }
	      }
	      // StringType
	      if (!serializationContext.Result.Failed)
	      {
	         string attribStringType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "stringType");
	         if (attribStringType != null)
	         {
	            HTML5Type valueOfStringType;
	            if (DslModeling::SerializationUtilities.TryGetValue<HTML5Type>(serializationContext, attribStringType, out valueOfStringType))
	            {
	               instanceOfModelAttribute.StringType = valueOfStringType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "stringType", typeof(HTML5Type), attribStringType);
	            }
	         }
	      }
	      // TableOverride
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTableOverride = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "tableOverride");
	         if (attribTableOverride != null)
	         {
	            global::System.String valueOfTableOverride;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTableOverride, out valueOfTableOverride))
	            {
	               instanceOfModelAttribute.TableOverride = valueOfTableOverride;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "tableOverride", typeof(global::System.String), attribTableOverride);
	            }
	         }
	      }
	      // IsConcurrencyToken
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsConcurrencyToken = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isConcurrencyToken");
	         if (attribIsConcurrencyToken != null)
	         {
	            global::System.Boolean valueOfIsConcurrencyToken;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsConcurrencyToken, out valueOfIsConcurrencyToken))
	            {
	               instanceOfModelAttribute.IsConcurrencyToken = valueOfIsConcurrencyToken;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isConcurrencyToken", typeof(global::System.Boolean), attribIsConcurrencyToken);
	            }
	         }
	      }
	      // IdentityType
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIdentityType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "identityType");
	         if (attribIdentityType != null)
	         {
	            IdentityType valueOfIdentityType;
	            if (DslModeling::SerializationUtilities.TryGetValue<IdentityType>(serializationContext, attribIdentityType, out valueOfIdentityType))
	            {
	               instanceOfModelAttribute.IdentityType = valueOfIdentityType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "identityType", typeof(IdentityType), attribIdentityType);
	            }
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDescription = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "description");
	         if (attribDescription != null)
	         {
	            global::System.String valueOfDescription;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDescription, out valueOfDescription))
	            {
	               instanceOfModelAttribute.Description = valueOfDescription;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSummary = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "summary");
	         if (attribSummary != null)
	         {
	            global::System.String valueOfSummary;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSummary, out valueOfSummary))
	            {
	               instanceOfModelAttribute.Summary = valueOfSummary;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "summary", typeof(global::System.String), attribSummary);
	            }
	         }
	      }
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         string attribName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
	         if (attribName != null)
	         {
	            global::System.String valueOfName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
	            {
	               instanceOfModelAttribute.Name = valueOfName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
	            }
	         }
	      }
	      // SetterVisibility
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSetterVisibility = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "setterVisibility");
	         if (attribSetterVisibility != null)
	         {
	            SetterAccessModifier valueOfSetterVisibility;
	            if (DslModeling::SerializationUtilities.TryGetValue<SetterAccessModifier>(serializationContext, attribSetterVisibility, out valueOfSetterVisibility))
	            {
	               instanceOfModelAttribute.SetterVisibility = valueOfSetterVisibility;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "setterVisibility", typeof(SetterAccessModifier), attribSetterVisibility);
	            }
	         }
	      }
	      // Virtual
	      if (!serializationContext.Result.Failed)
	      {
	         string attribVirtual = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "virtual");
	         if (attribVirtual != null)
	         {
	            global::System.Boolean valueOfVirtual;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribVirtual, out valueOfVirtual))
	            {
	               instanceOfModelAttribute.Virtual = valueOfVirtual;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "virtual", typeof(global::System.Boolean), attribVirtual);
	            }
	         }
	      }
	      // ReadOnly
	      if (!serializationContext.Result.Failed)
	      {
	         string attribReadOnly = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "readOnly");
	         if (attribReadOnly != null)
	         {
	            global::System.Boolean valueOfReadOnly;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribReadOnly, out valueOfReadOnly))
	            {
	               instanceOfModelAttribute.ReadOnly = valueOfReadOnly;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "readOnly", typeof(global::System.Boolean), attribReadOnly);
	            }
	         }
	      }
	      // AutoProperty
	      if (!serializationContext.Result.Failed)
	      {
	         string attribAutoProperty = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "autoProperty");
	         if (attribAutoProperty != null)
	         {
	            global::System.Boolean valueOfAutoProperty;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribAutoProperty, out valueOfAutoProperty))
	            {
	               instanceOfModelAttribute.AutoProperty = valueOfAutoProperty;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "autoProperty", typeof(global::System.Boolean), attribAutoProperty);
	            }
	         }
	      }
	      // MinLength
	      if (!serializationContext.Result.Failed)
	      {
	         string attribMinLength = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "minLength");
	         if (attribMinLength != null)
	         {
	            global::System.Int32 valueOfMinLength;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Int32>(serializationContext, attribMinLength, out valueOfMinLength))
	            {
	               instanceOfModelAttribute.MinLength = valueOfMinLength;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "minLength", typeof(global::System.Int32), attribMinLength);
	            }
	         }
	      }
	      // ColumnName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribColumnName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "columnName");
	         if (attribColumnName != null)
	         {
	            global::System.String valueOfColumnName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribColumnName, out valueOfColumnName))
	            {
	               instanceOfModelAttribute.ColumnName = valueOfColumnName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "columnName", typeof(global::System.String), attribColumnName);
	            }
	         }
	      }
	      // IsColumnNameTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsColumnNameTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isColumnNameTracking");
	         if (attribIsColumnNameTracking != null)
	         {
	            global::System.Boolean valueOfIsColumnNameTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsColumnNameTracking, out valueOfIsColumnNameTracking))
	            {
	               instanceOfModelAttribute.IsColumnNameTracking = valueOfIsColumnNameTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isColumnNameTracking", typeof(global::System.Boolean), attribIsColumnNameTracking);
	            }
	         }
	      }
	      // ColumnType
	      if (!serializationContext.Result.Failed)
	      {
	         string attribColumnType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "columnType");
	         if (attribColumnType != null)
	         {
	            global::System.String valueOfColumnType;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribColumnType, out valueOfColumnType))
	            {
	               instanceOfModelAttribute.ColumnType = valueOfColumnType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "columnType", typeof(global::System.String), attribColumnType);
	            }
	         }
	      }
	      // IsColumnTypeTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsColumnTypeTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isColumnTypeTracking");
	         if (attribIsColumnTypeTracking != null)
	         {
	            global::System.Boolean valueOfIsColumnTypeTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsColumnTypeTracking, out valueOfIsColumnTypeTracking))
	            {
	               instanceOfModelAttribute.IsColumnTypeTracking = valueOfIsColumnTypeTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isColumnTypeTracking", typeof(global::System.Boolean), attribIsColumnTypeTracking);
	            }
	         }
	      }
	      // CustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         string attribCustomAttributes = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "customAttributes");
	         if (attribCustomAttributes != null)
	         {
	            global::System.String valueOfCustomAttributes;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCustomAttributes, out valueOfCustomAttributes))
	            {
	               instanceOfModelAttribute.CustomAttributes = valueOfCustomAttributes;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customAttributes", typeof(global::System.String), attribCustomAttributes);
	            }
	         }
	      }
	      // DisplayText
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDisplayText = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "displayText");
	         if (attribDisplayText != null)
	         {
	            global::System.String valueOfDisplayText;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDisplayText, out valueOfDisplayText))
	            {
	               instanceOfModelAttribute.DisplayText = valueOfDisplayText;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "displayText", typeof(global::System.String), attribDisplayText);
	            }
	         }
	      }
	      // ImplementNotify
	      if (!serializationContext.Result.Failed)
	      {
	         string attribImplementNotify = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "implementNotify");
	         if (attribImplementNotify != null)
	         {
	            global::System.Boolean valueOfImplementNotify;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribImplementNotify, out valueOfImplementNotify))
	            {
	               instanceOfModelAttribute.ImplementNotify = valueOfImplementNotify;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "implementNotify", typeof(global::System.Boolean), attribImplementNotify);
	            }
	         }
	      }
	      // IsImplementNotifyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsImplementNotifyTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isImplementNotifyTracking");
	         if (attribIsImplementNotifyTracking != null)
	         {
	            global::System.Boolean valueOfIsImplementNotifyTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsImplementNotifyTracking, out valueOfIsImplementNotifyTracking))
	            {
	               instanceOfModelAttribute.IsImplementNotifyTracking = valueOfIsImplementNotifyTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isImplementNotifyTracking", typeof(global::System.Boolean), attribIsImplementNotifyTracking);
	            }
	         }
	      }
	      // IsAutoPropertyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsAutoPropertyTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isAutoPropertyTracking");
	         if (attribIsAutoPropertyTracking != null)
	         {
	            global::System.Boolean valueOfIsAutoPropertyTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsAutoPropertyTracking, out valueOfIsAutoPropertyTracking))
	            {
	               instanceOfModelAttribute.IsAutoPropertyTracking = valueOfIsAutoPropertyTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isAutoPropertyTracking", typeof(global::System.Boolean), attribIsAutoPropertyTracking);
	            }
	         }
	      }
	      // IsForeignKeyFor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsForeignKeyFor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isForeignKeyFor");
	         if (attribIsForeignKeyFor != null)
	         {
	            global::System.Guid valueOfIsForeignKeyFor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Guid>(serializationContext, attribIsForeignKeyFor, out valueOfIsForeignKeyFor))
	            {
	               // Non-public setter, use DomainPropertyInfo method.
	               DslModeling::DomainPropertyInfo propInfo = instanceOfModelAttribute.Partition.DomainDataDirectory.GetDomainProperty (ModelAttribute.IsForeignKeyForDomainPropertyId);
	               global::System.Diagnostics.Debug.Assert (propInfo != null, "Cannot get DomainPropertyInfo for ModelAttribute.IsForeignKeyFor!");
	               propInfo.SetValue(instanceOfModelAttribute, valueOfIsForeignKeyFor);
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isForeignKeyFor", typeof(global::System.Guid), attribIsForeignKeyFor);
	            }
	         }
	      }
	      // BackingFieldName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribBackingFieldName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "backingFieldName");
	         if (attribBackingFieldName != null)
	         {
	            global::System.String valueOfBackingFieldName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribBackingFieldName, out valueOfBackingFieldName))
	            {
	               instanceOfModelAttribute.BackingFieldName = valueOfBackingFieldName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "backingFieldName", typeof(global::System.String), attribBackingFieldName);
	            }
	         }
	      }
	      // DatabaseCollation
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDatabaseCollation = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "databaseCollation");
	         if (attribDatabaseCollation != null)
	         {
	            global::System.String valueOfDatabaseCollation;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDatabaseCollation, out valueOfDatabaseCollation))
	            {
	               instanceOfModelAttribute.DatabaseCollation = valueOfDatabaseCollation;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "databaseCollation", typeof(global::System.String), attribDatabaseCollation);
	            }
	         }
	      }
	      // IsDatabaseCollationTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsDatabaseCollationTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isDatabaseCollationTracking");
	         if (attribIsDatabaseCollationTracking != null)
	         {
	            global::System.Boolean valueOfIsDatabaseCollationTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsDatabaseCollationTracking, out valueOfIsDatabaseCollationTracking))
	            {
	               instanceOfModelAttribute.IsDatabaseCollationTracking = valueOfIsDatabaseCollationTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isDatabaseCollationTracking", typeof(global::System.Boolean), attribIsDatabaseCollationTracking);
	            }
	         }
	      }
	      // PropertyAccessMode
	      if (!serializationContext.Result.Failed)
	      {
	         string attribPropertyAccessMode = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "propertyAccessMode");
	         if (attribPropertyAccessMode != null)
	         {
	            PropertyAccessMode valueOfPropertyAccessMode;
	            if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccessMode>(serializationContext, attribPropertyAccessMode, out valueOfPropertyAccessMode))
	            {
	               instanceOfModelAttribute.PropertyAccessMode = valueOfPropertyAccessMode;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "propertyAccessMode", typeof(PropertyAccessMode), attribPropertyAccessMode);
	            }
	         }
	      }
	      // IsAbstract
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsAbstract = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isAbstract");
	         if (attribIsAbstract != null)
	         {
	            global::System.Boolean valueOfIsAbstract;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsAbstract, out valueOfIsAbstract))
	            {
	               instanceOfModelAttribute.IsAbstract = valueOfIsAbstract;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isAbstract", typeof(global::System.Boolean), attribIsAbstract);
	            }
	         }
	      }
	      // IsPropertyAccessModeTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsPropertyAccessModeTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isPropertyAccessModeTracking");
	         if (attribIsPropertyAccessModeTracking != null)
	         {
	            global::System.Boolean valueOfIsPropertyAccessModeTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsPropertyAccessModeTracking, out valueOfIsPropertyAccessModeTracking))
	            {
	               instanceOfModelAttribute.IsPropertyAccessModeTracking = valueOfIsPropertyAccessModeTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isPropertyAccessModeTracking", typeof(global::System.Boolean), attribIsPropertyAccessModeTracking);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelAttribute instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelAttribute based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelAttribute, a new ModelAttribute instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelAttribute instance, or null if the reader is not pointing to a serialized ModelAttribute instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelAttribute" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelAttribute".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               ModelAttributeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelAttributeSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelAttribute based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelAttribute.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelAttribute instance should be created.</param>
	   /// <returns>Created ModelAttribute instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new ModelAttribute(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelAttribute, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelAttribute.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelAttribute.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelAttribute itself) instance of ModelAttribute based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelAttribute" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelAttribute".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelAttributeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelAttributeSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelAttribute based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelAttribute.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelAttribute, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelAttribute.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelAttribute.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelAttribute instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelAttribute instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelAttribute instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelAttribute instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelAttribute instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelAttribute instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelAttribute instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      ModelAttribute instanceOfModelAttribute = element as ModelAttribute;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelAttribute != null, "Expecting an instance of ModelAttribute");
	
	      // Type
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.Type;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, "String") != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "type", propValue);
	            }
	         }
	      }
	      // InitialValue
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.InitialValue;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "initialValue", propValue);
	            }
	         }
	      }
	      // IsIdentity
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IsIdentity;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isIdentity", serializedPropValue);
	            }
	         }
	      }
	      // Required
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.Required;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "required", serializedPropValue);
	            }
	         }
	      }
	      // Persistent
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.Persistent;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "persistent", serializedPropValue);
	            }
	         }
	      }
	      // MaxLength
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Nullable<System.Int32> propValue = instanceOfModelAttribute.MaxLength;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Nullable<System.Int32>>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "maxLength", serializedPropValue);
	            }
	         }
	      }
	      // Indexed
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.Indexed;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "indexed", serializedPropValue);
	         }
	      }
	      // IndexedUnique
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IndexedUnique;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "indexedUnique", serializedPropValue);
	         }
	      }
	      // StringType
	      if (!serializationContext.Result.Failed)
	      {
	         HTML5Type propValue = instanceOfModelAttribute.StringType;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<HTML5Type>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "stringType", serializedPropValue);
	         }
	      }
	      // TableOverride
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.TableOverride;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "tableOverride", propValue);
	
	         }
	      }
	      // IsConcurrencyToken
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IsConcurrencyToken;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isConcurrencyToken", serializedPropValue);
	            }
	         }
	      }
	      // IdentityType
	      if (!serializationContext.Result.Failed)
	      {
	         IdentityType propValue = instanceOfModelAttribute.IdentityType;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<IdentityType>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "None") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "identityType", serializedPropValue);
	            }
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.Description;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "description", propValue);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.Summary;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "summary", propValue);
	
	         }
	      }
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.Name;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
	            }
	         }
	      }
	      // SetterVisibility
	      if (!serializationContext.Result.Failed)
	      {
	         SetterAccessModifier propValue = instanceOfModelAttribute.SetterVisibility;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<SetterAccessModifier>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Public") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "setterVisibility", serializedPropValue);
	            }
	         }
	      }
	      // Virtual
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.Virtual;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "virtual", serializedPropValue);
	            }
	         }
	      }
	      // ReadOnly
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.ReadOnly;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "readOnly", serializedPropValue);
	            }
	         }
	      }
	      // AutoProperty
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.AutoProperty;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "autoProperty", serializedPropValue);
	            }
	         }
	      }
	      // MinLength
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Int32 propValue = instanceOfModelAttribute.MinLength;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Int32>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "minLength", serializedPropValue);
	            }
	         }
	      }
	      // ColumnName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.ColumnName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null)
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "columnName", propValue);
	         }
	      }
	      // IsColumnNameTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IsColumnNameTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isColumnNameTracking", serializedPropValue);
	            }
	         }
	      }
	      // ColumnType
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.ColumnType;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null)
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "columnType", propValue);
	         }
	      }
	      // IsColumnTypeTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IsColumnTypeTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isColumnTypeTracking", serializedPropValue);
	            }
	         }
	      }
	      // CustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.CustomAttributes;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "customAttributes", propValue);
	
	         }
	      }
	      // DisplayText
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.DisplayText;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "displayText", propValue);
	
	         }
	      }
	      // ImplementNotify
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.ImplementNotify;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "implementNotify", serializedPropValue);
	            }
	         }
	      }
	      // IsImplementNotifyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IsImplementNotifyTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isImplementNotifyTracking", serializedPropValue);
	            }
	         }
	      }
	      // IsAutoPropertyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IsAutoPropertyTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isAutoPropertyTracking", serializedPropValue);
	            }
	         }
	      }
	      // IsForeignKeyFor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Guid propValue = instanceOfModelAttribute.IsForeignKeyFor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Guid>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isForeignKeyFor", serializedPropValue);
	         }
	      }
	      // BackingFieldName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.BackingFieldName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null)
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "backingFieldName", propValue);
	         }
	      }
	      // DatabaseCollation
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelAttribute.DatabaseCollation;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "databaseCollation", propValue);
	            }
	         }
	      }
	      // IsDatabaseCollationTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IsDatabaseCollationTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isDatabaseCollationTracking", serializedPropValue);
	            }
	         }
	      }
	      // PropertyAccessMode
	      if (!serializationContext.Result.Failed)
	      {
	         PropertyAccessMode propValue = instanceOfModelAttribute.PropertyAccessMode;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccessMode>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "FieldDuringConstruction") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "propertyAccessMode", serializedPropValue);
	            }
	         }
	      }
	      // IsAbstract
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IsAbstract;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isAbstract", serializedPropValue);
	            }
	         }
	      }
	      // IsPropertyAccessModeTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelAttribute.IsPropertyAccessModeTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isPropertyAccessModeTracking", serializedPropValue);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelAttribute instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelAttribute instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelAttribute instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelAttribute instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelAttribute instance = element as ModelAttribute;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelAttribute!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelAttribute instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer CommentSerializer for DomainClass Comment.
	/// </summary>
	public partial class CommentSerializer : DslModeling::DomainClassXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// CommentSerializer Constructor
	   /// </summary>
	   public CommentSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of Comment.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"comment"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of Comment.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"commentMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of Comment in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one Comment instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the Comment element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      Comment instanceOfComment = element as Comment;
	      global::System.Diagnostics.Debug.Assert(instanceOfComment != null, "Expecting an instance of Comment");
	
	      // Text
	      if (!serializationContext.Result.Failed)
	      {
	         string attribText = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "text");
	         if (attribText != null)
	         {
	            global::System.String valueOfText;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribText, out valueOfText))
	            {
	               instanceOfComment.Text = valueOfText;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "text", typeof(global::System.String), attribText);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	      Comment instanceOfComment = element as Comment;
	      global::System.Diagnostics.Debug.Assert(instanceOfComment != null, "Expecting an instance of Comment!");
	
	      // Read child model elements (which are always serialized as nested XML elements).
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	         ReadChildElements(serializationContext, instanceOfComment, reader);
	   }
	
	   /// <summary>
	   /// This method deserializes all child model elements.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first child XML element to deserialized.
	   /// This method will read as many child elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
	   ///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
	   ///    should return immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
	   private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Comment element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         switch (reader.LocalName)
	         {
	            case "classes":   // Relationship "CommentReferencesClasses"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <classes>
	                  ReadCommentReferencesClassesInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </classes>
	               }
	               break;
	            case "enums":   // Relationship "CommentReferencesEnums"
	               if (reader.IsEmptyElement)
	               {   // No instance of this relationship, just skip
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	               else
	               {
	                  DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <enums>
	                  ReadCommentReferencesEnumsInstances(serializationContext, element, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </enums>
	               }
	               break;
	            default:
			         return;  // Don't know this element.
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship CommentReferencesClasses.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
	   private static void ReadCommentReferencesClassesInstances(DslModeling::SerializationContext serializationContext, Comment element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newCommentReferencesClassesSerializer = serializationContext.Directory.GetSerializer(CommentReferencesClasses.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newCommentReferencesClassesSerializer != null, "Cannot find serializer for CommentReferencesClasses!");
	         CommentReferencesClasses newCommentReferencesClasses = newCommentReferencesClassesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as CommentReferencesClasses;
	         if (newCommentReferencesClasses != null)
	         {
	            DslModeling::DomainRoleInfo.SetRolePlayer (newCommentReferencesClasses, CommentReferencesClasses.CommentDomainRoleId, element);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newCommentReferencesClasses.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newCommentReferencesClasses.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newCommentReferencesClasses, reader);
	         }
	         else
	         {   // Maybe the relationship is serialized in short-form by mistake.
	            DslModeling::DomainClassXmlSerializer newModelClassMonikerOfCommentReferencesClassesSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
	            global::System.Diagnostics.Debug.Assert(newModelClassMonikerOfCommentReferencesClassesSerializer != null, "Cannot find serializer for ModelClass!");
	            DslModeling::Moniker newModelClassMonikerOfCommentReferencesClasses = newModelClassMonikerOfCommentReferencesClassesSerializer.TryCreateMonikerInstance(serializationContext, reader, element, CommentReferencesClasses.DomainClassId, element.Partition);
	            if (newModelClassMonikerOfCommentReferencesClasses != null)
	            {
	               EFModelSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(CommentReferencesClasses));
	               new CommentReferencesClasses(element.Partition, new DslModeling::RoleAssignment(CommentReferencesClasses.CommentDomainRoleId, element), new DslModeling::RoleAssignment(CommentReferencesClasses.ModelClassDomainRoleId, newModelClassMonikerOfCommentReferencesClasses));
	               DslModeling::SerializationUtilities.Skip(reader);   // Moniker contains no child XML elements, so just skip.
	            }
	            else
	            {   // Unknown element, skip.
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship CommentReferencesEnums.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Comment instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
	   private static void ReadCommentReferencesEnumsInstances(DslModeling::SerializationContext serializationContext, Comment element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newCommentReferencesEnumsSerializer = serializationContext.Directory.GetSerializer(CommentReferencesEnums.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newCommentReferencesEnumsSerializer != null, "Cannot find serializer for CommentReferencesEnums!");
	         CommentReferencesEnums newCommentReferencesEnums = newCommentReferencesEnumsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as CommentReferencesEnums;
	         if (newCommentReferencesEnums != null)
	         {
	            DslModeling::DomainRoleInfo.SetRolePlayer (newCommentReferencesEnums, CommentReferencesEnums.CommentDomainRoleId, element);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newCommentReferencesEnums.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newCommentReferencesEnums.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newCommentReferencesEnums, reader);
	         }
	         else
	         {   // Maybe the relationship is serialized in short-form by mistake.
	            DslModeling::DomainClassXmlSerializer newModelEnumMonikerOfCommentReferencesEnumsSerializer = serializationContext.Directory.GetSerializer(ModelEnum.DomainClassId);
	            global::System.Diagnostics.Debug.Assert(newModelEnumMonikerOfCommentReferencesEnumsSerializer != null, "Cannot find serializer for ModelEnum!");
	            DslModeling::Moniker newModelEnumMonikerOfCommentReferencesEnums = newModelEnumMonikerOfCommentReferencesEnumsSerializer.TryCreateMonikerInstance(serializationContext, reader, element, CommentReferencesEnums.DomainClassId, element.Partition);
	            if (newModelEnumMonikerOfCommentReferencesEnums != null)
	            {
	               EFModelSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(CommentReferencesEnums));
	               new CommentReferencesEnums(element.Partition, new DslModeling::RoleAssignment(CommentReferencesEnums.CommentDomainRoleId, element), new DslModeling::RoleAssignment(CommentReferencesEnums.ModelEnumDomainRoleId, newModelEnumMonikerOfCommentReferencesEnums));
	               DslModeling::SerializationUtilities.Skip(reader);   // Moniker contains no child XML elements, so just skip.
	            }
	            else
	            {   // Unknown element, skip.
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of Comment based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized Comment, a new Comment instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created Comment instance, or null if the reader is not pointing to a serialized Comment instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "Comment" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "Comment".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               CommentSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of Comment based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of Comment.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new Comment instance should be created.</param>
	   /// <returns>Created Comment instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new Comment(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from Comment, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from Comment.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Comment.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including Comment itself) instance of Comment based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "Comment" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "Comment".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               CommentSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of Comment based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, Comment.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Comment, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Comment.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Comment.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized Comment instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Comment instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the Comment instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Comment instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one Comment instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Comment instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Comment instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      Comment instanceOfComment = element as Comment;
	      global::System.Diagnostics.Debug.Assert(instanceOfComment != null, "Expecting an instance of Comment");
	
	      // Text
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfComment.Text;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "text", propValue);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Comment instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	      Comment instance = element as Comment;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Comment!");
	
	      // Write child model elements (which are always serialized as nested XML elements).
	      if (!serializationContext.Result.Failed)
	         WriteChildElements(serializationContext, instance, writer);
	   }
	
	
	   /// <summary>
	   /// Serialize all child model elements.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Comment instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]
	   private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Comment element, global::System.Xml.XmlWriter writer)
	   {
	      // CommentReferencesClasses
	      global::System.Collections.ObjectModel.ReadOnlyCollection<CommentReferencesClasses> allCommentReferencesClassesInstances = CommentReferencesClasses.GetLinksToClasses(element);
	      if (!serializationContext.Result.Failed && allCommentReferencesClassesInstances.Count > 0)
	      {
	         writer.WriteStartElement("classes");
	         foreach (CommentReferencesClasses eachCommentReferencesClassesInstance in allCommentReferencesClassesInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachCommentReferencesClassesInstance.GetDomainClass().Id);
		         global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachCommentReferencesClassesInstance.GetDomainClass().Name + "!");
		         relSerializer.Write(serializationContext, eachCommentReferencesClassesInstance, writer);
	         }
	         writer.WriteEndElement();
	      }
	
	      // CommentReferencesEnums
	      global::System.Collections.ObjectModel.ReadOnlyCollection<CommentReferencesEnums> allCommentReferencesEnumsInstances = CommentReferencesEnums.GetLinksToEnums(element);
	      if (!serializationContext.Result.Failed && allCommentReferencesEnumsInstances.Count > 0)
	      {
	         writer.WriteStartElement("enums");
	         foreach (CommentReferencesEnums eachCommentReferencesEnumsInstance in allCommentReferencesEnumsInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachCommentReferencesEnumsInstance.GetDomainClass().Id);
		         global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachCommentReferencesEnumsInstance.GetDomainClass().Name + "!");
		         relSerializer.Write(serializationContext, eachCommentReferencesEnumsInstance, writer);
	         }
	         writer.WriteEndElement();
	      }
	
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Comment instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Comment instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Comment instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Comment instance = element as Comment;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Comment!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Comment instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelEnumSerializer for DomainClass ModelEnum.
	/// </summary>
	public partial class ModelEnumSerializer : DesignElementSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelEnumSerializer Constructor
	   /// </summary>
	   public ModelEnumSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelEnum.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelEnum"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelEnum.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelEnumMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelEnum in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelEnum instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelEnum element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnum instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnum instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      ModelEnum instanceOfModelEnum = element as ModelEnum;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelEnum != null, "Expecting an instance of ModelEnum");
	
	      // ValueType
	      if (!serializationContext.Result.Failed)
	      {
	         string attribValueType = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "valueType");
	         if (attribValueType != null)
	         {
	            EnumValueType valueOfValueType;
	            if (DslModeling::SerializationUtilities.TryGetValue<EnumValueType>(serializationContext, attribValueType, out valueOfValueType))
	            {
	               instanceOfModelEnum.ValueType = valueOfValueType;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "valueType", typeof(EnumValueType), attribValueType);
	            }
	         }
	      }
	      // Namespace
	      if (!serializationContext.Result.Failed)
	      {
	         string attribNamespace = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "namespace");
	         if (attribNamespace != null)
	         {
	            global::System.String valueOfNamespace;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribNamespace, out valueOfNamespace))
	            {
	               instanceOfModelEnum.Namespace = valueOfNamespace;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "namespace", typeof(global::System.String), attribNamespace);
	            }
	         }
	      }
	      // IsNamespaceTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsNamespaceTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isNamespaceTracking");
	         if (attribIsNamespaceTracking != null)
	         {
	            global::System.Boolean valueOfIsNamespaceTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsNamespaceTracking, out valueOfIsNamespaceTracking))
	            {
	               instanceOfModelEnum.IsNamespaceTracking = valueOfIsNamespaceTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isNamespaceTracking", typeof(global::System.Boolean), attribIsNamespaceTracking);
	            }
	         }
	      }
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         string attribName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
	         if (attribName != null)
	         {
	            global::System.String valueOfName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
	            {
	               instanceOfModelEnum.Name = valueOfName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
	            }
	         }
	      }
	      // IsFlags
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsFlags = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isFlags");
	         if (attribIsFlags != null)
	         {
	            global::System.Boolean valueOfIsFlags;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsFlags, out valueOfIsFlags))
	            {
	               instanceOfModelEnum.IsFlags = valueOfIsFlags;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isFlags", typeof(global::System.Boolean), attribIsFlags);
	            }
	         }
	      }
	      // OutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutputDirectory = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outputDirectory");
	         if (attribOutputDirectory != null)
	         {
	            global::System.String valueOfOutputDirectory;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribOutputDirectory, out valueOfOutputDirectory))
	            {
	               instanceOfModelEnum.OutputDirectory = valueOfOutputDirectory;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outputDirectory", typeof(global::System.String), attribOutputDirectory);
	            }
	         }
	      }
	      // IsOutputDirectoryTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsOutputDirectoryTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isOutputDirectoryTracking");
	         if (attribIsOutputDirectoryTracking != null)
	         {
	            global::System.Boolean valueOfIsOutputDirectoryTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsOutputDirectoryTracking, out valueOfIsOutputDirectoryTracking))
	            {
	               instanceOfModelEnum.IsOutputDirectoryTracking = valueOfIsOutputDirectoryTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isOutputDirectoryTracking", typeof(global::System.Boolean), attribIsOutputDirectoryTracking);
	            }
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDescription = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "description");
	         if (attribDescription != null)
	         {
	            global::System.String valueOfDescription;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDescription, out valueOfDescription))
	            {
	               instanceOfModelEnum.Description = valueOfDescription;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSummary = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "summary");
	         if (attribSummary != null)
	         {
	            global::System.String valueOfSummary;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSummary, out valueOfSummary))
	            {
	               instanceOfModelEnum.Summary = valueOfSummary;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "summary", typeof(global::System.String), attribSummary);
	            }
	         }
	      }
	      // CustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         string attribCustomAttributes = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "customAttributes");
	         if (attribCustomAttributes != null)
	         {
	            global::System.String valueOfCustomAttributes;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCustomAttributes, out valueOfCustomAttributes))
	            {
	               instanceOfModelEnum.CustomAttributes = valueOfCustomAttributes;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customAttributes", typeof(global::System.String), attribCustomAttributes);
	            }
	         }
	      }
	      // GenerateCode
	      if (!serializationContext.Result.Failed)
	      {
	         string attribGenerateCode = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "generateCode");
	         if (attribGenerateCode != null)
	         {
	            global::System.Boolean valueOfGenerateCode;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribGenerateCode, out valueOfGenerateCode))
	            {
	               instanceOfModelEnum.GenerateCode = valueOfGenerateCode;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "generateCode", typeof(global::System.Boolean), attribGenerateCode);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnum instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	      ModelEnum instanceOfModelEnum = element as ModelEnum;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelEnum != null, "Expecting an instance of ModelEnum!");
	
	      // Read child model elements (which are always serialized as nested XML elements).
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	         ReadChildElements(serializationContext, instanceOfModelEnum, reader);
	   }
	
	   /// <summary>
	   /// This method deserializes all child model elements.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first child XML element to deserialized.
	   /// This method will read as many child elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
	   ///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
	   ///    should return immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="element">In-memory ModelEnum instance that will get the deserialized data.</param>
	   private static void ReadChildElements(DslModeling::SerializationContext serializationContext, ModelEnum element, global::System.Xml.XmlReader reader)
	   {
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         if (string.Compare(reader.LocalName, "values", global::System.StringComparison.CurrentCulture) == 0)
	         {
	            if (reader.IsEmptyElement)
	            {   // No instance of this relationship, just skip
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	            else
	            {
	               DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <values>
	               ReadModelEnumHasValuesInstances(serializationContext, element, reader);
	               DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </values>
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// Reads all instances of relationship ModelEnumHasValues.
	   /// </summary>
	   /// <remarks>
	   /// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	   /// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	   /// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnum instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   private static void ReadModelEnumHasValuesInstances(DslModeling::SerializationContext serializationContext, ModelEnum element, global::System.Xml.XmlReader reader)
	   {
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         DslModeling::DomainClassXmlSerializer newModelEnumHasValuesSerializer = serializationContext.Directory.GetSerializer(ModelEnumHasValues.DomainClassId);
	         global::System.Diagnostics.Debug.Assert(newModelEnumHasValuesSerializer != null, "Cannot find serializer for ModelEnumHasValues!");
	         ModelEnumHasValues newModelEnumHasValues = newModelEnumHasValuesSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as ModelEnumHasValues;
	         if (newModelEnumHasValues != null)
	         {
	            DslModeling::DomainRoleInfo.SetRolePlayer (newModelEnumHasValues, ModelEnumHasValues.EnumDomainRoleId, element);
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelEnumHasValues.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelEnumHasValues.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, newModelEnumHasValues, reader);
	         }
	         else
	         {   // Maybe the relationship is serialized in short-form by mistake.
	            DslModeling::DomainClassXmlSerializer newModelEnumValueOfModelEnumHasValuesSerializer = serializationContext.Directory.GetSerializer(ModelEnumValue.DomainClassId);
	            global::System.Diagnostics.Debug.Assert(newModelEnumValueOfModelEnumHasValuesSerializer != null, "Cannot find serializer for ModelEnumValue!");
	            ModelEnumValue newModelEnumValueOfModelEnumHasValues = newModelEnumValueOfModelEnumHasValuesSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as ModelEnumValue;
	            if (newModelEnumValueOfModelEnumHasValues != null)
	            {
	               EFModelSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(ModelEnumHasValues));
	               element.Values.Add(newModelEnumValueOfModelEnumHasValues);
	               DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newModelEnumValueOfModelEnumHasValues.GetDomainClass().Id);
	               global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newModelEnumValueOfModelEnumHasValues.GetDomainClass().Name + "!");
	               targetSerializer.Read(serializationContext, newModelEnumValueOfModelEnumHasValues, reader);
	            }
	            else
	            {   // Unknown element, skip.
	               DslModeling::SerializationUtilities.Skip(reader);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelEnum based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelEnum, a new ModelEnum instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelEnum instance, or null if the reader is not pointing to a serialized ModelEnum instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelEnum" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelEnum".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               ModelEnumSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelEnumSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelEnum based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelEnum.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelEnum instance should be created.</param>
	   /// <returns>Created ModelEnum instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new ModelEnum(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelEnum, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelEnum.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelEnum.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelEnum itself) instance of ModelEnum based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelEnum" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelEnum".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelEnumSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelEnumSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelEnum based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelEnum.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelEnum, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelEnum.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelEnum.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelEnum instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnum instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelEnum instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelEnum instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelEnum instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnum instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnum instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      ModelEnum instanceOfModelEnum = element as ModelEnum;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelEnum != null, "Expecting an instance of ModelEnum");
	
	      // ValueType
	      if (!serializationContext.Result.Failed)
	      {
	         EnumValueType propValue = instanceOfModelEnum.ValueType;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<EnumValueType>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Int32") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "valueType", serializedPropValue);
	            }
	         }
	      }
	      // Namespace
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnum.Namespace;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null)
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "namespace", propValue);
	         }
	      }
	      // IsNamespaceTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelEnum.IsNamespaceTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isNamespaceTracking", serializedPropValue);
	            }
	         }
	      }
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnum.Name;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
	            }
	         }
	      }
	      // IsFlags
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelEnum.IsFlags;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "false") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isFlags", serializedPropValue);
	            }
	         }
	      }
	      // OutputDirectory
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnum.OutputDirectory;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null)
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outputDirectory", propValue);
	         }
	      }
	      // IsOutputDirectoryTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelEnum.IsOutputDirectoryTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isOutputDirectoryTracking", serializedPropValue);
	            }
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnum.Description;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "description", propValue);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnum.Summary;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "summary", propValue);
	
	         }
	      }
	      // CustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnum.CustomAttributes;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "customAttributes", propValue);
	
	         }
	      }
	      // GenerateCode
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfModelEnum.GenerateCode;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "generateCode", serializedPropValue);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnum instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	      ModelEnum instance = element as ModelEnum;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelEnum!");
	
	      // Write child model elements (which are always serialized as nested XML elements).
	      if (!serializationContext.Result.Failed)
	         WriteChildElements(serializationContext, instance, writer);
	   }
	
	
	   /// <summary>
	   /// Serialize all child model elements.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnum instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]
	   private static void WriteChildElements(DslModeling::SerializationContext serializationContext, ModelEnum element, global::System.Xml.XmlWriter writer)
	   {
	      // ModelEnumHasValues
	      global::System.Collections.ObjectModel.ReadOnlyCollection<ModelEnumHasValues> allModelEnumHasValuesInstances = ModelEnumHasValues.GetLinksToValues(element);
	      if (!serializationContext.Result.Failed && allModelEnumHasValuesInstances.Count > 0)
	      {
	         writer.WriteStartElement("values");
	         foreach (ModelEnumHasValues eachModelEnumHasValuesInstance in allModelEnumHasValuesInstances)
	         {
	            if (serializationContext.Result.Failed)
	               break;
	
		         DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachModelEnumHasValuesInstance.GetDomainClass().Id);
		         global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachModelEnumHasValuesInstance.GetDomainClass().Name + "!");
		         relSerializer.Write(serializationContext, eachModelEnumHasValuesInstance, writer);
	         }
	         writer.WriteEndElement();
	      }
	
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelEnum instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelEnum instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelEnum instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelEnum instance = element as ModelEnum;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelEnum!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelEnum instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelEnumValueSerializer for DomainClass ModelEnumValue.
	/// </summary>
	public partial class ModelEnumValueSerializer : DslModeling::DomainClassXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelEnumValueSerializer Constructor
	   /// </summary>
	   public ModelEnumValueSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelEnumValue.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelEnumValue"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelEnumValue.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelEnumValueMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelEnumValue in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelEnumValue instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelEnumValue element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnumValue instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnumValue instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      ModelEnumValue instanceOfModelEnumValue = element as ModelEnumValue;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelEnumValue != null, "Expecting an instance of ModelEnumValue");
	
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         string attribName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
	         if (attribName != null)
	         {
	            global::System.String valueOfName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
	            {
	               instanceOfModelEnumValue.Name = valueOfName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
	            }
	         }
	      }
	      // Value
	      if (!serializationContext.Result.Failed)
	      {
	         string attribValue = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "value");
	         if (attribValue != null)
	         {
	            global::System.String valueOfValue;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribValue, out valueOfValue))
	            {
	               instanceOfModelEnumValue.Value = valueOfValue;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "value", typeof(global::System.String), attribValue);
	            }
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDescription = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "description");
	         if (attribDescription != null)
	         {
	            global::System.String valueOfDescription;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDescription, out valueOfDescription))
	            {
	               instanceOfModelEnumValue.Description = valueOfDescription;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSummary = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "summary");
	         if (attribSummary != null)
	         {
	            global::System.String valueOfSummary;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSummary, out valueOfSummary))
	            {
	               instanceOfModelEnumValue.Summary = valueOfSummary;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "summary", typeof(global::System.String), attribSummary);
	            }
	         }
	      }
	      // CustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         string attribCustomAttributes = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "customAttributes");
	         if (attribCustomAttributes != null)
	         {
	            global::System.String valueOfCustomAttributes;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCustomAttributes, out valueOfCustomAttributes))
	            {
	               instanceOfModelEnumValue.CustomAttributes = valueOfCustomAttributes;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "customAttributes", typeof(global::System.String), attribCustomAttributes);
	            }
	         }
	      }
	      // DisplayText
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDisplayText = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "displayText");
	         if (attribDisplayText != null)
	         {
	            global::System.String valueOfDisplayText;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDisplayText, out valueOfDisplayText))
	            {
	               instanceOfModelEnumValue.DisplayText = valueOfDisplayText;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "displayText", typeof(global::System.String), attribDisplayText);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnumValue instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelEnumValue based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelEnumValue, a new ModelEnumValue instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelEnumValue instance, or null if the reader is not pointing to a serialized ModelEnumValue instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelEnumValue" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelEnumValue".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               ModelEnumValueSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelEnumValueSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelEnumValue based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelEnumValue.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelEnumValue instance should be created.</param>
	   /// <returns>Created ModelEnumValue instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new ModelEnumValue(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelEnumValue, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelEnumValue.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelEnumValue.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelEnumValue itself) instance of ModelEnumValue based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelEnumValue" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelEnumValue".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelEnumValueSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelEnumValueSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelEnumValue based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelEnumValue.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelEnumValue, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelEnumValue.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelEnumValue.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelEnumValue instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnumValue instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelEnumValue instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelEnumValue instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelEnumValue instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnumValue instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnumValue instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      ModelEnumValue instanceOfModelEnumValue = element as ModelEnumValue;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelEnumValue != null, "Expecting an instance of ModelEnumValue");
	
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnumValue.Name;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
	            }
	         }
	      }
	      // Value
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnumValue.Value;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "value", propValue);
	
	         }
	      }
	      // Description
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnumValue.Description;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "description", propValue);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnumValue.Summary;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "summary", propValue);
	
	         }
	      }
	      // CustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnumValue.CustomAttributes;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "customAttributes", propValue);
	
	         }
	      }
	      // DisplayText
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelEnumValue.DisplayText;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "displayText", propValue);
	
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnumValue instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelEnumValue instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelEnumValue instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelEnumValue instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelEnumValue instance = element as ModelEnumValue;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelEnumValue!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelEnumValue instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer DesignElementSerializer for DomainClass DesignElement.
	/// </summary>
	public partial class DesignElementSerializer : DslModeling::DomainClassXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// DesignElementSerializer Constructor
	   /// </summary>
	   public DesignElementSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// Cannot be serialized.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// DesignElement is abstract and cannot be instantiated, so this method throws NotSupportedException.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the DesignElement element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory DesignElement instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory DesignElement instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // There is no property to read; do nothing
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of DesignElement based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized DesignElement, a new DesignElement instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created DesignElement instance, or null if the reader is not pointing to a serialized DesignElement instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         // Check for derived classes of "DesignElement".
	         if (this.derivedClasses == null)
	            this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	         global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	         DslModeling::DomainClassInfo derivedClass = null;
	         if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	         {   // New derived class instance.
	            DesignElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DesignElementSerializer;
	            global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	            result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of DesignElement based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of DesignElement.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new DesignElement instance should be created.</param>
	   /// <returns>Created DesignElement instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      // Abstract class, cannot be serialized.
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from DesignElement, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from DesignElement.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DesignElement.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including DesignElement itself) instance of DesignElement based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         // Check for derived classes of "DesignElement".
	         if (this.derivedClassMonikers == null)
	            this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	         global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	         DslModeling::DomainClassInfo derivedClass = null;
	         if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	         {   // New derived class moniker instance.
	            DesignElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as DesignElementSerializer;
	            global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	            result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of DesignElement based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, DesignElement.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from DesignElement, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from DesignElement.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(DesignElement.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized DesignElement instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">DesignElement instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the DesignElement instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the DesignElement instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      // Instance of DesignElement cannot be monikerized.
	      EFModelSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "DesignElement");
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one DesignElement instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">DesignElement instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">DesignElement instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // There are no properties; do nothing
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given DesignElement instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DesignElement instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the DesignElement instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			DesignElement instance = element as DesignElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of DesignElement!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">DesignElement instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelDiagramDataSerializer for DomainClass ModelDiagramData.
	/// </summary>
	public partial class ModelDiagramDataSerializer : DslModeling::DomainClassXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelDiagramDataSerializer Constructor
	   /// </summary>
	   public ModelDiagramDataSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelDiagramData.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelDiagramData"; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelDiagramData instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelDiagramData element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelDiagramData instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelDiagramData instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      ModelDiagramData instanceOfModelDiagramData = element as ModelDiagramData;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelDiagramData != null, "Expecting an instance of ModelDiagramData");
	
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         string attribName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
	         if (attribName != null)
	         {
	            global::System.String valueOfName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
	            {
	               instanceOfModelDiagramData.Name = valueOfName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelDiagramData instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelDiagramData based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelDiagramData, a new ModelDiagramData instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelDiagramData instance, or null if the reader is not pointing to a serialized ModelDiagramData instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelDiagramData" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelDiagramData".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               ModelDiagramDataSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelDiagramDataSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelDiagramData based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelDiagramData.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelDiagramData instance should be created.</param>
	   /// <returns>Created ModelDiagramData instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      return new ModelDiagramData(partition);
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelDiagramData, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelDiagramData.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelDiagramData.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelDiagramData itself) instance of ModelDiagramData based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelDiagramData" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelDiagramData".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelDiagramDataSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelDiagramDataSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelDiagramData based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      // Cannot be monikerized.
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelDiagramData, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelDiagramData.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelDiagramData.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelDiagramData instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelDiagramData instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelDiagramData instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelDiagramData instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      // Instance of ModelDiagramData cannot be monikerized.
	      EFModelSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "ModelDiagramData");
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelDiagramData instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelDiagramData instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelDiagramData instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      ModelDiagramData instanceOfModelDiagramData = element as ModelDiagramData;
	      global::System.Diagnostics.Debug.Assert(instanceOfModelDiagramData != null, "Expecting an instance of ModelDiagramData");
	
	      // Name
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfModelDiagramData.Name;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
	
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelDiagramData instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelDiagramData instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelDiagramData instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelDiagramData instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelDiagramData instance = element as ModelDiagramData;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelDiagramData!");
	
			DslModeling::ModelElement container = instance.ModelRoot;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.CalculateQualifiedName(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelDiagramData instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelDiagramData instance = element as ModelDiagramData;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelDiagramData!");
			DslModeling::ModelElement container = instance.ModelRoot;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer AssociationSerializer for DomainClass Association.
	/// </summary>
	public partial class AssociationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// AssociationSerializer Constructor
	   /// </summary>
	   public AssociationSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// Cannot be serialized.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Association is abstract and cannot be instantiated, so this method throws NotSupportedException.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the Association element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Association instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// This method reads the target role player Target.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Association instance that will link to the target ModelClass instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the monikerized instance of target role-player Target
	      DslModeling::Moniker targetRoleMoniker = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((Association)element).Source, Association.DomainClassId, element.Partition);
	         if (targetRoleMoniker != null)
	         {
	            // Attach the target role-player moniker.
	            DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, Association.TargetDomainRoleId, targetRoleMoniker);
	            // Moniker tag has no child XML elements in it, so just skip to the next element.
	            DslModeling::SerializationUtilities.Skip(reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRoleMoniker == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "Association");
	      }
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Association instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      Association instanceOfAssociation = element as Association;
	      global::System.Diagnostics.Debug.Assert(instanceOfAssociation != null, "Expecting an instance of Association");
	
	      // SourceMultiplicity
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceMultiplicity = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceMultiplicity");
	         if (attribSourceMultiplicity != null)
	         {
	            Multiplicity valueOfSourceMultiplicity;
	            if (DslModeling::SerializationUtilities.TryGetValue<Multiplicity>(serializationContext, attribSourceMultiplicity, out valueOfSourceMultiplicity))
	            {
	               instanceOfAssociation.SourceMultiplicity = valueOfSourceMultiplicity;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceMultiplicity", typeof(Multiplicity), attribSourceMultiplicity);
	            }
	         }
	      }
	      // TargetMultiplicity
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetMultiplicity = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetMultiplicity");
	         if (attribTargetMultiplicity != null)
	         {
	            Multiplicity valueOfTargetMultiplicity;
	            if (DslModeling::SerializationUtilities.TryGetValue<Multiplicity>(serializationContext, attribTargetMultiplicity, out valueOfTargetMultiplicity))
	            {
	               instanceOfAssociation.TargetMultiplicity = valueOfTargetMultiplicity;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetMultiplicity", typeof(Multiplicity), attribTargetMultiplicity);
	            }
	         }
	      }
	      // TargetPropertyName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetPropertyName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetPropertyName");
	         if (attribTargetPropertyName != null)
	         {
	            global::System.String valueOfTargetPropertyName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetPropertyName, out valueOfTargetPropertyName))
	            {
	               instanceOfAssociation.TargetPropertyName = valueOfTargetPropertyName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyName", typeof(global::System.String), attribTargetPropertyName);
	            }
	         }
	      }
	      // Persistent
	      if (!serializationContext.Result.Failed)
	      {
	         string attribPersistent = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "persistent");
	         if (attribPersistent != null)
	         {
	            global::System.Boolean valueOfPersistent;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribPersistent, out valueOfPersistent))
	            {
	               instanceOfAssociation.Persistent = valueOfPersistent;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "persistent", typeof(global::System.Boolean), attribPersistent);
	            }
	         }
	      }
	      // SourceDeleteAction
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceDeleteAction = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceDeleteAction");
	         if (attribSourceDeleteAction != null)
	         {
	            DeleteAction valueOfSourceDeleteAction;
	            if (DslModeling::SerializationUtilities.TryGetValue<DeleteAction>(serializationContext, attribSourceDeleteAction, out valueOfSourceDeleteAction))
	            {
	               instanceOfAssociation.SourceDeleteAction = valueOfSourceDeleteAction;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceDeleteAction", typeof(DeleteAction), attribSourceDeleteAction);
	            }
	         }
	      }
	      // TargetDeleteAction
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetDeleteAction = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetDeleteAction");
	         if (attribTargetDeleteAction != null)
	         {
	            DeleteAction valueOfTargetDeleteAction;
	            if (DslModeling::SerializationUtilities.TryGetValue<DeleteAction>(serializationContext, attribTargetDeleteAction, out valueOfTargetDeleteAction))
	            {
	               instanceOfAssociation.TargetDeleteAction = valueOfTargetDeleteAction;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetDeleteAction", typeof(DeleteAction), attribTargetDeleteAction);
	            }
	         }
	      }
	      // CollectionClass
	      if (!serializationContext.Result.Failed)
	      {
	         string attribCollectionClass = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "collectionClass");
	         if (attribCollectionClass != null)
	         {
	            global::System.String valueOfCollectionClass;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribCollectionClass, out valueOfCollectionClass))
	            {
	               instanceOfAssociation.CollectionClass = valueOfCollectionClass;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "collectionClass", typeof(global::System.String), attribCollectionClass);
	            }
	         }
	      }
	      // TargetDescription
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetDescription = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetDescription");
	         if (attribTargetDescription != null)
	         {
	            global::System.String valueOfTargetDescription;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetDescription, out valueOfTargetDescription))
	            {
	               instanceOfAssociation.TargetDescription = valueOfTargetDescription;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetDescription", typeof(global::System.String), attribTargetDescription);
	            }
	         }
	      }
	      // TargetSummary
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetSummary = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetSummary");
	         if (attribTargetSummary != null)
	         {
	            global::System.String valueOfTargetSummary;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetSummary, out valueOfTargetSummary))
	            {
	               instanceOfAssociation.TargetSummary = valueOfTargetSummary;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetSummary", typeof(global::System.String), attribTargetSummary);
	            }
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSummary = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "summary");
	         if (attribSummary != null)
	         {
	            global::System.String valueOfSummary;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSummary, out valueOfSummary))
	            {
	               instanceOfAssociation.Summary = valueOfSummary;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "summary", typeof(global::System.String), attribSummary);
	            }
	         }
	      }
	      // IsCollectionClassTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsCollectionClassTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isCollectionClassTracking");
	         if (attribIsCollectionClassTracking != null)
	         {
	            global::System.Boolean valueOfIsCollectionClassTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsCollectionClassTracking, out valueOfIsCollectionClassTracking))
	            {
	               instanceOfAssociation.IsCollectionClassTracking = valueOfIsCollectionClassTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isCollectionClassTracking", typeof(global::System.Boolean), attribIsCollectionClassTracking);
	            }
	         }
	      }
	      // SourceRole
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceRole = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceRole");
	         if (attribSourceRole != null)
	         {
	            EndpointRole valueOfSourceRole;
	            if (DslModeling::SerializationUtilities.TryGetValue<EndpointRole>(serializationContext, attribSourceRole, out valueOfSourceRole))
	            {
	               instanceOfAssociation.SourceRole = valueOfSourceRole;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceRole", typeof(EndpointRole), attribSourceRole);
	            }
	         }
	      }
	      // TargetRole
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetRole = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetRole");
	         if (attribTargetRole != null)
	         {
	            EndpointRole valueOfTargetRole;
	            if (DslModeling::SerializationUtilities.TryGetValue<EndpointRole>(serializationContext, attribTargetRole, out valueOfTargetRole))
	            {
	               instanceOfAssociation.TargetRole = valueOfTargetRole;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetRole", typeof(EndpointRole), attribTargetRole);
	            }
	         }
	      }
	      // ForeignKeyLocation
	      if (!serializationContext.Result.Failed)
	      {
	         string attribForeignKeyLocation = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "foreignKeyLocation");
	         if (attribForeignKeyLocation != null)
	         {
	            ForeignKeyOwner valueOfForeignKeyLocation;
	            if (DslModeling::SerializationUtilities.TryGetValue<ForeignKeyOwner>(serializationContext, attribForeignKeyLocation, out valueOfForeignKeyLocation))
	            {
	               // Non-public setter, use DomainPropertyInfo method.
	               DslModeling::DomainPropertyInfo propInfo = instanceOfAssociation.Partition.DomainDataDirectory.GetDomainProperty (Association.ForeignKeyLocationDomainPropertyId);
	               global::System.Diagnostics.Debug.Assert (propInfo != null, "Cannot get DomainPropertyInfo for Association.ForeignKeyLocation!");
	               propInfo.SetValue(instanceOfAssociation, valueOfForeignKeyLocation);
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "foreignKeyLocation", typeof(ForeignKeyOwner), attribForeignKeyLocation);
	            }
	         }
	      }
	      // TargetCustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetCustomAttributes = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetCustomAttributes");
	         if (attribTargetCustomAttributes != null)
	         {
	            global::System.String valueOfTargetCustomAttributes;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetCustomAttributes, out valueOfTargetCustomAttributes))
	            {
	               instanceOfAssociation.TargetCustomAttributes = valueOfTargetCustomAttributes;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetCustomAttributes", typeof(global::System.String), attribTargetCustomAttributes);
	            }
	         }
	      }
	      // TargetDisplayText
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetDisplayText = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetDisplayText");
	         if (attribTargetDisplayText != null)
	         {
	            global::System.String valueOfTargetDisplayText;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetDisplayText, out valueOfTargetDisplayText))
	            {
	               instanceOfAssociation.TargetDisplayText = valueOfTargetDisplayText;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetDisplayText", typeof(global::System.String), attribTargetDisplayText);
	            }
	         }
	      }
	      // TargetImplementNotify
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetImplementNotify = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetImplementNotify");
	         if (attribTargetImplementNotify != null)
	         {
	            global::System.Boolean valueOfTargetImplementNotify;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetImplementNotify, out valueOfTargetImplementNotify))
	            {
	               instanceOfAssociation.TargetImplementNotify = valueOfTargetImplementNotify;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetImplementNotify", typeof(global::System.Boolean), attribTargetImplementNotify);
	            }
	         }
	      }
	      // IsTargetImplementNotifyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsTargetImplementNotifyTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isTargetImplementNotifyTracking");
	         if (attribIsTargetImplementNotifyTracking != null)
	         {
	            global::System.Boolean valueOfIsTargetImplementNotifyTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsTargetImplementNotifyTracking, out valueOfIsTargetImplementNotifyTracking))
	            {
	               instanceOfAssociation.IsTargetImplementNotifyTracking = valueOfIsTargetImplementNotifyTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isTargetImplementNotifyTracking", typeof(global::System.Boolean), attribIsTargetImplementNotifyTracking);
	            }
	         }
	      }
	      // FKPropertyName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribFKPropertyName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "fKPropertyName");
	         if (attribFKPropertyName != null)
	         {
	            global::System.String valueOfFKPropertyName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribFKPropertyName, out valueOfFKPropertyName))
	            {
	               instanceOfAssociation.FKPropertyName = valueOfFKPropertyName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "fKPropertyName", typeof(global::System.String), attribFKPropertyName);
	            }
	         }
	      }
	      // JoinTableName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribJoinTableName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "joinTableName");
	         if (attribJoinTableName != null)
	         {
	            global::System.String valueOfJoinTableName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribJoinTableName, out valueOfJoinTableName))
	            {
	               instanceOfAssociation.JoinTableName = valueOfJoinTableName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "joinTableName", typeof(global::System.String), attribJoinTableName);
	            }
	         }
	      }
	      // TargetBackingFieldName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetBackingFieldName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetBackingFieldName");
	         if (attribTargetBackingFieldName != null)
	         {
	            global::System.String valueOfTargetBackingFieldName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribTargetBackingFieldName, out valueOfTargetBackingFieldName))
	            {
	               instanceOfAssociation.TargetBackingFieldName = valueOfTargetBackingFieldName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetBackingFieldName", typeof(global::System.String), attribTargetBackingFieldName);
	            }
	         }
	      }
	      // TargetPropertyAccessMode
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetPropertyAccessMode = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetPropertyAccessMode");
	         if (attribTargetPropertyAccessMode != null)
	         {
	            PropertyAccessMode valueOfTargetPropertyAccessMode;
	            if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccessMode>(serializationContext, attribTargetPropertyAccessMode, out valueOfTargetPropertyAccessMode))
	            {
	               instanceOfAssociation.TargetPropertyAccessMode = valueOfTargetPropertyAccessMode;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetPropertyAccessMode", typeof(PropertyAccessMode), attribTargetPropertyAccessMode);
	            }
	         }
	      }
	      // TargetAutoProperty
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetAutoProperty = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetAutoProperty");
	         if (attribTargetAutoProperty != null)
	         {
	            global::System.Boolean valueOfTargetAutoProperty;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetAutoProperty, out valueOfTargetAutoProperty))
	            {
	               instanceOfAssociation.TargetAutoProperty = valueOfTargetAutoProperty;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetAutoProperty", typeof(global::System.Boolean), attribTargetAutoProperty);
	            }
	         }
	      }
	      // IsTargetAutoPropertyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsTargetAutoPropertyTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isTargetAutoPropertyTracking");
	         if (attribIsTargetAutoPropertyTracking != null)
	         {
	            global::System.Boolean valueOfIsTargetAutoPropertyTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsTargetAutoPropertyTracking, out valueOfIsTargetAutoPropertyTracking))
	            {
	               instanceOfAssociation.IsTargetAutoPropertyTracking = valueOfIsTargetAutoPropertyTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isTargetAutoPropertyTracking", typeof(global::System.Boolean), attribIsTargetAutoPropertyTracking);
	            }
	         }
	      }
	      // IsTargetAbstract
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsTargetAbstract = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isTargetAbstract");
	         if (attribIsTargetAbstract != null)
	         {
	            global::System.Boolean valueOfIsTargetAbstract;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsTargetAbstract, out valueOfIsTargetAbstract))
	            {
	               instanceOfAssociation.IsTargetAbstract = valueOfIsTargetAbstract;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isTargetAbstract", typeof(global::System.Boolean), attribIsTargetAbstract);
	            }
	         }
	      }
	      // TargetAutoInclude
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTargetAutoInclude = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "targetAutoInclude");
	         if (attribTargetAutoInclude != null)
	         {
	            global::System.Boolean valueOfTargetAutoInclude;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribTargetAutoInclude, out valueOfTargetAutoInclude))
	            {
	               instanceOfAssociation.TargetAutoInclude = valueOfTargetAutoInclude;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "targetAutoInclude", typeof(global::System.Boolean), attribTargetAutoInclude);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of Association based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized Association, a new Association instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created Association instance, or null if the reader is not pointing to a serialized Association instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         // Check for derived classes of "Association".
	         if (this.derivedClasses == null)
	            this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	         global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	         DslModeling::DomainClassInfo derivedClass = null;
	         if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	         {   // New derived relationship instance.
	            AssociationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AssociationSerializer;
	            global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	            result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of Association based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of Association.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new Association instance should be created.</param>
	   /// <returns>Created Association instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      // Abstract class, cannot be serialized.
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of Association based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// Association type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from Association, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {   // Abstract relationship, so it's the same as TryCreateInstance().
	      return this.TryCreateInstance(serializationContext, reader, partition) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from Association, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from Association.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Association.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including Association itself) instance of Association based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         // Check for derived classes of "Association".
	         if (this.derivedClassMonikers == null)
	            this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	         global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	         DslModeling::DomainClassInfo derivedClass = null;
	         if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	         {   // New derived class moniker instance.
	            AssociationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AssociationSerializer;
	            global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	            result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of Association based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, Association.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Association, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Association.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Association.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized Association instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Association instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the Association instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Association instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      // Instance of Association cannot be monikerized.
	      EFModelSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "Association");
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one Association instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Association instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Association instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      Association instanceOfAssociation = element as Association;
	      global::System.Diagnostics.Debug.Assert(instanceOfAssociation != null, "Expecting an instance of Association");
	
	      // SourceMultiplicity
	      if (!serializationContext.Result.Failed)
	      {
	         Multiplicity propValue = instanceOfAssociation.SourceMultiplicity;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<Multiplicity>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "One") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceMultiplicity", serializedPropValue);
	            }
	         }
	      }
	      // TargetMultiplicity
	      if (!serializationContext.Result.Failed)
	      {
	         Multiplicity propValue = instanceOfAssociation.TargetMultiplicity;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<Multiplicity>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "ZeroMany") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetMultiplicity", serializedPropValue);
	            }
	         }
	      }
	      // TargetPropertyName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.TargetPropertyName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetPropertyName", propValue);
	            }
	         }
	      }
	      // Persistent
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfAssociation.Persistent;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "persistent", serializedPropValue);
	            }
	         }
	      }
	      // SourceDeleteAction
	      if (!serializationContext.Result.Failed)
	      {
	         DeleteAction propValue = instanceOfAssociation.SourceDeleteAction;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<DeleteAction>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceDeleteAction", serializedPropValue);
	            }
	         }
	      }
	      // TargetDeleteAction
	      if (!serializationContext.Result.Failed)
	      {
	         DeleteAction propValue = instanceOfAssociation.TargetDeleteAction;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<DeleteAction>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "Default") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetDeleteAction", serializedPropValue);
	            }
	         }
	      }
	      // CollectionClass
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.CollectionClass;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "collectionClass", propValue);
	            }
	         }
	      }
	      // TargetDescription
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.TargetDescription;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetDescription", propValue);
	            }
	         }
	      }
	      // TargetSummary
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.TargetSummary;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetSummary", propValue);
	
	         }
	      }
	      // Summary
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.Summary;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "summary", propValue);
	
	         }
	      }
	      // IsCollectionClassTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfAssociation.IsCollectionClassTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isCollectionClassTracking", serializedPropValue);
	            }
	         }
	      }
	      // SourceRole
	      if (!serializationContext.Result.Failed)
	      {
	         EndpointRole propValue = instanceOfAssociation.SourceRole;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<EndpointRole>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "NotSet") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceRole", serializedPropValue);
	            }
	         }
	      }
	      // TargetRole
	      if (!serializationContext.Result.Failed)
	      {
	         EndpointRole propValue = instanceOfAssociation.TargetRole;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<EndpointRole>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "NotSet") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetRole", serializedPropValue);
	            }
	         }
	      }
	      // ForeignKeyLocation
	      if (!serializationContext.Result.Failed)
	      {
	         ForeignKeyOwner propValue = instanceOfAssociation.ForeignKeyLocation;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<ForeignKeyOwner>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "foreignKeyLocation", serializedPropValue);
	         }
	      }
	      // TargetCustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.TargetCustomAttributes;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetCustomAttributes", propValue);
	
	         }
	      }
	      // TargetDisplayText
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.TargetDisplayText;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetDisplayText", propValue);
	
	         }
	      }
	      // TargetImplementNotify
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfAssociation.TargetImplementNotify;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetImplementNotify", serializedPropValue);
	         }
	      }
	      // IsTargetImplementNotifyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfAssociation.IsTargetImplementNotifyTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isTargetImplementNotifyTracking", serializedPropValue);
	            }
	         }
	      }
	      // FKPropertyName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.FKPropertyName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "fKPropertyName", propValue);
	
	         }
	      }
	      // JoinTableName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.JoinTableName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "joinTableName", propValue);
	            }
	         }
	      }
	      // TargetBackingFieldName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfAssociation.TargetBackingFieldName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null)
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetBackingFieldName", propValue);
	         }
	      }
	      // TargetPropertyAccessMode
	      if (!serializationContext.Result.Failed)
	      {
	         PropertyAccessMode propValue = instanceOfAssociation.TargetPropertyAccessMode;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccessMode>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "FieldDuringConstruction") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetPropertyAccessMode", serializedPropValue);
	            }
	         }
	      }
	      // TargetAutoProperty
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfAssociation.TargetAutoProperty;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetAutoProperty", serializedPropValue);
	            }
	         }
	      }
	      // IsTargetAutoPropertyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfAssociation.IsTargetAutoPropertyTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isTargetAutoPropertyTracking", serializedPropValue);
	            }
	         }
	      }
	      // IsTargetAbstract
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfAssociation.IsTargetAbstract;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isTargetAbstract", serializedPropValue);
	         }
	      }
	      // TargetAutoInclude
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfAssociation.TargetAutoInclude;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "targetAutoInclude", serializedPropValue);
	         }
	      }
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Association instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Association instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Association instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Association instance = element as Association;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Association!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Association instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, Association.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), Association.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return false;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer UnidirectionalAssociationSerializer for DomainClass UnidirectionalAssociation.
	/// </summary>
	public partial class UnidirectionalAssociationSerializer : AssociationSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// UnidirectionalAssociationSerializer Constructor
	   /// </summary>
	   public UnidirectionalAssociationSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of UnidirectionalAssociation.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"unidirectionalAssociation"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of UnidirectionalAssociation.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"unidirectionalAssociationMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of UnidirectionalAssociation in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one UnidirectionalAssociation instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the UnidirectionalAssociation element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory UnidirectionalAssociation instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the monikerized instance of target role-player UnidirectionalTarget
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player UnidirectionalTarget.
	            base.ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               base.ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "UnidirectionalAssociation");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of UnidirectionalAssociation based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized UnidirectionalAssociation, a new UnidirectionalAssociation instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created UnidirectionalAssociation instance, or null if the reader is not pointing to a serialized UnidirectionalAssociation instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of UnidirectionalAssociation based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// UnidirectionalAssociation type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from UnidirectionalAssociation, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "UnidirectionalAssociation" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "UnidirectionalAssociation".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               UnidirectionalAssociationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as UnidirectionalAssociationSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of UnidirectionalAssociation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of UnidirectionalAssociation.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new UnidirectionalAssociation instance should be created.</param>
	   /// <returns>Created UnidirectionalAssociation instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new UnidirectionalAssociation(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (UnidirectionalAssociation.UnidirectionalSourceDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (UnidirectionalAssociation.UnidirectionalTargetDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from UnidirectionalAssociation, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from UnidirectionalAssociation.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(UnidirectionalAssociation.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including UnidirectionalAssociation itself) instance of UnidirectionalAssociation based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "UnidirectionalAssociation" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "UnidirectionalAssociation".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               UnidirectionalAssociationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as UnidirectionalAssociationSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of UnidirectionalAssociation based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, UnidirectionalAssociation.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from UnidirectionalAssociation, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from UnidirectionalAssociation.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(UnidirectionalAssociation.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized UnidirectionalAssociation instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">UnidirectionalAssociation instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the UnidirectionalAssociation instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the UnidirectionalAssociation instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one UnidirectionalAssociation instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">UnidirectionalAssociation instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      // Write the target role-player instance.
	      UnidirectionalAssociation instance = element as UnidirectionalAssociation;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of UnidirectionalAssociation!");
	
	      DslModeling::ModelElement targetElement = instance.UnidirectionalTarget;
	      DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
	      global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
	      targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.UnidirectionalSource, this);
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         base.WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given UnidirectionalAssociation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">UnidirectionalAssociation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the UnidirectionalAssociation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			UnidirectionalAssociation instance = element as UnidirectionalAssociation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of UnidirectionalAssociation!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">UnidirectionalAssociation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, UnidirectionalAssociation.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), UnidirectionalAssociation.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ClassHasAttributesSerializer for DomainClass ClassHasAttributes.
	/// </summary>
	public partial class ClassHasAttributesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ClassHasAttributesSerializer Constructor
	   /// </summary>
	   public ClassHasAttributesSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ClassHasAttributes.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"classHasAttributes"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ClassHasAttributes.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"classHasAttributesMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ClassHasAttributes in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ClassHasAttributes instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ClassHasAttributes element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ClassHasAttributes instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the instance of target role-player Attribute
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player Attribute.
	            ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasAttributes");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method reads the target role player Attribute.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ClassHasAttributes instance that will link to the target ModelAttribute instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the instance of target role-player Attribute
	      DslModeling::ModelElement targetRolePlayer = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelAttribute.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelAttribute!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
	         if (targetRolePlayer != null)
	         {
	            // Attach the target role-player.
	            DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ClassHasAttributes.AttributeDomainRoleId, targetRolePlayer);
	            // Read target role-player.
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, targetRolePlayer, reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRolePlayer == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ClassHasAttributes");
	      }
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ClassHasAttributes instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // There is no property to read; do nothing
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ClassHasAttributes instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of ClassHasAttributes based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ClassHasAttributes, a new ClassHasAttributes instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ClassHasAttributes instance, or null if the reader is not pointing to a serialized ClassHasAttributes instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of ClassHasAttributes based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// ClassHasAttributes type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from ClassHasAttributes, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ClassHasAttributes" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ClassHasAttributes".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               ClassHasAttributesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasAttributesSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ClassHasAttributes based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ClassHasAttributes.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ClassHasAttributes instance should be created.</param>
	   /// <returns>Created ClassHasAttributes instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new ClassHasAttributes(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasAttributes.ModelClassDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ClassHasAttributes.AttributeDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassHasAttributes, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassHasAttributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasAttributes.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ClassHasAttributes itself) instance of ClassHasAttributes based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ClassHasAttributes" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ClassHasAttributes".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ClassHasAttributesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassHasAttributesSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ClassHasAttributes based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ClassHasAttributes.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasAttributes, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassHasAttributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassHasAttributes.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ClassHasAttributes instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ClassHasAttributes instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ClassHasAttributes instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassHasAttributes instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ClassHasAttributes instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ClassHasAttributes instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ClassHasAttributes instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // There are no properties; do nothing
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ClassHasAttributes instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassHasAttributes instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasAttributes instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassHasAttributes instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassHasAttributes instance = element as ClassHasAttributes;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassHasAttributes!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassHasAttributes instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return false;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelRootHasCommentsSerializer for DomainClass ModelRootHasComments.
	/// </summary>
	public partial class ModelRootHasCommentsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelRootHasCommentsSerializer Constructor
	   /// </summary>
	   public ModelRootHasCommentsSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelRootHasComments.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRootHasComments"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelRootHasComments.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRootHasCommentsMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelRootHasComments in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelRootHasComments instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelRootHasComments element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasComments instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the instance of target role-player Comment
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player Comment.
	            ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasComments");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method reads the target role player Comment.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasComments instance that will link to the target Comment instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the instance of target role-player Comment
	      DslModeling::ModelElement targetRolePlayer = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Comment.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Comment!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
	         if (targetRolePlayer != null)
	         {
	            // Attach the target role-player.
	            DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelRootHasComments.CommentDomainRoleId, targetRolePlayer);
	            // Read target role-player.
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, targetRolePlayer, reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRolePlayer == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasComments");
	      }
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasComments instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // There is no property to read; do nothing
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasComments instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelRootHasComments based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelRootHasComments, a new ModelRootHasComments instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelRootHasComments instance, or null if the reader is not pointing to a serialized ModelRootHasComments instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of ModelRootHasComments based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// ModelRootHasComments type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from ModelRootHasComments, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRootHasComments" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRootHasComments".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               ModelRootHasCommentsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasCommentsSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelRootHasComments based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelRootHasComments.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelRootHasComments instance should be created.</param>
	   /// <returns>Created ModelRootHasComments instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new ModelRootHasComments(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasComments.ModelRootDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasComments.CommentDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelRootHasComments, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelRootHasComments.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasComments.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelRootHasComments itself) instance of ModelRootHasComments based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRootHasComments" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRootHasComments".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelRootHasCommentsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasCommentsSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelRootHasComments based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelRootHasComments.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasComments, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasComments.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasComments.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelRootHasComments instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasComments instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelRootHasComments instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelRootHasComments instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelRootHasComments instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasComments instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasComments instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // There are no properties; do nothing
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasComments instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelRootHasComments instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasComments instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelRootHasComments instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRootHasComments instance = element as ModelRootHasComments;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasComments!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasComments instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return false;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer GeneralizationSerializer for DomainClass Generalization.
	/// </summary>
	public partial class GeneralizationSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// GeneralizationSerializer Constructor
	   /// </summary>
	   public GeneralizationSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of Generalization.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"generalization"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of Generalization.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"generalizationMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of Generalization in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one Generalization instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the Generalization element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Generalization instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the monikerized instance of target role-player Subclass
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player Subclass.
	            ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "Generalization");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method reads the target role player Subclass.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Generalization instance that will link to the target ModelClass instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the monikerized instance of target role-player Subclass
	      DslModeling::Moniker targetRoleMoniker = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((Generalization)element).Superclass, Generalization.DomainClassId, element.Partition);
	         if (targetRoleMoniker != null)
	         {
	            // Attach the target role-player moniker.
	            DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, Generalization.SubclassDomainRoleId, targetRoleMoniker);
	            // Moniker tag has no child XML elements in it, so just skip to the next element.
	            DslModeling::SerializationUtilities.Skip(reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRoleMoniker == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "Generalization");
	      }
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Generalization instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // There is no property to read; do nothing
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory Generalization instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of Generalization based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized Generalization, a new Generalization instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created Generalization instance, or null if the reader is not pointing to a serialized Generalization instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of Generalization based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// Generalization type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from Generalization, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "Generalization" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "Generalization".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               GeneralizationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as GeneralizationSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of Generalization based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of Generalization.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new Generalization instance should be created.</param>
	   /// <returns>Created Generalization instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new Generalization(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (Generalization.SuperclassDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (Generalization.SubclassDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from Generalization, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from Generalization.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Generalization.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including Generalization itself) instance of Generalization based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "Generalization" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "Generalization".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               GeneralizationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as GeneralizationSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of Generalization based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, Generalization.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Generalization, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Generalization.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Generalization.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized Generalization instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Generalization instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the Generalization instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Generalization instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one Generalization instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Generalization instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      // Write the target role-player instance.
	      Generalization instance = element as Generalization;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Generalization!");
	
	      DslModeling::ModelElement targetElement = instance.Subclass;
	      DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
	      global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
	      targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Superclass, this);
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Generalization instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // There are no properties; do nothing
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">Generalization instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Generalization instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Generalization instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Generalization instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Generalization instance = element as Generalization;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Generalization!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Generalization instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, Generalization.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), Generalization.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer BidirectionalAssociationSerializer for DomainClass BidirectionalAssociation.
	/// </summary>
	public partial class BidirectionalAssociationSerializer : AssociationSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// BidirectionalAssociationSerializer Constructor
	   /// </summary>
	   public BidirectionalAssociationSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of BidirectionalAssociation.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"bidirectionalAssociation"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of BidirectionalAssociation.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"bidirectionalAssociationMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of BidirectionalAssociation in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one BidirectionalAssociation instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the BidirectionalAssociation element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory BidirectionalAssociation instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the monikerized instance of target role-player BidirectionalTarget
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player BidirectionalTarget.
	            base.ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               base.ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "BidirectionalAssociation");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory BidirectionalAssociation instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      BidirectionalAssociation instanceOfBidirectionalAssociation = element as BidirectionalAssociation;
	      global::System.Diagnostics.Debug.Assert(instanceOfBidirectionalAssociation != null, "Expecting an instance of BidirectionalAssociation");
	
	      // SourcePropertyName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourcePropertyName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourcePropertyName");
	         if (attribSourcePropertyName != null)
	         {
	            global::System.String valueOfSourcePropertyName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourcePropertyName, out valueOfSourcePropertyName))
	            {
	               instanceOfBidirectionalAssociation.SourcePropertyName = valueOfSourcePropertyName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyName", typeof(global::System.String), attribSourcePropertyName);
	            }
	         }
	      }
	      // SourceDescription
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceDescription = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceDescription");
	         if (attribSourceDescription != null)
	         {
	            global::System.String valueOfSourceDescription;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceDescription, out valueOfSourceDescription))
	            {
	               instanceOfBidirectionalAssociation.SourceDescription = valueOfSourceDescription;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceDescription", typeof(global::System.String), attribSourceDescription);
	            }
	         }
	      }
	      // SourceSummary
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceSummary = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceSummary");
	         if (attribSourceSummary != null)
	         {
	            global::System.String valueOfSourceSummary;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceSummary, out valueOfSourceSummary))
	            {
	               instanceOfBidirectionalAssociation.SourceSummary = valueOfSourceSummary;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceSummary", typeof(global::System.String), attribSourceSummary);
	            }
	         }
	      }
	      // SourceCustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceCustomAttributes = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceCustomAttributes");
	         if (attribSourceCustomAttributes != null)
	         {
	            global::System.String valueOfSourceCustomAttributes;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceCustomAttributes, out valueOfSourceCustomAttributes))
	            {
	               instanceOfBidirectionalAssociation.SourceCustomAttributes = valueOfSourceCustomAttributes;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceCustomAttributes", typeof(global::System.String), attribSourceCustomAttributes);
	            }
	         }
	      }
	      // SourceDisplayText
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceDisplayText = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceDisplayText");
	         if (attribSourceDisplayText != null)
	         {
	            global::System.String valueOfSourceDisplayText;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceDisplayText, out valueOfSourceDisplayText))
	            {
	               instanceOfBidirectionalAssociation.SourceDisplayText = valueOfSourceDisplayText;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceDisplayText", typeof(global::System.String), attribSourceDisplayText);
	            }
	         }
	      }
	      // SourceImplementNotify
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceImplementNotify = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceImplementNotify");
	         if (attribSourceImplementNotify != null)
	         {
	            global::System.Boolean valueOfSourceImplementNotify;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceImplementNotify, out valueOfSourceImplementNotify))
	            {
	               instanceOfBidirectionalAssociation.SourceImplementNotify = valueOfSourceImplementNotify;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceImplementNotify", typeof(global::System.Boolean), attribSourceImplementNotify);
	            }
	         }
	      }
	      // IsSourceImplementNotifyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsSourceImplementNotifyTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isSourceImplementNotifyTracking");
	         if (attribIsSourceImplementNotifyTracking != null)
	         {
	            global::System.Boolean valueOfIsSourceImplementNotifyTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsSourceImplementNotifyTracking, out valueOfIsSourceImplementNotifyTracking))
	            {
	               instanceOfBidirectionalAssociation.IsSourceImplementNotifyTracking = valueOfIsSourceImplementNotifyTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isSourceImplementNotifyTracking", typeof(global::System.Boolean), attribIsSourceImplementNotifyTracking);
	            }
	         }
	      }
	      // SourcePropertyAccessMode
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourcePropertyAccessMode = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourcePropertyAccessMode");
	         if (attribSourcePropertyAccessMode != null)
	         {
	            PropertyAccessMode valueOfSourcePropertyAccessMode;
	            if (DslModeling::SerializationUtilities.TryGetValue<PropertyAccessMode>(serializationContext, attribSourcePropertyAccessMode, out valueOfSourcePropertyAccessMode))
	            {
	               instanceOfBidirectionalAssociation.SourcePropertyAccessMode = valueOfSourcePropertyAccessMode;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourcePropertyAccessMode", typeof(PropertyAccessMode), attribSourcePropertyAccessMode);
	            }
	         }
	      }
	      // SourceBackingFieldName
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceBackingFieldName = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceBackingFieldName");
	         if (attribSourceBackingFieldName != null)
	         {
	            global::System.String valueOfSourceBackingFieldName;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribSourceBackingFieldName, out valueOfSourceBackingFieldName))
	            {
	               instanceOfBidirectionalAssociation.SourceBackingFieldName = valueOfSourceBackingFieldName;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceBackingFieldName", typeof(global::System.String), attribSourceBackingFieldName);
	            }
	         }
	      }
	      // SourceAutoProperty
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceAutoProperty = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceAutoProperty");
	         if (attribSourceAutoProperty != null)
	         {
	            global::System.Boolean valueOfSourceAutoProperty;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceAutoProperty, out valueOfSourceAutoProperty))
	            {
	               instanceOfBidirectionalAssociation.SourceAutoProperty = valueOfSourceAutoProperty;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceAutoProperty", typeof(global::System.Boolean), attribSourceAutoProperty);
	            }
	         }
	      }
	      // IsSourceAutoPropertyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsSourceAutoPropertyTracking = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isSourceAutoPropertyTracking");
	         if (attribIsSourceAutoPropertyTracking != null)
	         {
	            global::System.Boolean valueOfIsSourceAutoPropertyTracking;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsSourceAutoPropertyTracking, out valueOfIsSourceAutoPropertyTracking))
	            {
	               instanceOfBidirectionalAssociation.IsSourceAutoPropertyTracking = valueOfIsSourceAutoPropertyTracking;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isSourceAutoPropertyTracking", typeof(global::System.Boolean), attribIsSourceAutoPropertyTracking);
	            }
	         }
	      }
	      // IsSourceAbstract
	      if (!serializationContext.Result.Failed)
	      {
	         string attribIsSourceAbstract = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "isSourceAbstract");
	         if (attribIsSourceAbstract != null)
	         {
	            global::System.Boolean valueOfIsSourceAbstract;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribIsSourceAbstract, out valueOfIsSourceAbstract))
	            {
	               instanceOfBidirectionalAssociation.IsSourceAbstract = valueOfIsSourceAbstract;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "isSourceAbstract", typeof(global::System.Boolean), attribIsSourceAbstract);
	            }
	         }
	      }
	      // SourceAutoInclude
	      if (!serializationContext.Result.Failed)
	      {
	         string attribSourceAutoInclude = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "sourceAutoInclude");
	         if (attribSourceAutoInclude != null)
	         {
	            global::System.Boolean valueOfSourceAutoInclude;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribSourceAutoInclude, out valueOfSourceAutoInclude))
	            {
	               instanceOfBidirectionalAssociation.SourceAutoInclude = valueOfSourceAutoInclude;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "sourceAutoInclude", typeof(global::System.Boolean), attribSourceAutoInclude);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of BidirectionalAssociation based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized BidirectionalAssociation, a new BidirectionalAssociation instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created BidirectionalAssociation instance, or null if the reader is not pointing to a serialized BidirectionalAssociation instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of BidirectionalAssociation based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// BidirectionalAssociation type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from BidirectionalAssociation, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "BidirectionalAssociation" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "BidirectionalAssociation".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               BidirectionalAssociationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as BidirectionalAssociationSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of BidirectionalAssociation based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of BidirectionalAssociation.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new BidirectionalAssociation instance should be created.</param>
	   /// <returns>Created BidirectionalAssociation instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new BidirectionalAssociation(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (BidirectionalAssociation.BidirectionalSourceDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (BidirectionalAssociation.BidirectionalTargetDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from BidirectionalAssociation, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from BidirectionalAssociation.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(BidirectionalAssociation.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including BidirectionalAssociation itself) instance of BidirectionalAssociation based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "BidirectionalAssociation" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "BidirectionalAssociation".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               BidirectionalAssociationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as BidirectionalAssociationSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of BidirectionalAssociation based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, BidirectionalAssociation.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from BidirectionalAssociation, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from BidirectionalAssociation.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(BidirectionalAssociation.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized BidirectionalAssociation instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">BidirectionalAssociation instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the BidirectionalAssociation instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the BidirectionalAssociation instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one BidirectionalAssociation instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">BidirectionalAssociation instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      // Write the target role-player instance.
	      BidirectionalAssociation instance = element as BidirectionalAssociation;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of BidirectionalAssociation!");
	
	      DslModeling::ModelElement targetElement = instance.BidirectionalTarget;
	      DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
	      global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
	      targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.BidirectionalSource, this);
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         base.WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">BidirectionalAssociation instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      BidirectionalAssociation instanceOfBidirectionalAssociation = element as BidirectionalAssociation;
	      global::System.Diagnostics.Debug.Assert(instanceOfBidirectionalAssociation != null, "Expecting an instance of BidirectionalAssociation");
	
	      // SourcePropertyName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfBidirectionalAssociation.SourcePropertyName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourcePropertyName", propValue);
	            }
	         }
	      }
	      // SourceDescription
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfBidirectionalAssociation.SourceDescription;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceDescription", propValue);
	            }
	         }
	      }
	      // SourceSummary
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfBidirectionalAssociation.SourceSummary;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceSummary", propValue);
	
	         }
	      }
	      // SourceCustomAttributes
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfBidirectionalAssociation.SourceCustomAttributes;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceCustomAttributes", propValue);
	
	         }
	      }
	      // SourceDisplayText
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfBidirectionalAssociation.SourceDisplayText;
	         if (!serializationContext.Result.Failed)
	         {
	            if (!string.IsNullOrEmpty(propValue))
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceDisplayText", propValue);
	
	         }
	      }
	      // SourceImplementNotify
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfBidirectionalAssociation.SourceImplementNotify;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceImplementNotify", serializedPropValue);
	         }
	      }
	      // IsSourceImplementNotifyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfBidirectionalAssociation.IsSourceImplementNotifyTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isSourceImplementNotifyTracking", serializedPropValue);
	            }
	         }
	      }
	      // SourcePropertyAccessMode
	      if (!serializationContext.Result.Failed)
	      {
	         PropertyAccessMode propValue = instanceOfBidirectionalAssociation.SourcePropertyAccessMode;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<PropertyAccessMode>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "FieldDuringConstruction") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourcePropertyAccessMode", serializedPropValue);
	            }
	         }
	      }
	      // SourceBackingFieldName
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.String propValue = instanceOfBidirectionalAssociation.SourceBackingFieldName;
	         if (!serializationContext.Result.Failed)
	         {
	            if (propValue != null)
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceBackingFieldName", propValue);
	         }
	      }
	      // SourceAutoProperty
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfBidirectionalAssociation.SourceAutoProperty;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceAutoProperty", serializedPropValue);
	            }
	         }
	      }
	      // IsSourceAutoPropertyTracking
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfBidirectionalAssociation.IsSourceAutoPropertyTracking;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isSourceAutoPropertyTracking", serializedPropValue);
	            }
	         }
	      }
	      // IsSourceAbstract
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfBidirectionalAssociation.IsSourceAbstract;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "isSourceAbstract", serializedPropValue);
	         }
	      }
	      // SourceAutoInclude
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfBidirectionalAssociation.SourceAutoInclude;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "sourceAutoInclude", serializedPropValue);
	         }
	      }
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given BidirectionalAssociation instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">BidirectionalAssociation instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the BidirectionalAssociation instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			BidirectionalAssociation instance = element as BidirectionalAssociation;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of BidirectionalAssociation!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">BidirectionalAssociation instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of ModelClass that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, BidirectionalAssociation.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), BidirectionalAssociation.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is ModelClass, "Expecting an instance of ModelClass!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelRootHasEnumsSerializer for DomainClass ModelRootHasEnums.
	/// </summary>
	public partial class ModelRootHasEnumsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelRootHasEnumsSerializer Constructor
	   /// </summary>
	   public ModelRootHasEnumsSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelRootHasEnums.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRootHasEnums"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelRootHasEnums.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRootHasEnumsMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelRootHasEnums in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelRootHasEnums instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelRootHasEnums element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasEnums instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the instance of target role-player ModelEnum
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player ModelEnum.
	            ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasEnums");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method reads the target role player ModelEnum.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasEnums instance that will link to the target ModelEnum instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the instance of target role-player ModelEnum
	      DslModeling::ModelElement targetRolePlayer = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelEnum.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelEnum!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
	         if (targetRolePlayer != null)
	         {
	            // Attach the target role-player.
	            DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelRootHasEnums.ModelEnumDomainRoleId, targetRolePlayer);
	            // Read target role-player.
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, targetRolePlayer, reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRolePlayer == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasEnums");
	      }
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasEnums instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // There is no property to read; do nothing
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasEnums instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelRootHasEnums based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelRootHasEnums, a new ModelRootHasEnums instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelRootHasEnums instance, or null if the reader is not pointing to a serialized ModelRootHasEnums instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of ModelRootHasEnums based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// ModelRootHasEnums type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from ModelRootHasEnums, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRootHasEnums" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRootHasEnums".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               ModelRootHasEnumsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasEnumsSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelRootHasEnums based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelRootHasEnums.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelRootHasEnums instance should be created.</param>
	   /// <returns>Created ModelRootHasEnums instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new ModelRootHasEnums(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasEnums.ModelRootDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasEnums.ModelEnumDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelRootHasEnums, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelRootHasEnums.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasEnums.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelRootHasEnums itself) instance of ModelRootHasEnums based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRootHasEnums" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRootHasEnums".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelRootHasEnumsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasEnumsSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelRootHasEnums based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelRootHasEnums.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasEnums, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasEnums.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasEnums.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelRootHasEnums instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasEnums instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelRootHasEnums instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelRootHasEnums instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelRootHasEnums instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasEnums instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      // Write the target role-player instance.
	      ModelRootHasEnums instance = element as ModelRootHasEnums;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasEnums!");
	
	      DslModeling::ModelElement targetElement = instance.ModelEnum;
	      DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
	      global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
	      targetSerializer.Write(serializationContext, targetElement, writer);
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasEnums instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // There are no properties; do nothing
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasEnums instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelRootHasEnums instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasEnums instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelRootHasEnums instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRootHasEnums instance = element as ModelRootHasEnums;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasEnums!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasEnums instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelEnumHasValuesSerializer for DomainClass ModelEnumHasValues.
	/// </summary>
	public partial class ModelEnumHasValuesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelEnumHasValuesSerializer Constructor
	   /// </summary>
	   public ModelEnumHasValuesSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelEnumHasValues.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelEnumHasValues"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelEnumHasValues.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelEnumHasValuesMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelEnumHasValues in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelEnumHasValues instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelEnumHasValues element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnumHasValues instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the instance of target role-player Value
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player Value.
	            ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelEnumHasValues");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method reads the target role player Value.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnumHasValues instance that will link to the target ModelEnumValue instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the instance of target role-player Value
	      DslModeling::ModelElement targetRolePlayer = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelEnumValue.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelEnumValue!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
	         if (targetRolePlayer != null)
	         {
	            // Attach the target role-player.
	            DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelEnumHasValues.ValueDomainRoleId, targetRolePlayer);
	            // Read target role-player.
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, targetRolePlayer, reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRolePlayer == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelEnumHasValues");
	      }
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnumHasValues instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // There is no property to read; do nothing
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelEnumHasValues instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelEnumHasValues based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelEnumHasValues, a new ModelEnumHasValues instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelEnumHasValues instance, or null if the reader is not pointing to a serialized ModelEnumHasValues instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of ModelEnumHasValues based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// ModelEnumHasValues type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from ModelEnumHasValues, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelEnumHasValues" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelEnumHasValues".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               ModelEnumHasValuesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelEnumHasValuesSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelEnumHasValues based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelEnumHasValues.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelEnumHasValues instance should be created.</param>
	   /// <returns>Created ModelEnumHasValues instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new ModelEnumHasValues(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelEnumHasValues.EnumDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelEnumHasValues.ValueDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelEnumHasValues, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelEnumHasValues.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelEnumHasValues.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelEnumHasValues itself) instance of ModelEnumHasValues based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelEnumHasValues" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelEnumHasValues".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelEnumHasValuesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelEnumHasValuesSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelEnumHasValues based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelEnumHasValues.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelEnumHasValues, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelEnumHasValues.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelEnumHasValues.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelEnumHasValues instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnumHasValues instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelEnumHasValues instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelEnumHasValues instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelEnumHasValues instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnumHasValues instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      // Write the target role-player instance.
	      ModelEnumHasValues instance = element as ModelEnumHasValues;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelEnumHasValues!");
	
	      DslModeling::ModelElement targetElement = instance.Value;
	      DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
	      global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
	      targetSerializer.Write(serializationContext, targetElement, writer);
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnumHasValues instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // There are no properties; do nothing
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelEnumHasValues instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelEnumHasValues instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelEnumHasValues instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelEnumHasValues instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelEnumHasValues instance = element as ModelEnumHasValues;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelEnumHasValues!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelEnumHasValues instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelRootHasClassesSerializer for DomainClass ModelRootHasClasses.
	/// </summary>
	public partial class ModelRootHasClassesSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelRootHasClassesSerializer Constructor
	   /// </summary>
	   public ModelRootHasClassesSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelRootHasClasses.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRootHasClasses"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelRootHasClasses.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRootHasClassesMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelRootHasClasses in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelRootHasClasses instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelRootHasClasses element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasClasses instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the instance of target role-player ModelClass
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player ModelClass.
	            ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasClasses");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method reads the target role player ModelClass.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasClasses instance that will link to the target ModelClass instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the instance of target role-player ModelClass
	      DslModeling::ModelElement targetRolePlayer = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
	         if (targetRolePlayer != null)
	         {
	            // Attach the target role-player.
	            DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelRootHasClasses.ModelClassDomainRoleId, targetRolePlayer);
	            // Read target role-player.
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, targetRolePlayer, reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRolePlayer == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasClasses");
	      }
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasClasses instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // There is no property to read; do nothing
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasClasses instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelRootHasClasses based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelRootHasClasses, a new ModelRootHasClasses instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelRootHasClasses instance, or null if the reader is not pointing to a serialized ModelRootHasClasses instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of ModelRootHasClasses based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// ModelRootHasClasses type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from ModelRootHasClasses, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRootHasClasses" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRootHasClasses".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               ModelRootHasClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasClassesSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelRootHasClasses based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelRootHasClasses.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelRootHasClasses instance should be created.</param>
	   /// <returns>Created ModelRootHasClasses instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new ModelRootHasClasses(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasClasses.ModelRootDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasClasses.ModelClassDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelRootHasClasses, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelRootHasClasses.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasClasses.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelRootHasClasses itself) instance of ModelRootHasClasses based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRootHasClasses" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRootHasClasses".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelRootHasClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasClassesSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelRootHasClasses based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelRootHasClasses.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasClasses, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasClasses.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasClasses.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelRootHasClasses instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasClasses instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelRootHasClasses instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelRootHasClasses instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelRootHasClasses instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasClasses instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      // Write the target role-player instance.
	      ModelRootHasClasses instance = element as ModelRootHasClasses;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasClasses!");
	
	      DslModeling::ModelElement targetElement = instance.ModelClass;
	      DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
	      global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
	      targetSerializer.Write(serializationContext, targetElement, writer);
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasClasses instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // There are no properties; do nothing
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasClasses instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelRootHasClasses instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasClasses instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelRootHasClasses instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRootHasClasses instance = element as ModelRootHasClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasClasses!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasClasses instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer CommentReferencesSubjectsSerializer for DomainClass CommentReferencesSubjects.
	/// </summary>
	public partial class CommentReferencesSubjectsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// CommentReferencesSubjectsSerializer Constructor
	   /// </summary>
	   public CommentReferencesSubjectsSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// Cannot be serialized.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// CommentReferencesSubjects is abstract and cannot be instantiated, so this method throws NotSupportedException.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the CommentReferencesSubjects element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentReferencesSubjects instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// This method reads the target role player DesignElement.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentReferencesSubjects instance that will link to the target DesignElement instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the monikerized instance of target role-player DesignElement
	      DslModeling::Moniker targetRoleMoniker = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(DesignElement.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for DesignElement!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((CommentReferencesSubjects)element).Comment, CommentReferencesSubjects.DomainClassId, element.Partition);
	         if (targetRoleMoniker != null)
	         {
	            // Attach the target role-player moniker.
	            DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, CommentReferencesSubjects.DesignElementDomainRoleId, targetRoleMoniker);
	            // Moniker tag has no child XML elements in it, so just skip to the next element.
	            DslModeling::SerializationUtilities.Skip(reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRoleMoniker == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "CommentReferencesSubjects");
	      }
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentReferencesSubjects instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // There is no property to read; do nothing
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of CommentReferencesSubjects based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized CommentReferencesSubjects, a new CommentReferencesSubjects instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created CommentReferencesSubjects instance, or null if the reader is not pointing to a serialized CommentReferencesSubjects instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         // Check for derived classes of "CommentReferencesSubjects".
	         if (this.derivedClasses == null)
	            this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	         global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	         DslModeling::DomainClassInfo derivedClass = null;
	         if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	         {   // New derived relationship instance.
	            CommentReferencesSubjectsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentReferencesSubjectsSerializer;
	            global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	            result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of CommentReferencesSubjects based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of CommentReferencesSubjects.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new CommentReferencesSubjects instance should be created.</param>
	   /// <returns>Created CommentReferencesSubjects instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      // Abstract class, cannot be serialized.
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of CommentReferencesSubjects based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// CommentReferencesSubjects type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from CommentReferencesSubjects, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {   // Abstract relationship, so it's the same as TryCreateInstance().
	      return this.TryCreateInstance(serializationContext, reader, partition) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from CommentReferencesSubjects, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from CommentReferencesSubjects.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentReferencesSubjects.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including CommentReferencesSubjects itself) instance of CommentReferencesSubjects based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         // Check for derived classes of "CommentReferencesSubjects".
	         if (this.derivedClassMonikers == null)
	            this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	         global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	         DslModeling::DomainClassInfo derivedClass = null;
	         if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	         {   // New derived class moniker instance.
	            CommentReferencesSubjectsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentReferencesSubjectsSerializer;
	            global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	            result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of CommentReferencesSubjects based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, CommentReferencesSubjects.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentReferencesSubjects, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentReferencesSubjects.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentReferencesSubjects.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized CommentReferencesSubjects instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentReferencesSubjects instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the CommentReferencesSubjects instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the CommentReferencesSubjects instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      // Instance of CommentReferencesSubjects cannot be monikerized.
	      EFModelSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "CommentReferencesSubjects");
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one CommentReferencesSubjects instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentReferencesSubjects instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentReferencesSubjects instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // There are no properties; do nothing
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given CommentReferencesSubjects instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentReferencesSubjects instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the CommentReferencesSubjects instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentReferencesSubjects instance = element as CommentReferencesSubjects;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentReferencesSubjects!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentReferencesSubjects instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a DesignElement
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of Comment that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of DesignElement</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of DesignElement instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Comment, "Expecting an instance of Comment!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, CommentReferencesSubjects.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), CommentReferencesSubjects.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a DesignElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Comment, "Expecting an instance of Comment!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is DesignElement, "Expecting an instance of DesignElement!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer CommentReferencesClassesSerializer for DomainClass CommentReferencesClasses.
	/// </summary>
	public partial class CommentReferencesClassesSerializer : CommentReferencesSubjectsSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// CommentReferencesClassesSerializer Constructor
	   /// </summary>
	   public CommentReferencesClassesSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of CommentReferencesClasses.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"commentReferencesClasses"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of CommentReferencesClasses.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"commentReferencesClassesMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of CommentReferencesClasses in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one CommentReferencesClasses instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the CommentReferencesClasses element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentReferencesClasses instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the monikerized instance of target role-player ModelClass
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player ModelClass.
	            ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               base.ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "CommentReferencesClasses");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method reads the target role player ModelClass.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentReferencesClasses instance that will link to the target ModelClass instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the monikerized instance of target role-player ModelClass
	      DslModeling::Moniker targetRoleMoniker = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelClass.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelClass!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((CommentReferencesClasses)element).Comment, CommentReferencesClasses.DomainClassId, element.Partition);
	         if (targetRoleMoniker != null)
	         {
	            // Attach the target role-player moniker.
	            DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, CommentReferencesClasses.ModelClassDomainRoleId, targetRoleMoniker);
	            // Moniker tag has no child XML elements in it, so just skip to the next element.
	            DslModeling::SerializationUtilities.Skip(reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRoleMoniker == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "CommentReferencesClasses");
	      }
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of CommentReferencesClasses based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized CommentReferencesClasses, a new CommentReferencesClasses instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created CommentReferencesClasses instance, or null if the reader is not pointing to a serialized CommentReferencesClasses instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of CommentReferencesClasses based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// CommentReferencesClasses type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from CommentReferencesClasses, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "CommentReferencesClasses" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "CommentReferencesClasses".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               CommentReferencesClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentReferencesClassesSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of CommentReferencesClasses based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of CommentReferencesClasses.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new CommentReferencesClasses instance should be created.</param>
	   /// <returns>Created CommentReferencesClasses instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new CommentReferencesClasses(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (CommentReferencesClasses.CommentDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (CommentReferencesClasses.ModelClassDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from CommentReferencesClasses, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from CommentReferencesClasses.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentReferencesClasses.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including CommentReferencesClasses itself) instance of CommentReferencesClasses based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "CommentReferencesClasses" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "CommentReferencesClasses".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               CommentReferencesClassesSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentReferencesClassesSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of CommentReferencesClasses based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, CommentReferencesClasses.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentReferencesClasses, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentReferencesClasses.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentReferencesClasses.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized CommentReferencesClasses instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentReferencesClasses instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the CommentReferencesClasses instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the CommentReferencesClasses instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one CommentReferencesClasses instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentReferencesClasses instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      // Write the target role-player instance.
	      CommentReferencesClasses instance = element as CommentReferencesClasses;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentReferencesClasses!");
	
	      DslModeling::ModelElement targetElement = instance.ModelClass;
	      DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
	      global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
	      targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Comment, this);
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         base.WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given CommentReferencesClasses instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentReferencesClasses instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the CommentReferencesClasses instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentReferencesClasses instance = element as CommentReferencesClasses;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentReferencesClasses!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentReferencesClasses instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelClass
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of Comment that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelClass</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelClass instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Comment, "Expecting an instance of Comment!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, CommentReferencesClasses.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), CommentReferencesClasses.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelClass.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Comment, "Expecting an instance of Comment!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelClass, "Expecting an instance of ModelClass!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer CommentReferencesEnumsSerializer for DomainClass CommentReferencesEnums.
	/// </summary>
	public partial class CommentReferencesEnumsSerializer : CommentReferencesSubjectsSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// CommentReferencesEnumsSerializer Constructor
	   /// </summary>
	   public CommentReferencesEnumsSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of CommentReferencesEnums.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"commentReferencesEnums"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of CommentReferencesEnums.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"commentReferencesEnumsMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of CommentReferencesEnums in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one CommentReferencesEnums instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the CommentReferencesEnums element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentReferencesEnums instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the monikerized instance of target role-player ModelEnum
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player ModelEnum.
	            ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               base.ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "CommentReferencesEnums");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method reads the target role player ModelEnum.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentReferencesEnums instance that will link to the target ModelEnum instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the monikerized instance of target role-player ModelEnum
	      DslModeling::Moniker targetRoleMoniker = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelEnum.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelEnum!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((CommentReferencesEnums)element).Comment, CommentReferencesEnums.DomainClassId, element.Partition);
	         if (targetRoleMoniker != null)
	         {
	            // Attach the target role-player moniker.
	            DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, CommentReferencesEnums.ModelEnumDomainRoleId, targetRoleMoniker);
	            // Moniker tag has no child XML elements in it, so just skip to the next element.
	            DslModeling::SerializationUtilities.Skip(reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRoleMoniker == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "CommentReferencesEnums");
	      }
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of CommentReferencesEnums based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized CommentReferencesEnums, a new CommentReferencesEnums instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created CommentReferencesEnums instance, or null if the reader is not pointing to a serialized CommentReferencesEnums instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of CommentReferencesEnums based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// CommentReferencesEnums type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from CommentReferencesEnums, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "CommentReferencesEnums" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "CommentReferencesEnums".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               CommentReferencesEnumsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentReferencesEnumsSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of CommentReferencesEnums based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of CommentReferencesEnums.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new CommentReferencesEnums instance should be created.</param>
	   /// <returns>Created CommentReferencesEnums instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new CommentReferencesEnums(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (CommentReferencesEnums.CommentDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (CommentReferencesEnums.ModelEnumDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from CommentReferencesEnums, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from CommentReferencesEnums.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentReferencesEnums.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including CommentReferencesEnums itself) instance of CommentReferencesEnums based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "CommentReferencesEnums" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "CommentReferencesEnums".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               CommentReferencesEnumsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentReferencesEnumsSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of CommentReferencesEnums based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, CommentReferencesEnums.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentReferencesEnums, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentReferencesEnums.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentReferencesEnums.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized CommentReferencesEnums instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentReferencesEnums instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the CommentReferencesEnums instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the CommentReferencesEnums instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one CommentReferencesEnums instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentReferencesEnums instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      // Write the target role-player instance.
	      CommentReferencesEnums instance = element as CommentReferencesEnums;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentReferencesEnums!");
	
	      DslModeling::ModelElement targetElement = instance.ModelEnum;
	      DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
	      global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
	      targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.Comment, this);
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         base.WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given CommentReferencesEnums instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentReferencesEnums instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the CommentReferencesEnums instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentReferencesEnums instance = element as CommentReferencesEnums;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentReferencesEnums!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentReferencesEnums instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a ModelEnum
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of Comment that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of ModelEnum</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of ModelEnum instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Comment, "Expecting an instance of Comment!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, CommentReferencesEnums.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), CommentReferencesEnums.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a ModelEnum.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is Comment, "Expecting an instance of Comment!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is ModelEnum, "Expecting an instance of ModelEnum!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ModelRootHasModelDiagramsSerializer for DomainClass ModelRootHasModelDiagrams.
	/// </summary>
	public partial class ModelRootHasModelDiagramsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ModelRootHasModelDiagramsSerializer Constructor
	   /// </summary>
	   public ModelRootHasModelDiagramsSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ModelRootHasModelDiagrams.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRootHasModelDiagrams"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ModelRootHasModelDiagrams.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"modelRootHasModelDiagramsMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ModelRootHasModelDiagrams in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ModelRootHasModelDiagrams instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ModelRootHasModelDiagrams element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasModelDiagrams instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements, which include at least the instance of target role-player ModelDiagramData
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read target role-player ModelDiagramData.
	            ReadTargetRolePlayer(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	         else
	         {
	            EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasModelDiagrams");
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method reads the target role player ModelDiagramData.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	   /// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	   /// 1) The open tag of the target role player.
	   /// 2) The end tag of the parent element (dangling relationship).
	   /// 3) EOF (dangling relationship).
	   /// After the call, the reader is positioned at:
	   /// 1) The open tag of the next child element after the target role player.
	   /// 2) The end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasModelDiagrams instance that will link to the target ModelDiagramData instance.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read the instance of target role-player ModelDiagramData
	      DslModeling::ModelElement targetRolePlayer = null;
	      DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(ModelDiagramData.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for ModelDiagramData!");
	
	      while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
	         if (targetRolePlayer != null)
	         {
	            // Attach the target role-player.
	            DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, ModelRootHasModelDiagrams.ModelDiagramDataDomainRoleId, targetRolePlayer);
	            // Read target role-player.
	            DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);
	            global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
	            targetSerializer.Read(serializationContext, targetRolePlayer, reader);
	            break;
	         }
	         // Encountered one unknown XML element, skip it and keep reading.
	         EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	         DslModeling::SerializationUtilities.Skip(reader);
	      }
	      if (targetRolePlayer == null)
	      {
	         EFModelSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "ModelRootHasModelDiagrams");
	      }
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasModelDiagrams instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // There is no property to read; do nothing
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ModelRootHasModelDiagrams instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance & TryCreateDerivedInstance
	   /// <summary>
	   /// This method creates a correct instance of ModelRootHasModelDiagrams based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ModelRootHasModelDiagrams, a new ModelRootHasModelDiagrams instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ModelRootHasModelDiagrams instance, or null if the reader is not pointing to a serialized ModelRootHasModelDiagrams instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	   }
	
	   /// <summary>
	   /// This method creates a correct derived instance of ModelRootHasModelDiagrams based on the tag currently pointed by the reader.
	   /// Note that the difference between this method and the above one is that this method will never create an instance of the
	   /// ModelRootHasModelDiagrams type itself, only derived types are checked.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created instance that derives from ModelRootHasModelDiagrams, or null if the reader is not pointing to such a serialized instance.</returns>
	   public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	   }
	
	   /// <summary>
	   /// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	   private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	   {
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRootHasModelDiagrams" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRootHasModelDiagrams".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived relationship instance.
	               ModelRootHasModelDiagramsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasModelDiagramsSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ModelRootHasModelDiagrams based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ModelRootHasModelDiagrams.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ModelRootHasModelDiagrams instance should be created.</param>
	   /// <returns>Created ModelRootHasModelDiagrams instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         // Create the link with place-holder role-players.
	         return new ModelRootHasModelDiagrams(
	            partition,
	            new DslModeling::RoleAssignment[] {
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasModelDiagrams.ModelRootDomainRoleId), 
	               DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (ModelRootHasModelDiagrams.ModelDiagramDataDomainRoleId)
	            },
	            new DslModeling::PropertyAssignment[] {
	               new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
	            }
	         );
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ModelRootHasModelDiagrams, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ModelRootHasModelDiagrams.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasModelDiagrams.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ModelRootHasModelDiagrams itself) instance of ModelRootHasModelDiagrams based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ModelRootHasModelDiagrams" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ModelRootHasModelDiagrams".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ModelRootHasModelDiagramsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ModelRootHasModelDiagramsSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ModelRootHasModelDiagrams based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ModelRootHasModelDiagrams.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasModelDiagrams, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ModelRootHasModelDiagrams.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ModelRootHasModelDiagrams.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ModelRootHasModelDiagrams instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasModelDiagrams instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ModelRootHasModelDiagrams instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ModelRootHasModelDiagrams instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ModelRootHasModelDiagrams instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasModelDiagrams instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      // Write the target role-player instance.
	      ModelRootHasModelDiagrams instance = element as ModelRootHasModelDiagrams;
	      global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasModelDiagrams!");
	
	      DslModeling::ModelElement targetElement = instance.ModelDiagramData;
	      DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
	      global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
	      targetSerializer.Write(serializationContext, targetElement, writer);
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasModelDiagrams instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // There are no properties; do nothing
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ModelRootHasModelDiagrams instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ModelRootHasModelDiagrams instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasModelDiagrams instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ModelRootHasModelDiagrams instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ModelRootHasModelDiagrams instance = element as ModelRootHasModelDiagrams;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ModelRootHasModelDiagrams!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ModelRootHasModelDiagrams instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	   #region Overrides to provide metadata at runtime
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing Id.
	   /// </summary>
	   public override bool SerializesId
	   {
	      get
	      {
	         return true;
	      }
	   }
	
	   /// <summary>
	   /// Exposes whether serializers derived from this class are serializing this relationship in full form.
	   /// </summary>
	   public override bool UsesFullForm
	   {
	      get
	      {
	         return true;
	      }
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer ClassShapeSerializerBase for DomainClass ClassShape.
	/// </summary>
	public abstract partial class ClassShapeSerializerBase : DslDiagrams::CompartmentShapeSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// ClassShapeSerializerBase Constructor
	   /// </summary>
	   protected ClassShapeSerializerBase ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of ClassShape.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"classShape"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of ClassShape.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"classShapeMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of ClassShape in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one ClassShape instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the ClassShape element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ClassShape instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ClassShape instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      ClassShape instanceOfClassShape = element as ClassShape;
	      global::System.Diagnostics.Debug.Assert(instanceOfClassShape != null, "Expecting an instance of ClassShape");
	
	      // FillColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribFillColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "fillColor");
	         if (attribFillColor != null)
	         {
	            global::System.Drawing.Color valueOfFillColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribFillColor, out valueOfFillColor))
	            {
	               instanceOfClassShape.FillColor = valueOfFillColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "fillColor", typeof(global::System.Drawing.Color), attribFillColor);
	            }
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTextColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "textColor");
	         if (attribTextColor != null)
	         {
	            global::System.Drawing.Color valueOfTextColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribTextColor, out valueOfTextColor))
	            {
	               instanceOfClassShape.TextColor = valueOfTextColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "textColor", typeof(global::System.Drawing.Color), attribTextColor);
	            }
	         }
	      }
	      // OutlineColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutlineColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outlineColor");
	         if (attribOutlineColor != null)
	         {
	            global::System.Drawing.Color valueOfOutlineColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribOutlineColor, out valueOfOutlineColor))
	            {
	               instanceOfClassShape.OutlineColor = valueOfOutlineColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outlineColor", typeof(global::System.Drawing.Color), attribOutlineColor);
	            }
	         }
	      }
	      // OutlineDashStyle
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutlineDashStyle = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outlineDashStyle");
	         if (attribOutlineDashStyle != null)
	         {
	            global::System.Drawing.Drawing2D.DashStyle valueOfOutlineDashStyle;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Drawing2D.DashStyle>(serializationContext, attribOutlineDashStyle, out valueOfOutlineDashStyle))
	            {
	               instanceOfClassShape.OutlineDashStyle = valueOfOutlineDashStyle;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outlineDashStyle", typeof(global::System.Drawing.Drawing2D.DashStyle), attribOutlineDashStyle);
	            }
	         }
	      }
	      // Visible
	      if (!serializationContext.Result.Failed)
	      {
	         string attribVisible = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "visible");
	         if (attribVisible != null)
	         {
	            global::System.Boolean valueOfVisible;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribVisible, out valueOfVisible))
	            {
	               instanceOfClassShape.Visible = valueOfVisible;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "visible", typeof(global::System.Boolean), attribVisible);
	            }
	         }
	      }
	      // OutlineThickness
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutlineThickness = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outlineThickness");
	         if (attribOutlineThickness != null)
	         {
	            global::System.Single valueOfOutlineThickness;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Single>(serializationContext, attribOutlineThickness, out valueOfOutlineThickness))
	            {
	               instanceOfClassShape.OutlineThickness = valueOfOutlineThickness;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outlineThickness", typeof(global::System.Single), attribOutlineThickness);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory ClassShape instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of ClassShape based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized ClassShape, a new ClassShape instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created ClassShape instance, or null if the reader is not pointing to a serialized ClassShape instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ClassShape" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "ClassShape".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               ClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassShapeSerializerBase;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of ClassShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of ClassShape.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new ClassShape instance should be created.</param>
	   /// <returns>Created ClassShape instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new ClassShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from ClassShape, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from ClassShape.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassShape.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including ClassShape itself) instance of ClassShape based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "ClassShape" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "ClassShape".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               ClassShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ClassShapeSerializerBase;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of ClassShape based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, ClassShape.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassShape, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from ClassShape.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(ClassShape.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized ClassShape instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ClassShape instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the ClassShape instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the ClassShape instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one ClassShape instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ClassShape instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ClassShape instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      ClassShape instanceOfClassShape = element as ClassShape;
	      global::System.Diagnostics.Debug.Assert(instanceOfClassShape != null, "Expecting an instance of ClassShape");
	
	      // FillColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfClassShape.FillColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "fillColor", serializedPropValue);
	            }
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfClassShape.TextColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "textColor", serializedPropValue);
	         }
	      }
	      // OutlineColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfClassShape.OutlineColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outlineColor", serializedPropValue);
	         }
	      }
	      // OutlineDashStyle
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Drawing2D.DashStyle propValue = instanceOfClassShape.OutlineDashStyle;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Drawing2D.DashStyle>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outlineDashStyle", serializedPropValue);
	         }
	      }
	      // Visible
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfClassShape.Visible;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "visible", serializedPropValue);
	            }
	         }
	      }
	      // OutlineThickness
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Single propValue = instanceOfClassShape.OutlineThickness;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Single>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outlineThickness", serializedPropValue);
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">ClassShape instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given ClassShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the ClassShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			ClassShape instance = element as ClassShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of ClassShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">ClassShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
	
	/// <summary>
	/// Serializer ClassShapeSerializer for DomainClass ClassShape.
	/// </summary>
	public partial class ClassShapeSerializer : ClassShapeSerializerBase
	{
	   #region Constructor
	   /// <summary>
	   /// ClassShapeSerializer Constructor
	   /// </summary>
	   public ClassShapeSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer CommentBoxShapeSerializerBase for DomainClass CommentBoxShape.
	/// </summary>
	public abstract partial class CommentBoxShapeSerializerBase : DslDiagrams::NodeShapeSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// CommentBoxShapeSerializerBase Constructor
	   /// </summary>
	   protected CommentBoxShapeSerializerBase ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of CommentBoxShape.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"commentBoxShape"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of CommentBoxShape.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"commentBoxShapeMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of CommentBoxShape in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one CommentBoxShape instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the CommentBoxShape element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentBoxShape instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentBoxShape instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      CommentBoxShape instanceOfCommentBoxShape = element as CommentBoxShape;
	      global::System.Diagnostics.Debug.Assert(instanceOfCommentBoxShape != null, "Expecting an instance of CommentBoxShape");
	
	      // FillColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribFillColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "fillColor");
	         if (attribFillColor != null)
	         {
	            global::System.Drawing.Color valueOfFillColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribFillColor, out valueOfFillColor))
	            {
	               instanceOfCommentBoxShape.FillColor = valueOfFillColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "fillColor", typeof(global::System.Drawing.Color), attribFillColor);
	            }
	         }
	      }
	      // OutlineColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutlineColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outlineColor");
	         if (attribOutlineColor != null)
	         {
	            global::System.Drawing.Color valueOfOutlineColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribOutlineColor, out valueOfOutlineColor))
	            {
	               instanceOfCommentBoxShape.OutlineColor = valueOfOutlineColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outlineColor", typeof(global::System.Drawing.Color), attribOutlineColor);
	            }
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTextColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "textColor");
	         if (attribTextColor != null)
	         {
	            global::System.Drawing.Color valueOfTextColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribTextColor, out valueOfTextColor))
	            {
	               instanceOfCommentBoxShape.TextColor = valueOfTextColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "textColor", typeof(global::System.Drawing.Color), attribTextColor);
	            }
	         }
	      }
	      // OutlineDashStyle
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutlineDashStyle = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outlineDashStyle");
	         if (attribOutlineDashStyle != null)
	         {
	            global::System.Drawing.Drawing2D.DashStyle valueOfOutlineDashStyle;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Drawing2D.DashStyle>(serializationContext, attribOutlineDashStyle, out valueOfOutlineDashStyle))
	            {
	               instanceOfCommentBoxShape.OutlineDashStyle = valueOfOutlineDashStyle;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outlineDashStyle", typeof(global::System.Drawing.Drawing2D.DashStyle), attribOutlineDashStyle);
	            }
	         }
	      }
	      // OutlineThickness
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutlineThickness = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outlineThickness");
	         if (attribOutlineThickness != null)
	         {
	            global::System.Single valueOfOutlineThickness;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Single>(serializationContext, attribOutlineThickness, out valueOfOutlineThickness))
	            {
	               instanceOfCommentBoxShape.OutlineThickness = valueOfOutlineThickness;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outlineThickness", typeof(global::System.Single), attribOutlineThickness);
	            }
	         }
	      }
	      // Visible
	      if (!serializationContext.Result.Failed)
	      {
	         string attribVisible = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "visible");
	         if (attribVisible != null)
	         {
	            global::System.Boolean valueOfVisible;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribVisible, out valueOfVisible))
	            {
	               instanceOfCommentBoxShape.Visible = valueOfVisible;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "visible", typeof(global::System.Boolean), attribVisible);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentBoxShape instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of CommentBoxShape based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized CommentBoxShape, a new CommentBoxShape instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created CommentBoxShape instance, or null if the reader is not pointing to a serialized CommentBoxShape instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "CommentBoxShape" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "CommentBoxShape".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               CommentBoxShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentBoxShapeSerializerBase;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of CommentBoxShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of CommentBoxShape.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new CommentBoxShape instance should be created.</param>
	   /// <returns>Created CommentBoxShape instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new CommentBoxShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from CommentBoxShape, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from CommentBoxShape.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentBoxShape.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including CommentBoxShape itself) instance of CommentBoxShape based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "CommentBoxShape" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "CommentBoxShape".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               CommentBoxShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentBoxShapeSerializerBase;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of CommentBoxShape based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, CommentBoxShape.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentBoxShape, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentBoxShape.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentBoxShape.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized CommentBoxShape instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentBoxShape instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the CommentBoxShape instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the CommentBoxShape instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one CommentBoxShape instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentBoxShape instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentBoxShape instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      CommentBoxShape instanceOfCommentBoxShape = element as CommentBoxShape;
	      global::System.Diagnostics.Debug.Assert(instanceOfCommentBoxShape != null, "Expecting an instance of CommentBoxShape");
	
	      // FillColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfCommentBoxShape.FillColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "fillColor", serializedPropValue);
	         }
	      }
	      // OutlineColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfCommentBoxShape.OutlineColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outlineColor", serializedPropValue);
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfCommentBoxShape.TextColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "textColor", serializedPropValue);
	         }
	      }
	      // OutlineDashStyle
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Drawing2D.DashStyle propValue = instanceOfCommentBoxShape.OutlineDashStyle;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Drawing2D.DashStyle>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outlineDashStyle", serializedPropValue);
	         }
	      }
	      // OutlineThickness
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Single propValue = instanceOfCommentBoxShape.OutlineThickness;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Single>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outlineThickness", serializedPropValue);
	         }
	      }
	      // Visible
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfCommentBoxShape.Visible;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "visible", serializedPropValue);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentBoxShape instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given CommentBoxShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentBoxShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the CommentBoxShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentBoxShape instance = element as CommentBoxShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentBoxShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentBoxShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
	
	/// <summary>
	/// Serializer CommentBoxShapeSerializer for DomainClass CommentBoxShape.
	/// </summary>
	public partial class CommentBoxShapeSerializer : CommentBoxShapeSerializerBase
	{
	   #region Constructor
	   /// <summary>
	   /// CommentBoxShapeSerializer Constructor
	   /// </summary>
	   public CommentBoxShapeSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer EnumShapeSerializerBase for DomainClass EnumShape.
	/// </summary>
	public abstract partial class EnumShapeSerializerBase : DslDiagrams::CompartmentShapeSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// EnumShapeSerializerBase Constructor
	   /// </summary>
	   protected EnumShapeSerializerBase ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of EnumShape.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"enumShape"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of EnumShape.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"enumShapeMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of EnumShape in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one EnumShape instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the EnumShape element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory EnumShape instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory EnumShape instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      EnumShape instanceOfEnumShape = element as EnumShape;
	      global::System.Diagnostics.Debug.Assert(instanceOfEnumShape != null, "Expecting an instance of EnumShape");
	
	      // FillColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribFillColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "fillColor");
	         if (attribFillColor != null)
	         {
	            global::System.Drawing.Color valueOfFillColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribFillColor, out valueOfFillColor))
	            {
	               instanceOfEnumShape.FillColor = valueOfFillColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "fillColor", typeof(global::System.Drawing.Color), attribFillColor);
	            }
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTextColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "textColor");
	         if (attribTextColor != null)
	         {
	            global::System.Drawing.Color valueOfTextColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribTextColor, out valueOfTextColor))
	            {
	               instanceOfEnumShape.TextColor = valueOfTextColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "textColor", typeof(global::System.Drawing.Color), attribTextColor);
	            }
	         }
	      }
	      // OutlineColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutlineColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outlineColor");
	         if (attribOutlineColor != null)
	         {
	            global::System.Drawing.Color valueOfOutlineColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribOutlineColor, out valueOfOutlineColor))
	            {
	               instanceOfEnumShape.OutlineColor = valueOfOutlineColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outlineColor", typeof(global::System.Drawing.Color), attribOutlineColor);
	            }
	         }
	      }
	      // Visible
	      if (!serializationContext.Result.Failed)
	      {
	         string attribVisible = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "visible");
	         if (attribVisible != null)
	         {
	            global::System.Boolean valueOfVisible;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Boolean>(serializationContext, attribVisible, out valueOfVisible))
	            {
	               instanceOfEnumShape.Visible = valueOfVisible;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "visible", typeof(global::System.Boolean), attribVisible);
	            }
	         }
	      }
	      // OutlineThickness
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutlineThickness = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outlineThickness");
	         if (attribOutlineThickness != null)
	         {
	            global::System.Single valueOfOutlineThickness;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Single>(serializationContext, attribOutlineThickness, out valueOfOutlineThickness))
	            {
	               instanceOfEnumShape.OutlineThickness = valueOfOutlineThickness;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outlineThickness", typeof(global::System.Single), attribOutlineThickness);
	            }
	         }
	      }
	      // OutlineDashStyle
	      if (!serializationContext.Result.Failed)
	      {
	         string attribOutlineDashStyle = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "outlineDashStyle");
	         if (attribOutlineDashStyle != null)
	         {
	            global::System.Drawing.Drawing2D.DashStyle valueOfOutlineDashStyle;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Drawing2D.DashStyle>(serializationContext, attribOutlineDashStyle, out valueOfOutlineDashStyle))
	            {
	               instanceOfEnumShape.OutlineDashStyle = valueOfOutlineDashStyle;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "outlineDashStyle", typeof(global::System.Drawing.Drawing2D.DashStyle), attribOutlineDashStyle);
	            }
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods deserializes nested XML elements inside the passed-in element.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	   /// reader at the open tag of the first child XML element.
	   /// This method will read as many child XML elements as it can. It returns under three circumstances:
	   /// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	   ///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	   ///    immediately and do nothing.
	   /// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	   /// 3) EOF.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory EnumShape instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadElements(serializationContext, element, reader);
	
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of EnumShape based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized EnumShape, a new EnumShape instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created EnumShape instance, or null if the reader is not pointing to a serialized EnumShape instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "EnumShape" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "EnumShape".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               EnumShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EnumShapeSerializerBase;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of EnumShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of EnumShape.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new EnumShape instance should be created.</param>
	   /// <returns>Created EnumShape instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new EnumShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from EnumShape, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from EnumShape.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EnumShape.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including EnumShape itself) instance of EnumShape based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "EnumShape" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "EnumShape".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               EnumShapeSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EnumShapeSerializerBase;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of EnumShape based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, EnumShape.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EnumShape, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EnumShape.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EnumShape.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized EnumShape instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">EnumShape instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the EnumShape instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EnumShape instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one EnumShape instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">EnumShape instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">EnumShape instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      EnumShape instanceOfEnumShape = element as EnumShape;
	      global::System.Diagnostics.Debug.Assert(instanceOfEnumShape != null, "Expecting an instance of EnumShape");
	
	      // FillColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfEnumShape.FillColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, string.Empty) != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "fillColor", serializedPropValue);
	            }
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfEnumShape.TextColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "textColor", serializedPropValue);
	         }
	      }
	      // OutlineColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfEnumShape.OutlineColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outlineColor", serializedPropValue);
	         }
	      }
	      // Visible
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Boolean propValue = instanceOfEnumShape.Visible;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Boolean>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(serializedPropValue, "true") != 0)
	            {   // No need to write the value out if it's the same as default value.
	               EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "visible", serializedPropValue);
	            }
	         }
	      }
	      // OutlineThickness
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Single propValue = instanceOfEnumShape.OutlineThickness;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Single>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outlineThickness", serializedPropValue);
	         }
	      }
	      // OutlineDashStyle
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Drawing2D.DashStyle propValue = instanceOfEnumShape.OutlineDashStyle;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Drawing2D.DashStyle>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "outlineDashStyle", serializedPropValue);
	         }
	      }
	   }
	
	   /// <summary>
	   /// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">EnumShape instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>        
	   protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WriteElements(serializationContext, element, writer);
	
	   }
	
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EnumShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EnumShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EnumShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EnumShape instance = element as EnumShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EnumShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EnumShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
	
	/// <summary>
	/// Serializer EnumShapeSerializer for DomainClass EnumShape.
	/// </summary>
	public partial class EnumShapeSerializer : EnumShapeSerializerBase
	{
	   #region Constructor
	   /// <summary>
	   /// EnumShapeSerializer Constructor
	   /// </summary>
	   public EnumShapeSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer AssociationConnectorSerializerBase for DomainClass AssociationConnector.
	/// </summary>
	public abstract partial class AssociationConnectorSerializerBase : DslDiagrams::BinaryLinkShapeSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// AssociationConnectorSerializerBase Constructor
	   /// </summary>
	   protected AssociationConnectorSerializerBase ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// Cannot be serialized.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	
	   /// <summary>
	   /// Cannot be monikerized.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return string.Empty; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// AssociationConnector is abstract and cannot be instantiated, so this method throws NotSupportedException.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the AssociationConnector element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory AssociationConnector instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory AssociationConnector instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      AssociationConnector instanceOfAssociationConnector = element as AssociationConnector;
	      global::System.Diagnostics.Debug.Assert(instanceOfAssociationConnector != null, "Expecting an instance of AssociationConnector");
	
	      // Color
	      if (!serializationContext.Result.Failed)
	      {
	         string attribColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "color");
	         if (attribColor != null)
	         {
	            global::System.Drawing.Color valueOfColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribColor, out valueOfColor))
	            {
	               instanceOfAssociationConnector.Color = valueOfColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "color", typeof(global::System.Drawing.Color), attribColor);
	            }
	         }
	      }
	      // DashStyle
	      if (!serializationContext.Result.Failed)
	      {
	         string attribDashStyle = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "dashStyle");
	         if (attribDashStyle != null)
	         {
	            global::System.Drawing.Drawing2D.DashStyle valueOfDashStyle;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Drawing2D.DashStyle>(serializationContext, attribDashStyle, out valueOfDashStyle))
	            {
	               instanceOfAssociationConnector.DashStyle = valueOfDashStyle;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "dashStyle", typeof(global::System.Drawing.Drawing2D.DashStyle), attribDashStyle);
	            }
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTextColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "textColor");
	         if (attribTextColor != null)
	         {
	            global::System.Drawing.Color valueOfTextColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribTextColor, out valueOfTextColor))
	            {
	               instanceOfAssociationConnector.TextColor = valueOfTextColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "textColor", typeof(global::System.Drawing.Color), attribTextColor);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of AssociationConnector based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized AssociationConnector, a new AssociationConnector instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created AssociationConnector instance, or null if the reader is not pointing to a serialized AssociationConnector instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         // Check for derived classes of "AssociationConnector".
	         if (this.derivedClasses == null)
	            this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	         global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	         DslModeling::DomainClassInfo derivedClass = null;
	         if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	         {   // New derived class instance.
	            AssociationConnectorSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AssociationConnectorSerializerBase;
	            global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	            result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of AssociationConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of AssociationConnector.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new AssociationConnector instance should be created.</param>
	   /// <returns>Created AssociationConnector instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      // Abstract class, cannot be serialized.
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from AssociationConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from AssociationConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AssociationConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including AssociationConnector itself) instance of AssociationConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         // Check for derived classes of "AssociationConnector".
	         if (this.derivedClassMonikers == null)
	            this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	         global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	         DslModeling::DomainClassInfo derivedClass = null;
	         if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	         {   // New derived class moniker instance.
	            AssociationConnectorSerializerBase derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AssociationConnectorSerializerBase;
	            global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	            result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of AssociationConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, AssociationConnector.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from AssociationConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from AssociationConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AssociationConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized AssociationConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">AssociationConnector instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the AssociationConnector instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the AssociationConnector instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      // Instance of AssociationConnector cannot be monikerized.
	      EFModelSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "AssociationConnector");
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one AssociationConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">AssociationConnector instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      throw new global::System.NotSupportedException();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">AssociationConnector instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      AssociationConnector instanceOfAssociationConnector = element as AssociationConnector;
	      global::System.Diagnostics.Debug.Assert(instanceOfAssociationConnector != null, "Expecting an instance of AssociationConnector");
	
	      // Color
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfAssociationConnector.Color;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "color", serializedPropValue);
	         }
	      }
	      // DashStyle
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Drawing2D.DashStyle propValue = instanceOfAssociationConnector.DashStyle;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Drawing2D.DashStyle>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "dashStyle", serializedPropValue);
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfAssociationConnector.TextColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "textColor", serializedPropValue);
	         }
	      }
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given AssociationConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AssociationConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the AssociationConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			AssociationConnector instance = element as AssociationConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of AssociationConnector!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AssociationConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
	
	/// <summary>
	/// Serializer AssociationConnectorSerializer for DomainClass AssociationConnector.
	/// </summary>
	public partial class AssociationConnectorSerializer : AssociationConnectorSerializerBase
	{
	   #region Constructor
	   /// <summary>
	   /// AssociationConnectorSerializer Constructor
	   /// </summary>
	   public AssociationConnectorSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer UnidirectionalConnectorSerializer for DomainClass UnidirectionalConnector.
	/// </summary>
	public partial class UnidirectionalConnectorSerializer : AssociationConnectorSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// UnidirectionalConnectorSerializer Constructor
	   /// </summary>
	   public UnidirectionalConnectorSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of UnidirectionalConnector.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"unidirectionalConnector"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of UnidirectionalConnector.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"unidirectionalConnectorMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of UnidirectionalConnector in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one UnidirectionalConnector instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the UnidirectionalConnector element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory UnidirectionalConnector instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               base.ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of UnidirectionalConnector based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized UnidirectionalConnector, a new UnidirectionalConnector instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created UnidirectionalConnector instance, or null if the reader is not pointing to a serialized UnidirectionalConnector instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "UnidirectionalConnector" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "UnidirectionalConnector".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               UnidirectionalConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as UnidirectionalConnectorSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of UnidirectionalConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of UnidirectionalConnector.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new UnidirectionalConnector instance should be created.</param>
	   /// <returns>Created UnidirectionalConnector instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new UnidirectionalConnector(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from UnidirectionalConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from UnidirectionalConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(UnidirectionalConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including UnidirectionalConnector itself) instance of UnidirectionalConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "UnidirectionalConnector" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "UnidirectionalConnector".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               UnidirectionalConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as UnidirectionalConnectorSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of UnidirectionalConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, UnidirectionalConnector.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from UnidirectionalConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from UnidirectionalConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(UnidirectionalConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized UnidirectionalConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">UnidirectionalConnector instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the UnidirectionalConnector instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the UnidirectionalConnector instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one UnidirectionalConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">UnidirectionalConnector instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         base.WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given UnidirectionalConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">UnidirectionalConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the UnidirectionalConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			UnidirectionalConnector instance = element as UnidirectionalConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of UnidirectionalConnector!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">UnidirectionalConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer BidirectionalConnectorSerializer for DomainClass BidirectionalConnector.
	/// </summary>
	public partial class BidirectionalConnectorSerializer : AssociationConnectorSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// BidirectionalConnectorSerializer Constructor
	   /// </summary>
	   public BidirectionalConnectorSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of BidirectionalConnector.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"bidirectionalConnector"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of BidirectionalConnector.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"bidirectionalConnectorMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of BidirectionalConnector in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one BidirectionalConnector instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the BidirectionalConnector element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory BidirectionalConnector instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               base.ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of BidirectionalConnector based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized BidirectionalConnector, a new BidirectionalConnector instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created BidirectionalConnector instance, or null if the reader is not pointing to a serialized BidirectionalConnector instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "BidirectionalConnector" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "BidirectionalConnector".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               BidirectionalConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as BidirectionalConnectorSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of BidirectionalConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of BidirectionalConnector.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new BidirectionalConnector instance should be created.</param>
	   /// <returns>Created BidirectionalConnector instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new BidirectionalConnector(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from BidirectionalConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from BidirectionalConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(BidirectionalConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including BidirectionalConnector itself) instance of BidirectionalConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "BidirectionalConnector" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "BidirectionalConnector".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               BidirectionalConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as BidirectionalConnectorSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of BidirectionalConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, BidirectionalConnector.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from BidirectionalConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from BidirectionalConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(BidirectionalConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized BidirectionalConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">BidirectionalConnector instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the BidirectionalConnector instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the BidirectionalConnector instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one BidirectionalConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">BidirectionalConnector instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         base.WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given BidirectionalConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">BidirectionalConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the BidirectionalConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			BidirectionalConnector instance = element as BidirectionalConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of BidirectionalConnector!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">BidirectionalConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer GeneralizationConnectorSerializer for DomainClass GeneralizationConnector.
	/// </summary>
	public partial class GeneralizationConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// GeneralizationConnectorSerializer Constructor
	   /// </summary>
	   public GeneralizationConnectorSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of GeneralizationConnector.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"generalizationConnector"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of GeneralizationConnector.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"generalizationConnectorMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of GeneralizationConnector in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one GeneralizationConnector instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the GeneralizationConnector element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory GeneralizationConnector instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               base.ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory GeneralizationConnector instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      GeneralizationConnector instanceOfGeneralizationConnector = element as GeneralizationConnector;
	      global::System.Diagnostics.Debug.Assert(instanceOfGeneralizationConnector != null, "Expecting an instance of GeneralizationConnector");
	
	      // Color
	      if (!serializationContext.Result.Failed)
	      {
	         string attribColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "color");
	         if (attribColor != null)
	         {
	            global::System.Drawing.Color valueOfColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribColor, out valueOfColor))
	            {
	               instanceOfGeneralizationConnector.Color = valueOfColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "color", typeof(global::System.Drawing.Color), attribColor);
	            }
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTextColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "textColor");
	         if (attribTextColor != null)
	         {
	            global::System.Drawing.Color valueOfTextColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribTextColor, out valueOfTextColor))
	            {
	               instanceOfGeneralizationConnector.TextColor = valueOfTextColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "textColor", typeof(global::System.Drawing.Color), attribTextColor);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of GeneralizationConnector based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized GeneralizationConnector, a new GeneralizationConnector instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created GeneralizationConnector instance, or null if the reader is not pointing to a serialized GeneralizationConnector instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "GeneralizationConnector" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "GeneralizationConnector".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               GeneralizationConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as GeneralizationConnectorSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of GeneralizationConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of GeneralizationConnector.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new GeneralizationConnector instance should be created.</param>
	   /// <returns>Created GeneralizationConnector instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new GeneralizationConnector(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from GeneralizationConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from GeneralizationConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(GeneralizationConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including GeneralizationConnector itself) instance of GeneralizationConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "GeneralizationConnector" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "GeneralizationConnector".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               GeneralizationConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as GeneralizationConnectorSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of GeneralizationConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, GeneralizationConnector.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from GeneralizationConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from GeneralizationConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(GeneralizationConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized GeneralizationConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">GeneralizationConnector instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the GeneralizationConnector instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the GeneralizationConnector instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one GeneralizationConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">GeneralizationConnector instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         base.WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">GeneralizationConnector instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      GeneralizationConnector instanceOfGeneralizationConnector = element as GeneralizationConnector;
	      global::System.Diagnostics.Debug.Assert(instanceOfGeneralizationConnector != null, "Expecting an instance of GeneralizationConnector");
	
	      // Color
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfGeneralizationConnector.Color;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "color", serializedPropValue);
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfGeneralizationConnector.TextColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "textColor", serializedPropValue);
	         }
	      }
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given GeneralizationConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">GeneralizationConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the GeneralizationConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			GeneralizationConnector instance = element as GeneralizationConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of GeneralizationConnector!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">GeneralizationConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer CommentConnectorSerializer for DomainClass CommentConnector.
	/// </summary>
	public partial class CommentConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// CommentConnectorSerializer Constructor
	   /// </summary>
	   public CommentConnectorSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of CommentConnector.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"commentConnector"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of CommentConnector.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"commentConnectorMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of CommentConnector in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one CommentConnector instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the CommentConnector element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentConnector instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               base.ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory CommentConnector instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      CommentConnector instanceOfCommentConnector = element as CommentConnector;
	      global::System.Diagnostics.Debug.Assert(instanceOfCommentConnector != null, "Expecting an instance of CommentConnector");
	
	      // Color
	      if (!serializationContext.Result.Failed)
	      {
	         string attribColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "color");
	         if (attribColor != null)
	         {
	            global::System.Drawing.Color valueOfColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribColor, out valueOfColor))
	            {
	               instanceOfCommentConnector.Color = valueOfColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "color", typeof(global::System.Drawing.Color), attribColor);
	            }
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTextColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "textColor");
	         if (attribTextColor != null)
	         {
	            global::System.Drawing.Color valueOfTextColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribTextColor, out valueOfTextColor))
	            {
	               instanceOfCommentConnector.TextColor = valueOfTextColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "textColor", typeof(global::System.Drawing.Color), attribTextColor);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of CommentConnector based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized CommentConnector, a new CommentConnector instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created CommentConnector instance, or null if the reader is not pointing to a serialized CommentConnector instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "CommentConnector" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "CommentConnector".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               CommentConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentConnectorSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of CommentConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of CommentConnector.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new CommentConnector instance should be created.</param>
	   /// <returns>Created CommentConnector instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	         return new CommentConnector(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from CommentConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from CommentConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including CommentConnector itself) instance of CommentConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "CommentConnector" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "CommentConnector".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               CommentConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as CommentConnectorSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of CommentConnector based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, CommentConnector.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentConnector, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from CommentConnector.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(CommentConnector.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized CommentConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentConnector instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the CommentConnector instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the CommentConnector instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one CommentConnector instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentConnector instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         base.WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">CommentConnector instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      CommentConnector instanceOfCommentConnector = element as CommentConnector;
	      global::System.Diagnostics.Debug.Assert(instanceOfCommentConnector != null, "Expecting an instance of CommentConnector");
	
	      // Color
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfCommentConnector.Color;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "color", serializedPropValue);
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfCommentConnector.TextColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "textColor", serializedPropValue);
	         }
	      }
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given CommentConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the CommentConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			CommentConnector instance = element as CommentConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of CommentConnector!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">CommentConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Serializer EFModelDiagramSerializer for DomainClass EFModelDiagram.
	/// </summary>
	public partial class EFModelDiagramSerializer : DslDiagrams::DiagramSerializer
	{
	   #region Constructor
	   /// <summary>
	   /// EFModelDiagramSerializer Constructor
	   /// </summary>
	   public EFModelDiagramSerializer ()
	      : base ()
	   {
	   }
	   #endregion
	
	
	   #region Miscellaneous methods
	
	   /// <summary>
	   /// Reset the serializer
	   /// </summary>
	   /// <remarks>
	   /// Clear the cached information about any derived classes so that it is recalculated.
	   /// </remarks>
	   public override void Reset()
	   {
	      base.Reset();
	      this.derivedClasses = null;
	      this.derivedClassMonikers = null;
	   }
	
	   #endregion
	
	   #region Public Properties
	   /// <summary>
	   /// This is the XML tag name used to serialize an instance of EFModelDiagram.
	   /// </summary>
	   public override string XmlTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"eFModelDiagram"; }
	   }
	
	   /// <summary>
	   /// This is the XML tag name used to serialize a monikerized instance of EFModelDiagram.
	   /// </summary>
	   public override string MonikerTagName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"eFModelDiagramMoniker"; }
	   }
	
	   /// <summary>
	   /// This is the name of the XML attribute that stores the moniker of EFModelDiagram in a serialized monikerized instance.
	   /// </summary>
	   public override string MonikerAttributeName
	   {
	      [global::System.Diagnostics.DebuggerStepThrough]
	      get { return @"Id"; }
	   }
	   #endregion
	
	   #region Read Methods
	   /// <summary>
	   /// Public Read() method that deserializes one EFModelDiagram instance from XML.
	   /// </summary>
	   /// <remarks>
	   /// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	   /// of the EFModelDiagram element that is about to be deserialized. 
	   /// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	   /// or the close tag of the parent element (or EOF).
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory EFModelDiagram instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      #endregion
	
	      // Read properties serialized as XML attributes.
	      ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      // Read nested XML elements.
	      if (!serializationContext.Result.Failed)
	      {
	         if (!reader.IsEmptyElement)
	         {
	            // Read to the start of the first child element.
	            DslModeling::SerializationUtilities.SkipToFirstChild(reader);
	
	            // Read any extension element data under this XML element
	            EFModelSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
	
	            // Read nested XML elements, they can be either properties serialized as XML elements, or child 
	            // model elements.
	            while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	            {
	               base.ReadElements(serializationContext, element, reader);
	               if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	               {
	                  // Encountered one unknown XML element, skip it and keep reading.
	                  EFModelSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
	                  DslModeling::SerializationUtilities.Skip(reader);
	               }
	            }
	         }
	      }
	
	      // Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
	      DslModeling::SerializationUtilities.Skip(reader);
	   }
	
	
	   /// <summary>
	   /// This method deserializes all properties that are serialized as XML attributes.
	   /// </summary>
	   /// <remarks>
	   /// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	   /// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">In-memory EFModelDiagram instance that will get the deserialized data.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	   {
	      // Always call the base class so any extensions are deserialized
	      base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
	      EFModelDiagram instanceOfEFModelDiagram = element as EFModelDiagram;
	      global::System.Diagnostics.Debug.Assert(instanceOfEFModelDiagram != null, "Expecting an instance of EFModelDiagram");
	
	      // FillColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribFillColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "fillColor");
	         if (attribFillColor != null)
	         {
	            global::System.Drawing.Color valueOfFillColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribFillColor, out valueOfFillColor))
	            {
	               instanceOfEFModelDiagram.FillColor = valueOfFillColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "fillColor", typeof(global::System.Drawing.Color), attribFillColor);
	            }
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         string attribTextColor = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "textColor");
	         if (attribTextColor != null)
	         {
	            global::System.Drawing.Color valueOfTextColor;
	            if (DslModeling::SerializationUtilities.TryGetValue<global::System.Drawing.Color>(serializationContext, attribTextColor, out valueOfTextColor))
	            {
	               instanceOfEFModelDiagram.TextColor = valueOfTextColor;
	            }
	            else
	            {   // Invalid property value, ignored.
	               EFModelSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "textColor", typeof(global::System.Drawing.Color), attribTextColor);
	            }
	         }
	      }
	   }
	
	   #region TryCreateInstance
	   /// <summary>
	   /// This method creates a correct instance of EFModelDiagram based on the tag currently pointed by the reader. If the reader
	   /// is positioned at a serialized EFModelDiagram, a new EFModelDiagram instance will be created in the given partition, otherwise 
	   /// null is returned.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new elements should be created.</param>
	   /// <returns>Created EFModelDiagram instance, or null if the reader is not pointing to a serialized EFModelDiagram instance.</returns>
	   public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::ModelElement result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "EFModelDiagram" instance.
	            result = this.CreateInstance(serializationContext, reader, partition);
	         }
	         else
	         {   // Check for derived classes of "EFModelDiagram".
	            if (this.derivedClasses == null)
	               this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class instance.
	               EFModelDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EFModelDiagramSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates an instance of EFModelDiagram based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	   /// to be pointed at a serialized instance of EFModelDiagram.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="partition">Partition in which new EFModelDiagram instance should be created.</param>
	   /// <returns>Created EFModelDiagram instance.</returns>
	   protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	   {
	      string idStr = reader.GetAttribute ("Id");
	      try
	      {
	         global::System.Guid id;
	         if (string.IsNullOrEmpty(idStr))
	         {   // Create a default Id.
	            id = global::System.Guid.NewGuid();
	            EFModelSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
	         }
	         else
	         {
	            id = new global::System.Guid (idStr);
	         }
	            string typeStr = reader.GetAttribute("type"); 
	            if (!string.IsNullOrEmpty(typeStr))
	           {
	                global::System.Type type = global::System.Type.GetType(typeStr);
	                if (type != typeof(EFModelDiagram) && !type.IsSubclassOf(typeof(EFModelDiagram)))
	               {
	                   throw new global::System.NotSupportedException();
	               }
	                return (DslModeling::ModelElement)global::System.Activator.CreateInstance(type, partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	            } 
	            else
	            {
	             return new EFModelDiagram(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
	            }
	      }
	      catch (global::System.ArgumentNullException /* anEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      catch (global::System.OverflowException /* ofEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
	      }
	      return null;
	   }
	
	   /// <summary>
	   /// Stores a mapping from XmlTagName to DomainClassInfo that derives from EFModelDiagram, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
	   /// <summary>
	   /// Construct the apping from XmlTagName to DomainClassInfo that derives from EFModelDiagram.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
	      this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EFModelDiagram.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            global::System.Type descendentType = descendent.ImplementationClass;
	            if (!descendentType.IsAbstract)
	            {
	               DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	               if (descendentSerializer != null)
	               {
	                  string descendentXmlTagName = descendentSerializer.XmlTagName;
	                  if (!string.IsNullOrEmpty (descendentXmlTagName))
	                  {
	                     global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
	                     this.derivedClasses.Add (descendentXmlTagName, descendent);
	                  }
	               }
	            }
	            else
	            {   // Ignore abstract derived classes because they cannot be instantiated directly.
	            }
	         }
	      }
	   }
	   #endregion
	
	   #region TryCreateMonikerInstance
	   /// <summary>
	   /// This method creates a Moniker of the correct derived (including EFModelDiagram itself) instance of EFModelDiagram based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (reader != null);
	      if (reader == null)
	         throw new global::System.ArgumentNullException ("reader");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (partition != null);
	      if (partition == null)
	         throw new global::System.ArgumentNullException ("partition");
	      #endregion
	
	      DslModeling::Moniker result = null;
	      if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
	      {
	         string localName = reader.LocalName;
	         if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
	         {   // New "EFModelDiagram" moniker instance.
	            result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	         }
	         else
	         {   // Check for derived classes of "EFModelDiagram".
	            if (this.derivedClassMonikers == null)
	               this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
	            global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
	            DslModeling::DomainClassInfo derivedClass = null;
	            if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
	            {   // New derived class moniker instance.
	               EFModelDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EFModelDiagramSerializer;
	               global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
	               result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	            }
	         }
	      }
	
	      return result;
	   }
	
	   /// <summary>
	   /// This method creates a Moniker of EFModelDiagram based on the tag currently pointed by the reader.
	   /// </summary>
	   /// <remarks>
	   /// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	   /// not move the reader; the reader should remain at the same position when this method returns.
	   /// </remarks>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="reader">XmlReader to read serialized data from.</param>
	   /// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	   /// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	   /// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>
	   /// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	   protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	   {
	      string monikerString = EFModelSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
	      if (string.IsNullOrEmpty(monikerString))
	      {
	         EFModelSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
	         return null;
	      }
	      try
	      {   // Normalize the Id.
	         global::System.Guid id = new global::System.Guid(monikerString);
	         monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
	         DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, EFModelDiagram.DomainClassId, partition.Store), partition.Store);
	         // Set location info if possible.
	         result.Location = serializationContext.Location;
	         global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
	         if (xmlLineInfo != null)
	         {
	            result.Line = xmlLineInfo.LineNumber;
	            result.Column = xmlLineInfo.LinePosition;
	         }
	         return result;
	      }
	      catch (global::System.FormatException /* fEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	      catch (global::System.OverflowException /* oEx */)
	      {
	         EFModelSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
	         return null;
	      }
	   }
	
	   /// <summary>
	   /// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EFModelDiagram, created on demand.
	   /// </summary>
	   private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
	   /// <summary>
	   /// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EFModelDiagram.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	   private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	   {
	      global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
	      this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
	      DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EFModelDiagram.DomainClassId);
	      global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
	      global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
	      if (descendents != null)
	      {
	         foreach (DslModeling::DomainClassInfo descendent in descendents)
	         {
	            DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
	            if (descendentSerializer != null)
	            {
	               string descendentMonikerTagName = descendentSerializer.MonikerTagName;
	               if (!string.IsNullOrEmpty (descendentMonikerTagName))
	               {
	                  global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
	                  this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
	               }
	            }
	         }
	      }
	   }
	   #endregion
	   #endregion
	
	   #region Write Methods
	   /// <summary>
	   /// Public WriteMoniker() method that writes a monikerized EFModelDiagram instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">EFModelDiagram instance to be monikerized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="sourceRolePlayer">Source element that references the EFModelDiagram instance being monikerized.</param>
	   /// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EFModelDiagram instance being monikerized.</param>
	   public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
	      if (sourceRolePlayer == null)
	         throw new global::System.ArgumentNullException ("sourceRolePlayer");
	      global::System.Diagnostics.Debug.Assert (relSerializer != null);
	      if (relSerializer == null)
	         throw new global::System.ArgumentNullException ("relSerializer");
	      #endregion
	
	      string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
	      global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
	      writer.WriteStartElement(this.MonikerTagName);
	      EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Public Write() method that serializes one EFModelDiagram instance into XML.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">EFModelDiagram instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param>
	   /// <param name="rootElementSettings">
	   /// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	   /// information like schema target namespace, version, etc.
	   /// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	   /// without this parameter).
	   /// </param>
	   public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	   {
	      #region Check Parameters
	      global::System.Diagnostics.Debug.Assert (serializationContext != null);
	      if (serializationContext == null)
	         throw new global::System.ArgumentNullException ("serializationContext");
	      global::System.Diagnostics.Debug.Assert (element != null);
	      if (element == null)
	         throw new global::System.ArgumentNullException ("element");
	      global::System.Diagnostics.Debug.Assert (writer != null);
	      if (writer == null)
	         throw new global::System.ArgumentNullException ("writer");
	      #endregion
	
	      // Write start of element, including schema target namespace if specified.
	      if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
	      {
	         writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
	         DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
	      }
	      else
	      {
	         writer.WriteStartElement(this.XmlTagName);
	      }
	
	      // Write version info (in the format 1.2.3.4), if necessary
	      if (rootElementSettings != null && rootElementSettings.Version != null)
	         writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
	      // Write out element Id.
	      writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	                writer.WriteAttributeString("type", element.GetType().FullName);
	      WritePropertiesAsAttributes(serializationContext, element, writer);
	      // Write out any extension data if this is the root element
	      if (rootElementSettings != null && !serializationContext.Result.Failed)
	      {
	         EFModelSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
	      }
	
	      if (!serializationContext.Result.Failed)
	      {
	         // Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
	         base.WriteElements(serializationContext, element, writer);
	      }
	
	      writer.WriteEndElement();
	   }
	
	   /// <summary>
	   /// Write all properties that need to be serialized as XML attributes.
	   /// </summary>
	   /// <param name="serializationContext">Serialization context.</param>
	   /// <param name="element">EFModelDiagram instance to be serialized.</param>
	   /// <param name="writer">XmlWriter to write serialized data to.</param> 
	   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	   protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	   {
	      // Always call the base class so any extensions are serialized
	      base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
	      EFModelDiagram instanceOfEFModelDiagram = element as EFModelDiagram;
	      global::System.Diagnostics.Debug.Assert(instanceOfEFModelDiagram != null, "Expecting an instance of EFModelDiagram");
	
	      // FillColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfEFModelDiagram.FillColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "fillColor", serializedPropValue);
	         }
	      }
	      // TextColor
	      if (!serializationContext.Result.Failed)
	      {
	         global::System.Drawing.Color propValue = instanceOfEFModelDiagram.TextColor;
	         string serializedPropValue = DslModeling::SerializationUtilities.GetString<global::System.Drawing.Color>(serializationContext, propValue);
	         if (!serializationContext.Result.Failed)
	         {
	            EFModelSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "textColor", serializedPropValue);
	         }
	      }
	   }
	   #endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EFModelDiagram instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EFModelDiagram instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EFModelDiagram instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EFModelDiagram instance = element as EFModelDiagram;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EFModelDiagram!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EFModelDiagram instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior EFModelSerializationBehavior.
	/// This is the abstract base of the double-derived implementation.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
	public abstract class EFModelSerializationBehaviorBase : DslModeling::DomainXmlSerializationBehavior
	{
		///<summary>
		/// The xml namespace used by this domain model when serializing
		///</summary>
		public const string DomainModelXmlNamespace = @"http://schemas.microsoft.com/dsltools/EFModel";
	
		#region Member Variables
		/// <summary>
		/// A list of DomainClass Ids mapped to DomainClassXmlSerializer types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry> serializerTypes;
	
		/// <summary>
		/// A list of xml namespaces mapped to domain model types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry> namespaceEntries;
	
		#endregion
	
		#region Constructor
		/// <summary>
		/// Protected constructor to prevent public instantiation.
		/// </summary>
		protected EFModelSerializationBehaviorBase() : base() { }
		#endregion
		
		#region Protected Methods
		/// <summary>
		/// Allows custom serializers to be added.
		/// Base implementation doesn't do anything.
		/// </summary>
		/// <returns>Custom serializer types, null or empty list if there's no custom serializer types.</returns>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected virtual global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> CustomSerializerTypes
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
		#endregion
	
		#region Public Methods
		/// <summary>
		/// This provides a mapping from DomainClass Id to DomainXmlSerializer implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> AllSerializers
		{
			get
			{
				if (EFModelSerializationBehavior.serializerTypes == null)
				{
					global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> customSerializerTypes = this.CustomSerializerTypes;
					int customSerializerCount = (customSerializerTypes == null ? 0 : customSerializerTypes.Count);
					EFModelSerializationBehavior.serializerTypes = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry>(30 + customSerializerCount);
	
					#region Serializers defined in this model
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelRoot.DomainClassId, typeof(ModelRootSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelClass.DomainClassId, typeof(ModelClassSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelAttribute.DomainClassId, typeof(ModelAttributeSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Comment.DomainClassId, typeof(CommentSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelEnum.DomainClassId, typeof(ModelEnumSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelEnumValue.DomainClassId, typeof(ModelEnumValueSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(DesignElement.DomainClassId, typeof(DesignElementSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelDiagramData.DomainClassId, typeof(ModelDiagramDataSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Association.DomainClassId, typeof(AssociationSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(UnidirectionalAssociation.DomainClassId, typeof(UnidirectionalAssociationSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassHasAttributes.DomainClassId, typeof(ClassHasAttributesSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelRootHasComments.DomainClassId, typeof(ModelRootHasCommentsSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Generalization.DomainClassId, typeof(GeneralizationSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(BidirectionalAssociation.DomainClassId, typeof(BidirectionalAssociationSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelRootHasEnums.DomainClassId, typeof(ModelRootHasEnumsSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelEnumHasValues.DomainClassId, typeof(ModelEnumHasValuesSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelRootHasClasses.DomainClassId, typeof(ModelRootHasClassesSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(CommentReferencesSubjects.DomainClassId, typeof(CommentReferencesSubjectsSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(CommentReferencesClasses.DomainClassId, typeof(CommentReferencesClassesSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(CommentReferencesEnums.DomainClassId, typeof(CommentReferencesEnumsSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ModelRootHasModelDiagrams.DomainClassId, typeof(ModelRootHasModelDiagramsSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(ClassShape.DomainClassId, typeof(ClassShapeSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(CommentBoxShape.DomainClassId, typeof(CommentBoxShapeSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EnumShape.DomainClassId, typeof(EnumShapeSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(AssociationConnector.DomainClassId, typeof(AssociationConnectorSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(UnidirectionalConnector.DomainClassId, typeof(UnidirectionalConnectorSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(BidirectionalConnector.DomainClassId, typeof(BidirectionalConnectorSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(GeneralizationConnector.DomainClassId, typeof(GeneralizationConnectorSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(CommentConnector.DomainClassId, typeof(CommentConnectorSerializer)));
					EFModelSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EFModelDiagram.DomainClassId, typeof(EFModelDiagramSerializer)));
					#endregion
					
					// Custom ones
					if (customSerializerCount > 0)
					{
						EFModelSerializationBehavior.serializerTypes.AddRange(customSerializerTypes);
					}
				}
				return EFModelSerializationBehavior.serializerTypes.AsReadOnly();
			}
		}
		
		/// <summary>
		/// This provides a mapping from xml namespaces to domain model implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		//[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerNamespaceEntry> AllNamespaces
		{
			get
			{
				if (EFModelSerializationBehavior.namespaceEntries == null)
				{
					EFModelSerializationBehavior.namespaceEntries = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry>();
					EFModelSerializationBehavior.namespaceEntries.Add(new DslModeling::DomainXmlSerializerNamespaceEntry(DomainModelXmlNamespace, typeof(global::Sawczyn.EFDesigner.EFModel.EFModelDomainModel)));
				}
				return EFModelSerializationBehavior.namespaceEntries.AsReadOnly();
			}
		}
		
		#endregion
	}
	
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior EFModelSerializationBehavior.
	/// This is the concrete type of the double-derived implementation.
	/// </summary>
	public sealed partial class EFModelSerializationBehavior : EFModelSerializationBehaviorBase
	{
		#region Singleton Instance
		/// <summary>
		/// Singleton instance.
		/// </summary>
		private static EFModelSerializationBehavior instance;
	
		/// <summary>
		/// Singleton instance.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		public static EFModelSerializationBehavior Instance
		{
			get
			{	// No need for synchronization. Most likely running in single-thread environment, and creating an extra instance
				// doesn't really hurt.
				if (EFModelSerializationBehavior.instance == null)
					EFModelSerializationBehavior.instance = new EFModelSerializationBehavior ();
				return EFModelSerializationBehavior.instance;
			}
		}
	
		/// <summary>
		/// Private constructor to prevent public instantiation.
		/// </summary>
		private EFModelSerializationBehavior() : base() { }
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Moniker resolver for serialization behavior EFModelSerializationBehavior.
	/// </summary>
	public partial class EFModelSerializationBehaviorMonikerResolver : EFModelSerializationBehaviorMonikerResolverBase
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public EFModelSerializationBehaviorMonikerResolver(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base(store,directory)
		{
		}
	}
	
	/// <summary>
	/// Base moniker resolver for serialization behavior EFModelSerializationBehavior.
	/// </summary>
	public partial class EFModelSerializationBehaviorMonikerResolverBase : DslModeling::SimpleMonikerResolver
	{
		#region Member Variables
		/// <summary>
		/// Look-up directory to find serializers for domain classes.
		/// </summary>
		private DslModeling::DomainXmlSerializerDirectory directory;
		#endregion
	
		#region Constructor
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public EFModelSerializationBehaviorMonikerResolverBase(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base (store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException("directory");
			#endregion
	
			this.directory = directory;
		}
		#endregion
	
		#region Base Overrides
		/// <summary>
		/// Tells if a DomainClass can be monikerized or not.
		/// </summary>
		/// <param name="domainClassInfo">DomainClassInfo of the DomainClass to be checked.</param>
		/// <returns>True if the DomainClass can be monikerized, false otherwise.</returns>
		protected override bool CanBeMonikerized(DslModeling::DomainClassInfo domainClassInfo)
		{
			if (this.IsDisposed || this.directory == null || domainClassInfo == null)
				return false;
				
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(domainClassInfo.Id);
			if (serializer != null)
				return (!string.IsNullOrEmpty(serializer.MonikerTagName));
			return false;
		}
			
		/// <summary>
		/// Calculate the fully qualified monikerized string of the given ModelElement.
		/// </summary>
		/// <param name="mel">ModelElement to get moniker from.</param>
		/// <returns>Calculated moniker string, returns null or empty string is the given ModelElement cannot be monikerized.</returns>
		protected override string CalculateQualifiedName(DslModeling::ModelElement mel)
		{
			if (this.IsDisposed || this.directory == null || mel == null)
				return string.Empty;
	
			string result = string.Empty;
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(mel.GetDomainClass().Id);
			if (serializer != null)
				result = serializer.CalculateQualifiedName(this.directory, mel);
			return result;
		}
		
		/// <summary>
		/// Called at the end of synchronization when they're unresolved monikers.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		protected override void OnUnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				EFModelSerializationBehaviorSerializationMessages.UnresolvedMoniker(serializationResult, moniker);
			}
		}
		
		/// <summary>
		/// Called when resolving a moniker causes a duplicate link to be created.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Moniker that causes duplicate link to be created.</param>
		protected override void OnMonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				EFModelSerializationBehaviorSerializationMessages.MonikerResolvedToDuplicateLink(serializationResult, moniker);
			}
			base.OnMonikerResolvedToDuplicateLink(serializationResult, moniker);
		}
		
		/// <summary>
		/// Called when two new elements are giving the same moniker, which will cause ambiguity during moniker resolution.
		/// </summary>
		/// <param name="context">SerializationContext to store error/warning messages.</param>
		/// <param name="moniker">Moniker that both elements give.</param>
		/// <param name="element1">The first element giving the moniker.</param>
		/// <param name="element2">The second element giving the same moniker.</param>
		protected override void OnAmbiguousMoniker(DslModeling::SerializationContext context, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			if (context != null)
			{
				EFModelSerializationBehaviorSerializationMessages.AmbiguousMoniker(context, moniker, element1, element2);
			}
			base.OnAmbiguousMoniker(context, moniker, element1, element2);
		}
		
		/// <summary>
		/// Error message for UnresolvedMonikerException.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected override string UnresolvedMonikerExceptionMessage
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return EFModelSerializationBehaviorSerializationMessages.ResourceManager.GetString("CannotOpenDocument"); }
		}
		#endregion
	}
}

namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Utility class to provide serialization messages
	/// </summary>
	public static partial class EFModelSerializationBehaviorSerializationMessages
	{
		/// <summary>
		/// ResourceManager to get serialization messages from.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
		public static global::System.Resources.ResourceManager ResourceManager
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return EFModelDomainModel.SingletonResourceManager; }
		}
	
		#region Warnings
		/// <summary>
		/// Add a warning for ambiguous schemas.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace to be resolved.</param>
		/// <param name="schemaPath">The schema that is used to resolve the definition of the target namespace.</param>
		public static void AmbiguousSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace, string schemaPath)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(schemaPath));
			if (string.IsNullOrEmpty(schemaPath))
				throw new global::System.ArgumentNullException("schemaPath");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousSchema"),
					targetNamespace,
					schemaPath
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a full-form relationship seems to be serialized in short-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingFullFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingFullFormRelationship"),
					reader.Name,
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a short-form relationship seems to be serialized in full-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingShortFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingShortFormRelationship"),
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for invalid property value with the given type, which will be ignored.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this warning.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void IgnoredPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("IgnoredPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for missing "Id" property.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="newId">Auto-generated new Id.</param>
		public static void MissingId(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Guid newId)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingId"),
					newId.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
			
		/// <summary>
		/// Add an warning for moniker resolved to duplicate link. The moniker will be ignored.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Offending moniker.</param>
		public static void MonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MonikerResolvedToDuplicateLink"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
		
		/// <summary>
		/// Add a warning for no schema found for the given target namespace, schema validation will be skipped in this case.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace that cannot be resolved.</param>
		public static void NoSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("NoSchema"),
					targetNamespace
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for schema validation error.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="message">Validation message reported from schema validation.</param>
		public static void SchemaValidationError(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string message)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(message));
			if (string.IsNullOrEmpty(message))
				throw new global::System.ArgumentNullException("message");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				message,
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an warning for unexpected XML element.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		public static void UnexpectedXmlElement(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
				
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnexpectedXmlElement"),
					reader.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	
		#region Errors
		/// <summary>
		/// Add an error for ambiguous moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="moniker">The ambiguous moniker string.</param>
		/// <param name="element1">The first element using the given moniker.</param>
		/// <param name="element2">The second element using the given moniker.</param>
		public static void AmbiguousMoniker(DslModeling::SerializationContext serializationContext, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			global::System.Diagnostics.Debug.Assert(element1 != null);
			if (element1 == null)
				throw new global::System.ArgumentNullException("element1");
			global::System.Diagnostics.Debug.Assert(element2 != null);
			if (element2 == null)
				throw new global::System.ArgumentNullException("element2");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousMoniker"),
					moniker,
					DslModeling::SerializationUtilities.GetElementName(element1),
					DslModeling::SerializationUtilities.GetElementName(element2)
				),
				null	// No location info available
			);
		}
		
		/// <summary>
		/// Add an error for not able to monikerize an instance of the given DomainClass.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="domainClassName">Name of the DomainClass whose instance cannot be monikerized.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Generated code.")]	
		public static void CannotMonikerizeElement(DslModeling::SerializationContext serializationContext, string domainClassName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(domainClassName));
			if (string.IsNullOrEmpty(domainClassName))
				throw new global::System.ArgumentNullException("domainClassName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext.Result,
				null,	/* no location available for this error, because save failed. */
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("CannotMonikerizeElement"),
					domainClassName
				),
				0,
				0
			);
		}
		
		/// <summary>
		/// Add an error for dangling relationship instance.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type name of the relationship.</param>
		public static void DanglingRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(relationshipType));
			if (string.IsNullOrEmpty(relationshipType))
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("DanglingRelationship"),
					relationshipType
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for invalid property value with given type.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this error.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void InvalidPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("InvalidPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for missing moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="monikerAttributeName">Name of the attribute that should hold the moniker.</param>
		public static void MissingMoniker(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string monikerAttributeName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerAttributeName));
			if (string.IsNullOrEmpty(monikerAttributeName))
				throw new global::System.ArgumentNullException("monikerAttributeName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingMoniker"),
					monikerAttributeName
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for unresolved moniker.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		public static void UnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnresolvedMoniker"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
	
		/// <summary>
		/// Add an error for Version mismatch.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="expectedVersion">The version that's expected.</param>
		/// <param name="actualVersion">Actual version from the file.</param>
		public static void VersionMismatch(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Version expectedVersion, global::System.Version actualVersion)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(expectedVersion != null);
			if (expectedVersion == null)
				throw new global::System.ArgumentNullException("expectedVersion");
			global::System.Diagnostics.Debug.Assert(actualVersion != null);
			if (actualVersion == null)
				throw new global::System.ArgumentNullException("actualVersion");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("VersionMismatch"), 
					actualVersion.ToString(4), 
					expectedVersion.ToString(4)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	}
}
namespace Sawczyn.EFDesigner.EFModel
{
	/// <summary>
	/// Provides an implementation of the IDomainModelSerializer interface
	/// that can be used to serialize / deserialize the EFModel domain model.
	/// </summary>
	/// <remarks>Double-derived class - the default implementation is in EFModelDomainModelSerializerBase.
	/// This class exist so users can customize behavior easily.</remarks>
	[global::System.ComponentModel.Composition.Export(typeof(DslModeling::IDomainModelSerializer))]
	[DslModeling::DomainModelSerializer(typeof(global::Sawczyn.EFDesigner.EFModel.EFModelDomainModel), global::Sawczyn.EFDesigner.EFModel.EFModelSerializationBehavior.DomainModelXmlNamespace, "efmodel")]
	public partial class EFModelDomainModelSerializer : EFModelDomainModelSerializerBase
	{
	}
	
	
	/// <summary>
	/// Base class that implements IDomainModelSerializer
	/// </summary>
	public abstract partial class EFModelDomainModelSerializerBase : DslModeling::IDomainModelSerializer
	{
	
		#region Public properties
	
		/// <summary>
		/// The XML namespace used when serializing the domain model
		/// </summary>
		public virtual string DomainModelNamespace
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return global::Sawczyn.EFDesigner.EFModel.EFModelSerializationBehavior.DomainModelXmlNamespace; }
		}
	
		/// <summary>
		/// Returns true: this DSL can be serialized / deserialized directly.
		/// </summary>
		public virtual bool IsSerializable
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return true; }
		}
	
		/// <summary>
		/// The type of the domain model
		/// </summary>
		public virtual global::System.Type DomainModelType
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return typeof(global::Sawczyn.EFDesigner.EFModel.EFModelDomainModel); }
		}
	
		/// <summary>
		/// File extension used for model files of this kind of domain model
		/// </summary>
		/// <remarks>If a domain model type cannot be serialized independently, or cannot
		/// be serialized to a file, it should return null or empty.</remarks>
		public string ModelFileExtension
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return "efmodel"; }
		}
	
		#endregion
		
		
		#region Load / Save model methods
		
		/// <summary>
		/// Loads a ModelRoot instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="partition">Partition in which the new ModelRoot instance will be created.</param>
		/// <param name="fileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded ModelRoot instance.</returns>
		public virtual DslModeling::ModelElement LoadModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition partition, 
			string fileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (partition == null) { throw new global::System.ArgumentNullException("partition"); }
			if (string.IsNullOrEmpty(fileName)) { throw new global::System.ArgumentNullException("fileName"); }
	
			return EFModelSerializationHelper.Instance.LoadModel(serializationResult, partition, fileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given model root to the given file, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="fileName">Name of the file in which the ModelRoot instance will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the ModelRoot instance.</param>
		public void SaveModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string fileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("fileName")) { throw new global::System.ArgumentNullException("fileName"); }
	
			global::Sawczyn.EFDesigner.EFModel.ModelRoot rootElement = modelRoot as global::Sawczyn.EFDesigner.EFModel.ModelRoot;
			if (rootElement == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::Sawczyn.EFDesigner.EFModel.EFModelDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
	
			}
	
			EFModelSerializationHelper.Instance.SaveModel(serializationResult, rootElement, fileName,encoding, true);
		}
	
		#endregion
	
		#region Load / Save model and diagram methods
	
		/// <summary>
		/// Calculates and returns the name of the diagram file for the specified model file
		/// </summary>
		/// <param name="modelFileName">The relevant model file name</param>
		/// <returns>Name of the associated diagram file</returns>
		/// <remarks>There is no guarantee that either the model file or the calculated diagram file exist.</remarks>
		public virtual string CalculateDiagramFileName(string modelFileName)
		{
			if (string.IsNullOrEmpty(modelFileName))
			{
				throw new global::System.ArgumentNullException("modelFileName");
			}
			return modelFileName + ".diagram";
		}
	
		/// <summary>
		/// Loads a ModelRoot instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="modelPartition">Partition in which the new ModelRoot instance will be created.</param>
		/// <param name="modelFileName">Name of the file from which the ModelRoot instance will be deserialized.</param>
		/// <param name="diagramPartition">Partition in which the new EFModelDiagram instance will be created.</param>
		/// <param name="diagramFileName">Name of the file from which the EFModelDiagram instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded ModelRoot instance.</returns>
		public DslModeling::ModelElement LoadModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition modelPartition, 
			string modelFileName, 
			DslModeling::Partition diagramPartition, 
			string diagramFileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelPartition == null) { throw new global::System.ArgumentNullException("modelPartition"); }
			if (string.IsNullOrEmpty(modelFileName)) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagramPartition == null) { throw new global::System.ArgumentNullException("diagramPartition"); }
			if (string.IsNullOrEmpty(diagramFileName)) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			return EFModelSerializationHelper.Instance.LoadModelAndDiagram(serializationResult, modelPartition, modelFileName, diagramPartition, diagramFileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given ModelRoot and EFModelDiagram to the given files, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">ModelRoot instance to be saved.</param>
		/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
		/// <param name="diagram">EFModelDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the diagram.</param>
		public void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string modelFileName, 
			DslModeling::ModelElement diagram, 
			string diagramFileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("modelFileName")) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagram == null) { throw new global::System.ArgumentNullException("diagram"); }
			if (string.IsNullOrEmpty("diagramFileName")) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			global::Sawczyn.EFDesigner.EFModel.ModelRoot typedRoot = modelRoot as global::Sawczyn.EFDesigner.EFModel.ModelRoot;
			if (typedRoot == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::Sawczyn.EFDesigner.EFModel.EFModelDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
			}
			global::Sawczyn.EFDesigner.EFModel.EFModelDiagram typedDiagram = diagram as global::Sawczyn.EFDesigner.EFModel.EFModelDiagram;
			if (typedDiagram == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::Sawczyn.EFDesigner.EFModel.EFModelDomainModel.SingletonResourceManager.GetString("InvalidSaveDiagramType"),
					diagram.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "diagram");
			}
	
			EFModelSerializationHelper.Instance.SaveModelAndDiagram(serializationResult, typedRoot, modelFileName, typedDiagram, diagramFileName, encoding, true);
		}
	
		#endregion
		
	}
}


