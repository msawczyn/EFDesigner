<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".cs" #>
<#@ include file="Dsl\PathMerge.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<#
	if(this.Dsl.Explorer == null)
	{
#>
//
// This source file is empty because this DSL does not define a model explorer.
//
<#
	}
	else
	{
		string dslName = this.Dsl.Name;
		bool hasPaths = false;

		foreach (DomainPath path in this.Dsl.Explorer.Behavior.HiddenNodes)
		{
			// create each path, extract the domain rel and class ID
			if ( path.Segments.Count != 0)
			{
				hasPaths = true;
				break;
			}
		}
		
		ExplorerBehavior expBehavior = DslDefinesExplorerBehavior.GetExplorerBehavior( this.Dsl);	
		bool hasTreeNodeCustomSetting = (expBehavior != null) ? (expBehavior.CustomNodeSettings.Count != 0) : false;
		
		bool hasExplorerCustomPropertyDisplayed = false;
		if ( hasTreeNodeCustomSetting )
		{
			// Check to see if there's any PropertyDisplayPath under each CustomExplorerSetting
			foreach(ExplorerNodeSettings explorerNodeSettings in expBehavior.CustomNodeSettings)
			{
				System.Collections.ObjectModel.ReadOnlyCollection<ExplorerNodeSettingsHasPropertyDisplayedPath> coll = DomainRoleInfo.GetElementLinks<ExplorerNodeSettingsHasPropertyDisplayedPath>(explorerNodeSettings, ExplorerNodeSettingsHasPropertyDisplayedPath.ExplorerNodeSettingsDomainRoleId);
				ExplorerNodeSettingsHasPropertyDisplayedPath link = (coll != null && coll.Count != 0) ? coll[0] : null;
				PropertyPath propPath = (link != null) ? DomainRoleInfo.GetRolePlayer(link, ExplorerNodeSettingsHasPropertyDisplayedPath.PropertyDisplayedPathDomainRoleId) as PropertyPath
														: null;

				if ( propPath != null && propPath.Property != null )
				{
					hasExplorerCustomPropertyDisplayed = true;
					break;
				}
			}
		}
		
		

		string namespaceString = CodeGenerationUtilities.GetPackageNamespace(this.Dsl);
#>

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslShell = global::Microsoft.VisualStudio.Modeling.Shell;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

<#
		if(!string.IsNullOrEmpty(namespaceString))
		{
#>
namespace <#= namespaceString #>
{
<#
			PushIndent("\t");
		}
#>
/// <summary>
/// Double-derived class to allow easier code customization.
/// </summary>
internal partial class <#= dslName #>Explorer : <#= dslName #>ExplorerBase
{
	/// <summary>
	/// Constructs a new <#= dslName #>Explorer.
	/// </summary>
	public <#= dslName #>Explorer(global::System.IServiceProvider serviceProvider)
		: base(serviceProvider)
	{
		Init();
	}

	partial void Init();
}

/// <summary>
/// Control hosted in the <#= dslName #>ExplorerToolWindow.
/// </summary>
internal abstract class <#= dslName #>ExplorerBase : DslShell::ModelExplorerTreeContainer
{
	/// <summary>
	/// Constructs a new <#= dslName #>ExplorerBase.
	/// </summary>
	protected <#= dslName #>ExplorerBase(global::System.IServiceProvider serviceProvider) : base(serviceProvider)
	{
<#
			if ( hasPaths ) 
			{
#>		try
		{	
			// Adds hidden path to hide elements from the explorer
<# 
				foreach (DomainPath path in this.Dsl.Explorer.Behavior.HiddenNodes)
				{
					// create each path, extract the domain rel and class ID
					if ( path.Segments.Count == 0)
					{
						continue;
					}
		  
					string guids = string.Empty;
					for (int i = 0; i < path.Segments.Count; i++)
					{
						PathSegment eachSeg = path.Segments[i];
						string fullTypeName = CodeGenerationUtilities.GetSegmentOutputType(eachSeg);
						if (fullTypeName != null && fullTypeName.Length > 0)
						{
							guids += fullTypeName + ".DomainClassId";
							if ( i != path.Segments.Count - 1)
							{
								guids += ", ";
							}
						}
					}
					if ( guids.Length != 0)
					{
#>			this.AddHiddenPath( new global::System.Guid[] { <#= guids #> }); 
<#
					}
				}
			}
#>		
<#
			if ( hasPaths ) 
			{
#>		}
		catch (global::System.InvalidOperationException)
		{
			// Each hidden path specified needs to have odd number of guid entries.  The entries will alternative between
			// DomainRelationshipID and DomainClassID. The guids list should also start out with a DomainRelationshipID.
			// This exception will be swallowed...
			global::System.Diagnostics.Debug.Fail("Each hidden path specified needs to have odd number of guid entries.\r\nPlease update the HiddenNodes section under ExplorerBehavior in the DSL file\r\nso the Model Explorer can hide element properly.");
		}
<#			} 
#>
<#
			if (hasTreeNodeCustomSetting)
			{
#>
		
		// Adds custom tree node settings...
		global::System.Resources.ResourceManager resourceManager = <#= this.Dsl.GetFullName(true) #>DomainModel.SingletonResourceManager;
		
<#
				ExplorerBehavior behavior = DslDefinesExplorerBehavior.GetExplorerBehavior( this.DslLibrary);
				foreach(ExplorerNodeSettings explorerNodeSettings in behavior.CustomNodeSettings)
				{
					string eachCall = string.Empty;
					
					string imageInfo = string.Empty;
					if(!String.IsNullOrEmpty(explorerNodeSettings.IconToDisplay))
					{
						imageInfo  = "DslDiagrams::ImageHelper.GetImage(";
						imageInfo += "resourceManager.GetObject(\"";
						imageInfo += explorerNodeSettings.Class.Name;
						imageInfo += "ExplorerImage";
						imageInfo += "\"))";
						
					}
					
					eachCall = "this.AddExplorerNodeCustomSetting(";
					eachCall += explorerNodeSettings.Class.GetFullName(true);
					eachCall += ".DomainClassId, ";
					eachCall += "\r\n						";
					eachCall += imageInfo.Length != 0 ? imageInfo.ToString() : "null";
					eachCall += ", ";
					eachCall += "\r\n						";
					eachCall += explorerNodeSettings.ShowsDomainClass ? "true" : "false";
					eachCall += ");";
				
#>		<#= eachCall #> 
<# 
			}
#><#
		}
		
			if ( hasExplorerCustomPropertyDisplayed )
			{
				// Profer a call back and pass along to the base class
#>		
		// Add a call back to provide ModelElementTreeNode TreeNode name in the Model Explorer
		this.GetModelElementDisplayNameEventHandler = new DslShell.GetModelElementDisplayNameEventHandler(GetModelElementDisplayName);
<#
		}
		
#>	}



	/// <summary>
	/// Create IElementVisitor
	/// </summary>
	/// <returns>IElementVisitor</returns>
	protected override DslModeling::IElementVisitor CreateElementVisitor()
	{
		return new DslShell::ExplorerElementVisitor(this);
	}

	/// <summary>
	/// Specifies the context menu that should be shown for the model explorer.
	///</summary>
	protected override global::System.ComponentModel.Design.CommandID ContextMenuCommandId
	{
		get
		{
			return Constants.<#= dslName #>ExplorerMenu;
		}
	}
	
	/// <summary>
	/// Returns the root elements domain class Id. The is the very top level tree node in the TreeView
	///</summary>
	protected override global::System.Guid RootElementDomainClassId
	{
		get { return <#= this.Dsl.Editor.RootClass.GetFullName(true) #>.DomainClassId; }
	}
	
	/// <summary>
	/// Returns the root elements to be displayed in the explorer.
	///</summary>
	protected override global::System.Collections.IList FindRootElements(DslModeling::Store store)
	{
		return store.ElementDirectory.FindElements( this.RootElementDomainClassId);
	}
<#
			if ( hasExplorerCustomPropertyDisplayed )
			{
				// We need to generate the call back here
#>		
	/// <summary>
	/// Method to supply the name for ModelElementTreeNode object in the TreeView.
	/// </summary>
	/// <param name="modelElement">Element to be displayed in the tree node</param>
	/// <returns>Name shown in the Model Explorer</returns>
	private string GetModelElementDisplayName(DslModeling::ModelElement modelElement)
	{
		string treeNodeDisplayName = null;
		DslModeling::DomainDataDirectory directory = modelElement.Store.DomainDataDirectory;
		DslModeling::DomainPropertyInfo domainPropertyInfo = null;
		DslModeling::ModelElement redirectedElement = null;
		
		switch ( modelElement.GetDomainClass().Id.ToString( "D", System.Globalization.CultureInfo.InvariantCulture) )
		{
<#
				ExplorerBehavior behavior = DslDefinesExplorerBehavior.GetExplorerBehavior( this.DslLibrary);
				foreach(ExplorerNodeSettings explorerNodeSettings in behavior.CustomNodeSettings)
				{
					System.Collections.ObjectModel.ReadOnlyCollection<ExplorerNodeSettingsHasPropertyDisplayedPath> coll = DomainRoleInfo.GetElementLinks<ExplorerNodeSettingsHasPropertyDisplayedPath>(explorerNodeSettings, ExplorerNodeSettingsHasPropertyDisplayedPath.ExplorerNodeSettingsDomainRoleId);
					ExplorerNodeSettingsHasPropertyDisplayedPath link = (coll != null && coll.Count != 0) ? coll[0] : null;
					PropertyPath propPath = (link != null) ? DomainRoleInfo.GetRolePlayer(link, ExplorerNodeSettingsHasPropertyDisplayedPath.PropertyDisplayedPathDomainRoleId) as PropertyPath
													: null;
			
					DomainPath domainPath = (propPath != null) ? propPath.PathToProperty : null;
					DomainProperty domainProp = (propPath != null) ? propPath.Property : null;
					if ( domainProp != null )
					{
						DomainClass eachClass = explorerNodeSettings.Class;
						string fullName = eachClass.GetFullName(true) ;

#>
			case "<#= eachClass.Id.ToString("D", System.Globalization.CultureInfo.InvariantCulture) #>":	// <#= eachClass.Name #>.DomainClassId
<#
						// we need to iterate for each children as well.
						System.Collections.ObjectModel.ReadOnlyCollection<DomainClass> allDescendants = eachClass.AllDescendants;
						foreach ( DomainClass eachDescendent in allDescendants)
						{
#>
			case "<#= eachDescendent.Id.ToString("D", System.Globalization.CultureInfo.InvariantCulture) #>":	// <#= eachDescendent.Name #>.DomainClassId
<#
						}
#>
			{
<#
						if ( domainPath != null && domainPath.Segments.Count > 0 )
						{
							// user specified a designated path which points to a different model element. Do the traversal
#>				<#= eachClass.GetFullName( true) #> instanceOf<#= eachClass.Name.TrimStart('@')  #> = modelElement as <#= eachClass.GetFullName( true)  #>;
<#					
							PushIndent("\t");
							GeneratePathMethodBody(domainPath, "instanceOf" + eachClass.Name.TrimStart('@'), "mapped" + eachClass.Name.TrimStart('@'), null, domainPath.Segments.Count, BreakOutSwitch);
							PopIndent();
#>

				domainPropertyInfo = directory.FindDomainProperty( <#= domainProp.Class.GetFullName( true) #>.<#=domainProp.Name #>DomainPropertyId);
				redirectedElement = mapped<#=eachClass.Name.TrimStart('@')#>;
<#
						}
						else
						{
							// use simply specifies a domain property for the current modelElement.
#>				domainPropertyInfo = directory.FindDomainProperty( <#= domainProp.Class.GetFullName( true) #>.<#=domainProp.Name #>DomainPropertyId);
				redirectedElement = modelElement;
<#
						}
#>			}			
			break;
			
<#
					}	
				}
#>	
		}
		
		if (domainPropertyInfo != null && redirectedElement != null)
		{
			// Get the name based on the designated domian property
			treeNodeDisplayName = domainPropertyInfo.GetValue(redirectedElement) as string;
		}
		else
		{
			// The passed in modelElement does not have a DomainPath specified. Try access the default name from the element.
			DslModeling::DomainClassInfo.TryGetName(modelElement, out treeNodeDisplayName);
		}
		return treeNodeDisplayName;
	}
<#
		}	
#>
}
<#
		if(!string.IsNullOrEmpty(namespaceString))
		{
			PopIndent();
#>
}
<#
		
		}
	}
#>	


<#+
	internal string NoReturnNull(PathSegment segment)
	{
		return "";
	}
	
	internal string BreakOutSwitch(PathSegment segment)
	{
		return @"break;";
	}
	
#>