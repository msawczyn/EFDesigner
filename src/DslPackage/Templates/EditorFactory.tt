<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #><#@ 
output extension=".cs" #><#
   string dslName = this.Dsl.Name;
#>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using VSShellInterop = global::Microsoft.VisualStudio.Shell.Interop;
using DslShell = global::Microsoft.VisualStudio.Modeling.Shell;
using MexModeling = global::Mexedge.VisualStudio.Modeling;

namespace <#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>
{
   /// <summary>
   /// Double-derived class to allow easier code customization.
   /// </summary>
   [global::System.Runtime.InteropServices.Guid(Constants.<#= dslName #>EditorFactoryId)]
   internal partial class <#= dslName #>EditorFactory : <#= dslName #>EditorFactoryBase
   {
      /// <summary>
      /// Constructs a new <#= dslName #>EditorFactory.
      /// </summary>
      public <#= dslName #>EditorFactory(global::System.IServiceProvider serviceProvider)
         : base(serviceProvider)
      {
      }
   }

   /// <summary>
   /// Factory for creating our editors
   /// </summary>
   internal abstract class <#= dslName #>EditorFactoryBase : DslShell::ModelingEditorFactory
   {
      /// <summary>
      /// Constructor.
      /// </summary>
      /// <param name="serviceProvider">Service provider used to access VS services.</param>
      protected <#= dslName #>EditorFactoryBase(global::System.IServiceProvider serviceProvider) : base(serviceProvider)
      {
      }

      /// <summary>
      /// Called by the shell to ask the editor to map a logical view to a physical one.
      /// </summary>
      protected override string MapLogicalView(global::System.Guid logicalView, object viewContext)
      {
         if (viewContext is MexModeling::ViewContext context)
            return context.ToString();
         return base.MapLogicalView(logicalView, viewContext);    
      }

      /// <summary>
      /// Called by the shell to ask the editor to create a new document object.
      /// </summary>
      public override DslShell::ModelingDocData CreateDocData(string fileName, VSShellInterop::IVsHierarchy hierarchy, uint itemId)
      {
         // Create the document type supported by this editor.
         return new <#= dslName #>DocData(this.ServiceProvider, typeof(<#= dslName #>EditorFactory).GUID);
      }

      /// <summary>
      /// Called by the shell to ask the editor to create a new view object.
      /// </summary>
      protected override DslShell::ModelingDocView CreateDocView(DslShell::ModelingDocData docData, string physicalView, out string editorCaption)
      {
         // Create the view type supported by this editor.
         editorCaption = " [Default]";
         MexModeling::ViewContext viewContext;
         if (MexModeling::ViewContext.TryParse(physicalView, out viewContext))
         {
            editorCaption = string.Format(" [{0}]", viewContext.DiagramName);
            return new <#= dslName #>DocView(docData, this.ServiceProvider, viewContext.DiagramName);
         }
         return new <#= dslName #>DocView(docData, this.ServiceProvider, string.Empty);
      }
   }
}

